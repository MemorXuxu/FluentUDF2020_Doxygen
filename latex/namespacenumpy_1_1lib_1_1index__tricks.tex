\doxysection{numpy.\+lib.\+index\+\_\+tricks Namespace Reference}
\hypertarget{namespacenumpy_1_1lib_1_1index__tricks}{}\label{namespacenumpy_1_1lib_1_1index__tricks}\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_axis_concatenator}{Axis\+Concatenator}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_c_class}{CClass}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_index_expression}{Index\+Expression}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1nd__grid}{nd\+\_\+grid}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1ndenumerate}{ndenumerate}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1ndindex}{ndindex}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_r_class}{RClass}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_a5c13b01e0e70cb7d2d84f395d0f86300}{ix\+\_\+}} (\texorpdfstring{$\ast$}{*}args)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_adf4ac4b83f7f54453e94d4ecee1d1a81}{fill\+\_\+diagonal}} (a, val, wrap=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_ac694edd29b2fba19799d5fe32a793160}{diag\+\_\+indices}} (n, ndim=2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_a2d7a81810c835cfd761611789629e3cf}{diag\+\_\+indices\+\_\+from}} (arr)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_ad3da3e70944854f0798a82fcf358a67b}{mgrid}} = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1nd__grid}{nd\+\_\+grid}}(sparse=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_a44232e69ee4f91797aa524fb4b9b6ac6}{ogrid}} = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1nd__grid}{nd\+\_\+grid}}(sparse=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_a9646ddcfbc2f9bc39d1cf1982e289472}{r\+\_\+}} = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_r_class}{RClass}}()
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_a58267b86f11dd4b2338c32b8f4c071b4}{c\+\_\+}} = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_c_class}{CClass}}()
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_a699f37c72f6ad14d8065402ca0663230}{index\+\_\+exp}} = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_index_expression}{Index\+Expression}}(maketuple=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1index__tricks_a228c2377e29cf663c8cb0b2ee6230031}{s\+\_\+}} = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_index_expression}{Index\+Expression}}(maketuple=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_ac694edd29b2fba19799d5fe32a793160}\label{namespacenumpy_1_1lib_1_1index__tricks_ac694edd29b2fba19799d5fe32a793160} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!diag\_indices@{diag\_indices}}
\index{diag\_indices@{diag\_indices}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{diag\_indices()}{diag\_indices()}}
{\footnotesize\ttfamily diag\+\_\+indices (\begin{DoxyParamCaption}\item[{}]{n,  }\item[{}]{ndim = {\ttfamily 2} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices to access the main diagonal of an array.

This returns a tuple of indices that can be used to access the main
diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape
(n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for
``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``
for ``i = [0..n-1]``.

Parameters
----------
n : int
  The size, along each dimension, of the arrays for which the returned
  indices can be used.

ndim : int, optional
  The number of dimensions.

See also
--------
diag_indices_from

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Create a set of indices to access the diagonal of a (4, 4) array:

>>> di = np.diag_indices(4)
>>> di
(array([0, 1, 2, 3]), array([0, 1, 2, 3]))
>>> a = np.arange(16).reshape(4, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> a[di] = 100
>>> a
array([[100,   1,   2,   3],
       [  4, 100,   6,   7],
       [  8,   9, 100,  11],
       [ 12,  13,  14, 100]])

Now, we create indices to manipulate a 3-D array:

>>> d3 = np.diag_indices(2, 3)
>>> d3
(array([0, 1]), array([0, 1]), array([0, 1]))

And use it to set the diagonal of an array of zeros to 1:

>>> a = np.zeros((2, 2, 2), dtype=int)
>>> a[d3] = 1
>>> a
array([[[1, 0],
        [0, 0]],
       [[0, 0],
        [0, 1]]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_a2d7a81810c835cfd761611789629e3cf}\label{namespacenumpy_1_1lib_1_1index__tricks_a2d7a81810c835cfd761611789629e3cf} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!diag\_indices\_from@{diag\_indices\_from}}
\index{diag\_indices\_from@{diag\_indices\_from}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{diag\_indices\_from()}{diag\_indices\_from()}}
{\footnotesize\ttfamily diag\+\_\+indices\+\_\+from (\begin{DoxyParamCaption}\item[{}]{arr }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the indices to access the main diagonal of an n-dimensional array.

See `diag_indices` for full details.

Parameters
----------
arr : array, at least 2-D

See Also
--------
diag_indices

Notes
-----
.. versionadded:: 1.4.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_adf4ac4b83f7f54453e94d4ecee1d1a81}\label{namespacenumpy_1_1lib_1_1index__tricks_adf4ac4b83f7f54453e94d4ecee1d1a81} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!fill\_diagonal@{fill\_diagonal}}
\index{fill\_diagonal@{fill\_diagonal}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{fill\_diagonal()}{fill\_diagonal()}}
{\footnotesize\ttfamily fill\+\_\+diagonal (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{val,  }\item[{}]{wrap = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Fill the main diagonal of the given array of any dimensionality.

For an array `a` with ``a.ndim >= 2``, the diagonal is the list of
locations with indices ``a[i, ..., i]`` all identical. This function
modifies the input array in-place, it does not return a value.

Parameters
----------
a : array, at least 2-D.
  Array whose diagonal is to be filled, it gets modified in-place.

val : scalar
  Value to be written on the diagonal, its type must be compatible with
  that of the array a.

wrap : bool
  For tall matrices in NumPy version up to 1.6.2, the
  diagonal "wrapped" after N columns. You can have this behavior
  with this option. This affects only tall matrices.

See also
--------
diag_indices, diag_indices_from

Notes
-----
.. versionadded:: 1.4.0

This functionality can be obtained via `diag_indices`, but internally
this version uses a much faster implementation that never constructs the
indices and uses simple slicing.

Examples
--------
>>> a = np.zeros((3, 3), int)
>>> np.fill_diagonal(a, 5)
>>> a
array([[5, 0, 0],
       [0, 5, 0],
       [0, 0, 5]])

The same function can operate on a 4-D array:

>>> a = np.zeros((3, 3, 3, 3), int)
>>> np.fill_diagonal(a, 4)

We only show a few blocks for clarity:

>>> a[0, 0]
array([[4, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])
>>> a[1, 1]
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 0]])
>>> a[2, 2]
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 4]])

The wrap option affects only tall matrices:

>>> # tall matrices no wrap
>>> a = np.zeros((5, 3),int)
>>> fill_diagonal(a, 4)
>>> a
array([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [0, 0, 0]])

>>> # tall matrices wrap
>>> a = np.zeros((5, 3),int)
>>> fill_diagonal(a, 4, wrap=True)
>>> a
array([[4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [4, 0, 0]])

>>> # wide matrices
>>> a = np.zeros((3, 5),int)
>>> fill_diagonal(a, 4, wrap=True)
>>> a
array([[4, 0, 0, 0, 0],
       [0, 4, 0, 0, 0],
       [0, 0, 4, 0, 0]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_a5c13b01e0e70cb7d2d84f395d0f86300}\label{namespacenumpy_1_1lib_1_1index__tricks_a5c13b01e0e70cb7d2d84f395d0f86300} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!ix\_@{ix\_}}
\index{ix\_@{ix\_}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{ix\_()}{ix\_()}}
{\footnotesize\ttfamily ix\+\_\+ (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{args }\end{DoxyParamCaption})}

\begin{DoxyVerb}Construct an open mesh from multiple sequences.

This function takes N 1-D sequences and returns N outputs with N
dimensions each, such that the shape is 1 in all but one dimension
and the dimension with the non-unit shape value cycles through all
N dimensions.

Using `ix_` one can quickly construct index arrays that will index
the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array
``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.

Parameters
----------
args : 1-D sequences
    Each sequence should be of integer or boolean type.
    Boolean sequences will be interpreted as boolean masks for the
    corresponding dimension (equivalent to passing in
    ``np.nonzero(boolean_sequence)``).

Returns
-------
out : tuple of ndarrays
    N arrays with N dimensions each, with N the number of input
    sequences. Together these arrays form an open mesh.

See Also
--------
ogrid, mgrid, meshgrid

Examples
--------
>>> a = np.arange(10).reshape(2, 5)
>>> a
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> ixgrid = np.ix_([0, 1], [2, 4])
>>> ixgrid
(array([[0],
       [1]]), array([[2, 4]]))
>>> ixgrid[0].shape, ixgrid[1].shape
((2, 1), (1, 2))
>>> a[ixgrid]
array([[2, 4],
       [7, 9]])

>>> ixgrid = np.ix_([True, True], [2, 4])
>>> a[ixgrid]
array([[2, 4],
       [7, 9]])
>>> ixgrid = np.ix_([True, True], [False, False, True, False, True])
>>> a[ixgrid]
array([[2, 4],
       [7, 9]])\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_a58267b86f11dd4b2338c32b8f4c071b4}\label{namespacenumpy_1_1lib_1_1index__tricks_a58267b86f11dd4b2338c32b8f4c071b4} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!c\_@{c\_}}
\index{c\_@{c\_}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{c\_}{c\_}}
{\footnotesize\ttfamily c\+\_\+ = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_c_class}{CClass}}()}

\Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_a699f37c72f6ad14d8065402ca0663230}\label{namespacenumpy_1_1lib_1_1index__tricks_a699f37c72f6ad14d8065402ca0663230} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!index\_exp@{index\_exp}}
\index{index\_exp@{index\_exp}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{index\_exp}{index\_exp}}
{\footnotesize\ttfamily index\+\_\+exp = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_index_expression}{Index\+Expression}}(maketuple=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})}

\Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_ad3da3e70944854f0798a82fcf358a67b}\label{namespacenumpy_1_1lib_1_1index__tricks_ad3da3e70944854f0798a82fcf358a67b} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!mgrid@{mgrid}}
\index{mgrid@{mgrid}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{mgrid}{mgrid}}
{\footnotesize\ttfamily mgrid = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1nd__grid}{nd\+\_\+grid}}(sparse=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})}

\Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_a44232e69ee4f91797aa524fb4b9b6ac6}\label{namespacenumpy_1_1lib_1_1index__tricks_a44232e69ee4f91797aa524fb4b9b6ac6} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!ogrid@{ogrid}}
\index{ogrid@{ogrid}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{ogrid}{ogrid}}
{\footnotesize\ttfamily ogrid = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1nd__grid}{nd\+\_\+grid}}(sparse=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})}

\Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_a9646ddcfbc2f9bc39d1cf1982e289472}\label{namespacenumpy_1_1lib_1_1index__tricks_a9646ddcfbc2f9bc39d1cf1982e289472} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!r\_@{r\_}}
\index{r\_@{r\_}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{r\_}{r\_}}
{\footnotesize\ttfamily r\+\_\+ = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_r_class}{RClass}}()}

\Hypertarget{namespacenumpy_1_1lib_1_1index__tricks_a228c2377e29cf663c8cb0b2ee6230031}\label{namespacenumpy_1_1lib_1_1index__tricks_a228c2377e29cf663c8cb0b2ee6230031} 
\index{numpy.lib.index\_tricks@{numpy.lib.index\_tricks}!s\_@{s\_}}
\index{s\_@{s\_}!numpy.lib.index\_tricks@{numpy.lib.index\_tricks}}
\doxysubsubsection{\texorpdfstring{s\_}{s\_}}
{\footnotesize\ttfamily s\+\_\+ = \mbox{\hyperlink{classnumpy_1_1lib_1_1index__tricks_1_1_index_expression}{Index\+Expression}}(maketuple=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})}

