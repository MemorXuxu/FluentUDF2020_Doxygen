\doxysection{numpy.\+polynomial.\+hermite\+\_\+e Namespace Reference}
\hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e}{}\label{namespacenumpy_1_1polynomial_1_1hermite__e}\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1polynomial_1_1hermite__e_1_1_hermite_e}{HermiteE}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a210967f5364bc7dec862c82be7f13e0d}{poly2herme}} (pol)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_ab8a98bed84ec95667ac010e5193a25d5}{herme2poly}} (c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a2255a72252a47a813c65193878e0bfe4}{hermeline}} (off, scl)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a4614cac0df53382dfda5718f6fcd9f02}{hermefromroots}} (\mbox{\hyperlink{namespacenumpy_1_1lib_1_1polynomial_ad2b400a70d64d17cebe1aea669d8040c}{roots}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a146937f644e40832fc14d76be2d3d7d1}{hermeadd}} (c1, c2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_acc886165b3c87bbcfb4c1b467db195a0}{hermesub}} (c1, c2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a8ee5b2a889bee0966378f4ce1e518c6e}{hermemulx}} (c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a1645caea6a08e08131a810804ad85938}{hermemul}} (c1, c2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a9384771800213f6517bad6e047fb3737}{hermediv}} (c1, c2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_ac494da50fa0502cac1d811b309bb3066}{hermepow}} (c, pow, maxpower=16)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_ae3207ff3a28c13bc040618fa6ddf8b03}{hermeder}} (c, m=1, scl=1, axis=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a88c8def58a032948ed488c867375ae40}{hermeint}} (c, m=1, \mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_adc468c70fb574ebd07287b38d0d0676d}{k}}=\mbox{[}$\,$\mbox{]}, lbnd=0, scl=1, axis=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_aec419c337e974610847479112e8209fc}{hermeval}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, c, tensor=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a6d9c16c758b0d2b71f60697b3372fb09}{hermeval2d}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a2133fa76b05adb22f86e6b5af6c8c537}{hermegrid2d}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a24d3a48234b05e81f63a238e59a18ee8}{hermeval3d}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, z, c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a005047921784658d6da63f8132779469}{hermegrid3d}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, z, c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a3d9f6d4b8c394bfc56b815eb348117f4}{hermevander}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, deg)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a1052a2e9eb566575e113a2dff6b5fcaa}{hermevander2d}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, deg)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_ad2fc607be3dc86543219225b127a87ed}{hermevander3d}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, z, deg)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_afb07ec65c7123e9fd879c948a64e7978}{hermefit}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, deg, rcond=None, \mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aedba2594d8fc1c40b727456402f98c6f}{full}}=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, w=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a0c5c8cf2a078937c6b566d56abfaee7a}{hermecompanion}} (c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a3d97938294447c23464ca9379fa590e7}{hermeroots}} (c)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a0e090243edc7e89ee86702b913e7ec25}{\+\_\+normed\+\_\+hermite\+\_\+e\+\_\+n}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, n)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a171ba5e9abb92c997146c2fe531b58be}{hermegauss}} (deg)
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_ac40564e2e895c9f6eb17372eedcd65cd}{hermeweight}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a627a4bf12279c6e0a2189238fd6e28c3}{hermetrim}} = pu.\+trimcoef
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a2833ef4d10cb0de286946919f307969f}{hermedomain}} = np.\+array(\mbox{[}-\/1, 1\mbox{]})
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a08e802f90b18a554ddff648d448c6043}{hermezero}} = np.\+array(\mbox{[}0\mbox{]})
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a6a7a1e34992a5e4bc1ceb5b2f5a37380}{hermeone}} = np.\+array(\mbox{[}1\mbox{]})
\item 
\mbox{\hyperlink{namespacenumpy_1_1polynomial_1_1hermite__e_a788bbf5a7ef9802a12c36cdfa5075d1e}{hermex}} = np.\+array(\mbox{[}0, 1\mbox{]})
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Objects for dealing with Hermite_e series.

This module provides a number of objects (mostly functions) useful for
dealing with Hermite_e series, including a `HermiteE` class that
encapsulates the usual arithmetic operations.  (General information
on how this module represents and works with such polynomials is in the
docstring for its "parent" sub-package, `numpy.polynomial`).

Constants
---------
- `hermedomain` -- Hermite_e series default domain, [-1,1].
- `hermezero` -- Hermite_e series that evaluates identically to 0.
- `hermeone` -- Hermite_e series that evaluates identically to 1.
- `hermex` -- Hermite_e series for the identity map, ``f(x) = x``.

Arithmetic
----------
- `hermemulx` -- multiply a Hermite_e series in ``P_i(x)`` by ``x``.
- `hermeadd` -- add two Hermite_e series.
- `hermesub` -- subtract one Hermite_e series from another.
- `hermemul` -- multiply two Hermite_e series.
- `hermediv` -- divide one Hermite_e series by another.
- `hermeval` -- evaluate a Hermite_e series at given points.
- `hermeval2d` -- evaluate a 2D Hermite_e series at given points.
- `hermeval3d` -- evaluate a 3D Hermite_e series at given points.
- `hermegrid2d` -- evaluate a 2D Hermite_e series on a Cartesian product.
- `hermegrid3d` -- evaluate a 3D Hermite_e series on a Cartesian product.

Calculus
--------
- `hermeder` -- differentiate a Hermite_e series.
- `hermeint` -- integrate a Hermite_e series.

Misc Functions
--------------
- `hermefromroots` -- create a Hermite_e series with specified roots.
- `hermeroots` -- find the roots of a Hermite_e series.
- `hermevander` -- Vandermonde-like matrix for Hermite_e polynomials.
- `hermevander2d` -- Vandermonde-like matrix for 2D power series.
- `hermevander3d` -- Vandermonde-like matrix for 3D power series.
- `hermegauss` -- Gauss-Hermite_e quadrature, points and weights.
- `hermeweight` -- Hermite_e weight function.
- `hermecompanion` -- symmetrized companion matrix in Hermite_e form.
- `hermefit` -- least-squares fit returning a Hermite_e series.
- `hermetrim` -- trim leading coefficients from a Hermite_e series.
- `hermeline` -- Hermite_e series of given straight line.
- `herme2poly` -- convert a Hermite_e series to a polynomial.
- `poly2herme` -- convert a polynomial to a Hermite_e series.

Classes
-------
- `HermiteE` -- A Hermite_e series class.

See also
--------
`numpy.polynomial`\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a0e090243edc7e89ee86702b913e7ec25}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a0e090243edc7e89ee86702b913e7ec25} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!\_normed\_hermite\_e\_n@{\_normed\_hermite\_e\_n}}
\index{\_normed\_hermite\_e\_n@{\_normed\_hermite\_e\_n}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{\_normed\_hermite\_e\_n()}{\_normed\_hermite\_e\_n()}}
{\footnotesize\ttfamily \+\_\+normed\+\_\+hermite\+\_\+e\+\_\+n (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Evaluate a normalized HermiteE polynomial.

Compute the value of the normalized HermiteE polynomial of degree ``n``
at the points ``x``.


Parameters
----------
x : ndarray of double.
    Points at which to evaluate the function
n : int
    Degree of the normalized HermiteE function to be evaluated.

Returns
-------
values : ndarray
    The shape of the return value is described above.

Notes
-----
.. versionadded:: 1.10.0

This function is needed for finding the Gauss points and integration
weights for high degrees. The values of the standard HermiteE functions
overflow when n >= 207.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_ab8a98bed84ec95667ac010e5193a25d5}\label{namespacenumpy_1_1polynomial_1_1hermite__e_ab8a98bed84ec95667ac010e5193a25d5} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!herme2poly@{herme2poly}}
\index{herme2poly@{herme2poly}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{herme2poly()}{herme2poly()}}
{\footnotesize\ttfamily herme2poly (\begin{DoxyParamCaption}\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert a Hermite series to a polynomial.

Convert an array representing the coefficients of a Hermite series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the "standard" basis) ordered
from lowest to highest degree.

Parameters
----------
c : array_like
    1-D array containing the Hermite series coefficients, ordered
    from lowest order term to highest.

Returns
-------
pol : ndarray
    1-D array containing the coefficients of the equivalent polynomial
    (relative to the "standard" basis) ordered from lowest order term
    to highest.

See Also
--------
poly2herme

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.hermite_e import herme2poly
>>> herme2poly([  2.,  10.,   2.,   3.])
array([ 0.,  1.,  2.,  3.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a146937f644e40832fc14d76be2d3d7d1}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a146937f644e40832fc14d76be2d3d7d1} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeadd@{hermeadd}}
\index{hermeadd@{hermeadd}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeadd()}{hermeadd()}}
{\footnotesize\ttfamily hermeadd (\begin{DoxyParamCaption}\item[{}]{c1,  }\item[{}]{c2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Add one Hermite series to another.

Returns the sum of two Hermite series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Hermite series of their sum.

See Also
--------
hermesub, hermemul, hermediv, hermepow

Notes
-----
Unlike multiplication, division, etc., the sum of two Hermite series
is a Hermite series (without having to "reproject" the result onto
the basis set) so addition, just like that of "standard" polynomials,
is simply "component-wise."

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeadd
>>> hermeadd([1, 2, 3], [1, 2, 3, 4])
array([ 2.,  4.,  6.,  4.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a0c5c8cf2a078937c6b566d56abfaee7a}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a0c5c8cf2a078937c6b566d56abfaee7a} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermecompanion@{hermecompanion}}
\index{hermecompanion@{hermecompanion}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermecompanion()}{hermecompanion()}}
{\footnotesize\ttfamily hermecompanion (\begin{DoxyParamCaption}\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when `c` is an HermiteE basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
`numpy.linalg.eigvalsh` is used to obtain them.

Parameters
----------
c : array_like
    1-D array of HermiteE series coefficients ordered from low to high
    degree.

Returns
-------
mat : ndarray
    Scaled companion matrix of dimensions (deg, deg).

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_ae3207ff3a28c13bc040618fa6ddf8b03}\label{namespacenumpy_1_1polynomial_1_1hermite__e_ae3207ff3a28c13bc040618fa6ddf8b03} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeder@{hermeder}}
\index{hermeder@{hermeder}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeder()}{hermeder()}}
{\footnotesize\ttfamily hermeder (\begin{DoxyParamCaption}\item[{}]{c,  }\item[{}]{m = {\ttfamily 1},  }\item[{}]{scl = {\ttfamily 1},  }\item[{}]{axis = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Differentiate a Hermite_e series.

Returns the series coefficients `c` differentiated `m` times along
`axis`.  At each iteration the result is multiplied by `scl` (the
scaling factor is for use in a linear change of variable). The argument
`c` is an array of coefficients from low to high degree along each
axis, e.g., [1,2,3] represents the series ``1*He_0 + 2*He_1 + 3*He_2``
while [[1,2],[1,2]] represents ``1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y)
+ 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y)`` if axis=0 is ``x`` and axis=1
is ``y``.

Parameters
----------
c : array_like
    Array of Hermite_e series coefficients. If `c` is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Number of derivatives taken, must be non-negative. (Default: 1)
scl : scalar, optional
    Each differentiation is multiplied by `scl`.  The end result is
    multiplication by ``scl**m``.  This is for use in a linear change of
    variable. (Default: 1)
axis : int, optional
    Axis over which the derivative is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
der : ndarray
    Hermite series of the derivative.

See Also
--------
hermeint

Notes
-----
In general, the result of differentiating a Hermite series does not
resemble the same operation on a power series. Thus the result of this
function may be "unintuitive," albeit correct; see Examples section
below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeder
>>> hermeder([ 1.,  1.,  1.,  1.])
array([ 1.,  2.,  3.])
>>> hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)
array([ 1.,  2.,  3.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a9384771800213f6517bad6e047fb3737}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a9384771800213f6517bad6e047fb3737} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermediv@{hermediv}}
\index{hermediv@{hermediv}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermediv()}{hermediv()}}
{\footnotesize\ttfamily hermediv (\begin{DoxyParamCaption}\item[{}]{c1,  }\item[{}]{c2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Divide one Hermite series by another.

Returns the quotient-with-remainder of two Hermite series
`c1` / `c2`.  The arguments are sequences of coefficients from lowest
order "term" to highest, e.g., [1,2,3] represents the series
``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
[quo, rem] : ndarrays
    Of Hermite series coefficients representing the quotient and
    remainder.

See Also
--------
hermeadd, hermesub, hermemul, hermepow

Notes
-----
In general, the (polynomial) division of one Hermite series by another
results in quotient and remainder terms that are not in the Hermite
polynomial basis set.  Thus, to express these results as a Hermite
series, it is necessary to "reproject" the results onto the Hermite
basis set, which may produce "unintuitive" (but correct) results; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermediv
>>> hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 0.]))
>>> hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])
(array([ 1.,  2.,  3.]), array([ 1.,  2.]))\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_afb07ec65c7123e9fd879c948a64e7978}\label{namespacenumpy_1_1polynomial_1_1hermite__e_afb07ec65c7123e9fd879c948a64e7978} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermefit@{hermefit}}
\index{hermefit@{hermefit}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermefit()}{hermefit()}}
{\footnotesize\ttfamily hermefit (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{deg,  }\item[{}]{rcond = {\ttfamily None},  }\item[{}]{full = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{w = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Least squares fit of Hermite series to data.

Return the coefficients of a HermiteE series of degree `deg` that is
the least squares fit to the data values `y` given at points `x`. If
`y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D
multiple fits are done, one for each column of `y`, and the resulting
coefficients are stored in the corresponding columns of a 2-D return.
The fitted polynomial(s) are in the form

.. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x),

where `n` is `deg`.

Parameters
----------
x : array_like, shape (M,)
    x-coordinates of the M sample points ``(x[i], y[i])``.
y : array_like, shape (M,) or (M, K)
    y-coordinates of the sample points. Several data sets of sample
    points sharing the same x-coordinates can be fitted at once by
    passing in a 2D-array that contains one dataset per column.
deg : int or 1-D array_like
    Degree(s) of the fitting polynomials. If `deg` is a single integer
    all terms up to and including the `deg`'th term are included in the
    fit. For NumPy versions >= 1.11.0 a list of integers specifying the
    degrees of the terms to include may be used instead.
rcond : float, optional
    Relative condition number of the fit. Singular values smaller than
    this relative to the largest singular value will be ignored. The
    default value is len(x)*eps, where eps is the relative precision of
    the float type, about 2e-16 in most cases.
full : bool, optional
    Switch determining nature of return value. When it is False (the
    default) just the coefficients are returned, when True diagnostic
    information from the singular value decomposition is also returned.
w : array_like, shape (`M`,), optional
    Weights. If not None, the contribution of each point
    ``(x[i],y[i])`` to the fit is weighted by `w[i]`. Ideally the
    weights are chosen so that the errors of the products ``w[i]*y[i]``
    all have the same variance.  The default value is None.

Returns
-------
coef : ndarray, shape (M,) or (M, K)
    Hermite coefficients ordered from low to high. If `y` was 2-D,
    the coefficients for the data in column k  of `y` are in column
    `k`.

[residuals, rank, singular_values, rcond] : list
    These values are only returned if `full` = True

    resid -- sum of squared residuals of the least squares fit
    rank -- the numerical rank of the scaled Vandermonde matrix
    sv -- singular values of the scaled Vandermonde matrix
    rcond -- value of `rcond`.

    For more details, see `linalg.lstsq`.

Warns
-----
RankWarning
    The rank of the coefficient matrix in the least-squares fit is
    deficient. The warning is only raised if `full` = False.  The
    warnings can be turned off by

    >>> import warnings
    >>> warnings.simplefilter('ignore', RankWarning)

See Also
--------
chebfit, legfit, polyfit, hermfit, polyfit
hermeval : Evaluates a Hermite series.
hermevander : pseudo Vandermonde matrix of Hermite series.
hermeweight : HermiteE weight function.
linalg.lstsq : Computes a least-squares fit from the matrix.
scipy.interpolate.UnivariateSpline : Computes spline fits.

Notes
-----
The solution is the coefficients of the HermiteE series `p` that
minimizes the sum of the weighted squared errors

.. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,

where the :math:`w_j` are the weights. This problem is solved by
setting up the (typically) overdetermined matrix equation

.. math:: V(x) * c = w * y,

where `V` is the pseudo Vandermonde matrix of `x`, the elements of `c`
are the coefficients to be solved for, and the elements of `y` are the
observed values.  This equation is then solved using the singular value
decomposition of `V`.

If some of the singular values of `V` are so small that they are
neglected, then a `RankWarning` will be issued. This means that the
coefficient values may be poorly determined. Using a lower order fit
will usually get rid of the warning.  The `rcond` parameter can also be
set to a value smaller than its default, but the resulting fit may be
spurious and have large contributions from roundoff error.

Fits using HermiteE series are probably most useful when the data can
be approximated by ``sqrt(w(x)) * p(x)``, where `w(x)` is the HermiteE
weight. In that case the weight ``sqrt(w(x[i])`` should be used
together with data values ``y[i]/sqrt(w(x[i])``. The weight function is
available as `hermeweight`.

References
----------
.. [1] Wikipedia, "Curve fitting",
       http://en.wikipedia.org/wiki/Curve_fitting

Examples
--------
>>> from numpy.polynomial.hermite_e import hermefit, hermeval
>>> x = np.linspace(-10, 10)
>>> err = np.random.randn(len(x))/10
>>> y = hermeval(x, [1, 2, 3]) + err
>>> hermefit(x, y, 2)
array([ 1.01690445,  1.99951418,  2.99948696])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a4614cac0df53382dfda5718f6fcd9f02}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a4614cac0df53382dfda5718f6fcd9f02} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermefromroots@{hermefromroots}}
\index{hermefromroots@{hermefromroots}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermefromroots()}{hermefromroots()}}
{\footnotesize\ttfamily hermefromroots (\begin{DoxyParamCaption}\item[{}]{roots }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate a HermiteE series with given roots.

The function returns the coefficients of the polynomial

.. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),

in HermiteE form, where the `r_n` are the roots specified in `roots`.
If a zero has multiplicity n, then it must appear in `roots` n times.
For instance, if 2 is a root of multiplicity three and 3 is a root of
multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
roots can appear in any order.

If the returned coefficients are `c`, then

.. math:: p(x) = c_0 + c_1 * He_1(x) + ... +  c_n * He_n(x)

The coefficient of the last term is not generally 1 for monic
polynomials in HermiteE form.

Parameters
----------
roots : array_like
    Sequence containing the roots.

Returns
-------
out : ndarray
    1-D array of coefficients.  If all roots are real then `out` is a
    real array, if some of the roots are complex, then `out` is complex
    even if all the coefficients in the result are real (see Examples
    below).

See Also
--------
polyfromroots, legfromroots, lagfromroots, hermfromroots,
chebfromroots.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermefromroots, hermeval
>>> coef = hermefromroots((-1, 0, 1))
>>> hermeval((-1, 0, 1), coef)
array([ 0.,  0.,  0.])
>>> coef = hermefromroots((-1j, 1j))
>>> hermeval((-1j, 1j), coef)
array([ 0.+0.j,  0.+0.j])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a171ba5e9abb92c997146c2fe531b58be}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a171ba5e9abb92c997146c2fe531b58be} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermegauss@{hermegauss}}
\index{hermegauss@{hermegauss}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermegauss()}{hermegauss()}}
{\footnotesize\ttfamily hermegauss (\begin{DoxyParamCaption}\item[{}]{deg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Gauss-HermiteE quadrature.

Computes the sample points and weights for Gauss-HermiteE quadrature.
These sample points and weights will correctly integrate polynomials of
degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]`
with the weight function :math:`f(x) = \\exp(-x^2/2)`.

Parameters
----------
deg : int
    Number of sample points and weights. It must be >= 1.

Returns
-------
x : ndarray
    1-D ndarray containing the sample points.
y : ndarray
    1-D ndarray containing the weights.

Notes
-----

.. versionadded:: 1.7.0

The results have only been tested up to degree 100, higher degrees may
be problematic. The weights are determined by using the fact that

.. math:: w_k = c / (He'_n(x_k) * He_{n-1}(x_k))

where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
is the k'th root of :math:`He_n`, and then scaling the results to get
the right value when integrating 1.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a2133fa76b05adb22f86e6b5af6c8c537}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a2133fa76b05adb22f86e6b5af6c8c537} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermegrid2d@{hermegrid2d}}
\index{hermegrid2d@{hermegrid2d}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermegrid2d()}{hermegrid2d()}}
{\footnotesize\ttfamily hermegrid2d (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate a 2-D HermiteE series on the Cartesian product of x and y.

This function returns the values:

.. math:: p(a,b) = \\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)

where the points `(a, b)` consist of all pairs formed by taking
`a` from `x` and `b` from `y`. The resulting points form a grid with
`x` in the first dimension and `y` in the second.

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars. In either
case, either `x` and `y` or their elements must support multiplication
and addition both with themselves and with the elements of `c`.

If `c` has fewer than two dimensions, ones are implicitly appended to
its shape to make it 2-D. The shape of the result will be c.shape[2:] +
x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points in the
    Cartesian product of `x` and `y`.  If `x` or `y` is a list or
    tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and, if it isn't an ndarray, it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermeval, hermeval2d, hermeval3d, hermegrid3d

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a005047921784658d6da63f8132779469}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a005047921784658d6da63f8132779469} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermegrid3d@{hermegrid3d}}
\index{hermegrid3d@{hermegrid3d}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermegrid3d()}{hermegrid3d()}}
{\footnotesize\ttfamily hermegrid3d (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{z,  }\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.

This function returns the values:

.. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * He_i(a) * He_j(b) * He_k(c)

where the points `(a, b, c)` consist of all triples formed by taking
`a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
a grid with `x` in the first dimension, `y` in the second, and `z` in
the third.

The parameters `x`, `y`, and `z` are converted to arrays only if they
are tuples or a lists, otherwise they are treated as a scalars. In
either case, either `x`, `y`, and `z` or their elements must support
multiplication and addition both with themselves and with the elements
of `c`.

If `c` has fewer than three dimensions, ones are implicitly appended to
its shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape + y.shape + z.shape.

Parameters
----------
x, y, z : array_like, compatible objects
    The three dimensional series is evaluated at the points in the
    Cartesian product of `x`, `y`, and `z`.  If `x`,`y`, or `z` is a
    list or tuple, it is first converted to an ndarray, otherwise it is
    left unchanged and, if it isn't an ndarray, it is treated as a
    scalar.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree i,j are contained in ``c[i,j]``. If `c` has dimension
    greater than two the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points in the Cartesian
    product of `x` and `y`.

See Also
--------
hermeval, hermeval2d, hermegrid2d, hermeval3d

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a88c8def58a032948ed488c867375ae40}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a88c8def58a032948ed488c867375ae40} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeint@{hermeint}}
\index{hermeint@{hermeint}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeint()}{hermeint()}}
{\footnotesize\ttfamily hermeint (\begin{DoxyParamCaption}\item[{}]{c,  }\item[{}]{m = {\ttfamily 1},  }\item[{}]{k = {\ttfamily \mbox{[}\mbox{]}},  }\item[{}]{lbnd = {\ttfamily 0},  }\item[{}]{scl = {\ttfamily 1},  }\item[{}]{axis = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Integrate a Hermite_e series.

Returns the Hermite_e series coefficients `c` integrated `m` times from
`lbnd` along `axis`. At each iteration the resulting series is
**multiplied** by `scl` and an integration constant, `k`, is added.
The scaling factor is for use in a linear change of variable.  ("Buyer
beware": note that, depending on what one is doing, one may want `scl`
to be the reciprocal of what one might expect; for more information,
see the Notes section below.)  The argument `c` is an array of
coefficients from low to high degree along each axis, e.g., [1,2,3]
represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]
represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.

Parameters
----------
c : array_like
    Array of Hermite_e series coefficients. If c is multidimensional
    the different axis correspond to different variables with the
    degree in each axis given by the corresponding index.
m : int, optional
    Order of integration, must be positive. (Default: 1)
k : {[], list, scalar}, optional
    Integration constant(s).  The value of the first integral at
    ``lbnd`` is the first value in the list, the value of the second
    integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
    default), all constants are set to zero.  If ``m == 1``, a single
    scalar can be given instead of a list.
lbnd : scalar, optional
    The lower bound of the integral. (Default: 0)
scl : scalar, optional
    Following each integration the result is *multiplied* by `scl`
    before the integration constant is added. (Default: 1)
axis : int, optional
    Axis over which the integral is taken. (Default: 0).

    .. versionadded:: 1.7.0

Returns
-------
S : ndarray
    Hermite_e series coefficients of the integral.

Raises
------
ValueError
    If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
    ``np.ndim(scl) != 0``.

See Also
--------
hermeder

Notes
-----
Note that the result of each integration is *multiplied* by `scl`.
Why is this important to note?  Say one is making a linear change of
variable :math:`u = ax + b` in an integral relative to `x`.  Then
:math:`dx = du/a`, so one will need to set `scl` equal to
:math:`1/a` - perhaps not what one would have first thought.

Also note that, in general, the result of integrating a C-series needs
to be "reprojected" onto the C-series basis set.  Thus, typically,
the result of this function is "unintuitive," albeit correct; see
Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeint
>>> hermeint([1, 2, 3]) # integrate once, value 0 at 0.
array([ 1.,  1.,  1.,  1.])
>>> hermeint([1, 2, 3], m=2) # integrate twice, value & deriv 0 at 0
array([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ])
>>> hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.
array([ 2.,  1.,  1.,  1.])
>>> hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1
array([-1.,  1.,  1.,  1.])
>>> hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)
array([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a2255a72252a47a813c65193878e0bfe4}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a2255a72252a47a813c65193878e0bfe4} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeline@{hermeline}}
\index{hermeline@{hermeline}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeline()}{hermeline()}}
{\footnotesize\ttfamily hermeline (\begin{DoxyParamCaption}\item[{}]{off,  }\item[{}]{scl }\end{DoxyParamCaption})}

\begin{DoxyVerb}Hermite series whose graph is a straight line.



Parameters
----------
off, scl : scalars
    The specified line is given by ``off + scl*x``.

Returns
-------
y : ndarray
    This module's representation of the Hermite series for
    ``off + scl*x``.

See Also
--------
polyline, chebline

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeline
>>> from numpy.polynomial.hermite_e import hermeline, hermeval
>>> hermeval(0,hermeline(3, 2))
3.0
>>> hermeval(1,hermeline(3, 2))
5.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a1645caea6a08e08131a810804ad85938}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a1645caea6a08e08131a810804ad85938} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermemul@{hermemul}}
\index{hermemul@{hermemul}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermemul()}{hermemul()}}
{\footnotesize\ttfamily hermemul (\begin{DoxyParamCaption}\item[{}]{c1,  }\item[{}]{c2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Multiply one Hermite series by another.

Returns the product of two Hermite series `c1` * `c2`.  The arguments
are sequences of coefficients, from lowest order "term" to highest,
e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their product.

See Also
--------
hermeadd, hermesub, hermediv, hermepow

Notes
-----
In general, the (polynomial) product of two C-series results in terms
that are not in the Hermite polynomial basis set.  Thus, to express
the product as a Hermite series, it is necessary to "reproject" the
product onto said basis set, which may produce "unintuitive" (but
correct) results; see Examples section below.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermemul
>>> hermemul([1, 2, 3], [0, 1, 2])
array([ 14.,  15.,  28.,   7.,   6.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a8ee5b2a889bee0966378f4ce1e518c6e}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a8ee5b2a889bee0966378f4ce1e518c6e} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermemulx@{hermemulx}}
\index{hermemulx@{hermemulx}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermemulx()}{hermemulx()}}
{\footnotesize\ttfamily hermemulx (\begin{DoxyParamCaption}\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Multiply a Hermite series by x.

Multiply the Hermite series `c` by x, where x is the independent
variable.


Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the result of the multiplication.

Notes
-----
The multiplication uses the recursion relationship for Hermite
polynomials in the form

.. math::

xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))

Examples
--------
>>> from numpy.polynomial.hermite_e import hermemulx
>>> hermemulx([1, 2, 3])
array([ 2.,  7.,  2.,  3.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_ac494da50fa0502cac1d811b309bb3066}\label{namespacenumpy_1_1polynomial_1_1hermite__e_ac494da50fa0502cac1d811b309bb3066} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermepow@{hermepow}}
\index{hermepow@{hermepow}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermepow()}{hermepow()}}
{\footnotesize\ttfamily hermepow (\begin{DoxyParamCaption}\item[{}]{c,  }\item[{}]{pow,  }\item[{}]{maxpower = {\ttfamily 16} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Raise a Hermite series to a power.

Returns the Hermite series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Parameters
----------
c : array_like
    1-D array of Hermite series coefficients ordered from low to
    high.
pow : integer
    Power to which the series will be raised
maxpower : integer, optional
    Maximum power allowed. This is mainly to limit growth of the series
    to unmanageable size. Default is 16

Returns
-------
coef : ndarray
    Hermite series of power.

See Also
--------
hermeadd, hermesub, hermemul, hermediv

Examples
--------
>>> from numpy.polynomial.hermite_e import hermepow
>>> hermepow([1, 2, 3], 2)
array([ 23.,  28.,  46.,  12.,   9.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a3d97938294447c23464ca9379fa590e7}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a3d97938294447c23464ca9379fa590e7} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeroots@{hermeroots}}
\index{hermeroots@{hermeroots}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeroots()}{hermeroots()}}
{\footnotesize\ttfamily hermeroots (\begin{DoxyParamCaption}\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the roots of a HermiteE series.

Return the roots (a.k.a. "zeros") of the polynomial

.. math:: p(x) = \\sum_i c[i] * He_i(x).

Parameters
----------
c : 1-D array_like
    1-D array of coefficients.

Returns
-------
out : ndarray
    Array of the roots of the series. If all the roots are real,
    then `out` is also real, otherwise it is complex.

See Also
--------
polyroots, legroots, lagroots, hermroots, chebroots

Notes
-----
The root estimates are obtained as the eigenvalues of the companion
matrix, Roots far from the origin of the complex plane may have large
errors due to the numerical instability of the series for such
values. Roots with multiplicity greater than 1 will also show larger
errors as the value of the series near such points is relatively
insensitive to errors in the roots. Isolated roots near the origin can
be improved by a few iterations of Newton's method.

The HermiteE series basis polynomials aren't powers of `x` so the
results of this function may seem unintuitive.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeroots, hermefromroots
>>> coef = hermefromroots([-1, 0, 1])
>>> coef
array([ 0.,  2.,  0.,  1.])
>>> hermeroots(coef)
array([-1.,  0.,  1.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_acc886165b3c87bbcfb4c1b467db195a0}\label{namespacenumpy_1_1polynomial_1_1hermite__e_acc886165b3c87bbcfb4c1b467db195a0} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermesub@{hermesub}}
\index{hermesub@{hermesub}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermesub()}{hermesub()}}
{\footnotesize\ttfamily hermesub (\begin{DoxyParamCaption}\item[{}]{c1,  }\item[{}]{c2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Subtract one Hermite series from another.

Returns the difference of two Hermite series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Hermite series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Of Hermite series coefficients representing their difference.

See Also
--------
hermeadd, hermemul, hermediv, hermepow

Notes
-----
Unlike multiplication, division, etc., the difference of two Hermite
series is a Hermite series (without having to "reproject" the result
onto the basis set) so subtraction, just like that of "standard"
polynomials, is simply "component-wise."

Examples
--------
>>> from numpy.polynomial.hermite_e import hermesub
>>> hermesub([1, 2, 3, 4], [1, 2, 3])
array([ 0.,  0.,  0.,  4.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_aec419c337e974610847479112e8209fc}\label{namespacenumpy_1_1polynomial_1_1hermite__e_aec419c337e974610847479112e8209fc} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeval@{hermeval}}
\index{hermeval@{hermeval}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeval()}{hermeval()}}
{\footnotesize\ttfamily hermeval (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{c,  }\item[{}]{tensor = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate an HermiteE series at points x.

If `c` is of length `n + 1`, this function returns the value:

.. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)

The parameter `x` is converted to an array only if it is a tuple or a
list, otherwise it is treated as a scalar. In either case, either `x`
or its elements must support multiplication and addition both with
themselves and with the elements of `c`.

If `c` is a 1-D array, then `p(x)` will have the same shape as `x`.  If
`c` is multidimensional, then the shape of the result depends on the
value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
scalars have shape (,).

Trailing zeros in the coefficients will be used in the evaluation, so
they should be avoided if efficiency is a concern.

Parameters
----------
x : array_like, compatible object
    If `x` is a list or tuple, it is converted to an ndarray, otherwise
    it is left unchanged and treated as a scalar. In either case, `x`
    or its elements must support addition and multiplication with
    with themselves and with the elements of `c`.
c : array_like
    Array of coefficients ordered so that the coefficients for terms of
    degree n are contained in c[n]. If `c` is multidimensional the
    remaining indices enumerate multiple polynomials. In the two
    dimensional case the coefficients may be thought of as stored in
    the columns of `c`.
tensor : boolean, optional
    If True, the shape of the coefficient array is extended with ones
    on the right, one for each dimension of `x`. Scalars have dimension 0
    for this action. The result is that every column of coefficients in
    `c` is evaluated for every element of `x`. If False, `x` is broadcast
    over the columns of `c` for the evaluation.  This keyword is useful
    when `c` is multidimensional. The default value is True.

    .. versionadded:: 1.7.0

Returns
-------
values : ndarray, algebra_like
    The shape of the return value is described above.

See Also
--------
hermeval2d, hermegrid2d, hermeval3d, hermegrid3d

Notes
-----
The evaluation uses Clenshaw recursion, aka synthetic division.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermeval
>>> coef = [1,2,3]
>>> hermeval(1, coef)
3.0
>>> hermeval([[1,2],[3,4]], coef)
array([[  3.,  14.],
       [ 31.,  54.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a6d9c16c758b0d2b71f60697b3372fb09}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a6d9c16c758b0d2b71f60697b3372fb09} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeval2d@{hermeval2d}}
\index{hermeval2d@{hermeval2d}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeval2d()}{hermeval2d()}}
{\footnotesize\ttfamily hermeval2d (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate a 2-D HermiteE series at points (x, y).

This function returns the values:

.. math:: p(x,y) = \\sum_{i,j} c_{i,j} * He_i(x) * He_j(y)

The parameters `x` and `y` are converted to arrays only if they are
tuples or a lists, otherwise they are treated as a scalars and they
must have the same shape after conversion. In either case, either `x`
and `y` or their elements must support multiplication and addition both
with themselves and with the elements of `c`.

If `c` is a 1-D array a one is implicitly appended to its shape to make
it 2-D. The shape of the result will be c.shape[2:] + x.shape.

Parameters
----------
x, y : array_like, compatible objects
    The two dimensional series is evaluated at the points `(x, y)`,
    where `x` and `y` must have the same shape. If `x` or `y` is a list
    or tuple, it is first converted to an ndarray, otherwise it is left
    unchanged and if it isn't an ndarray it is treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term
    of multi-degree i,j is contained in ``c[i,j]``. If `c` has
    dimension greater than two the remaining indices enumerate multiple
    sets of coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the two dimensional polynomial at points formed with
    pairs of corresponding values from `x` and `y`.

See Also
--------
hermeval, hermegrid2d, hermeval3d, hermegrid3d

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a24d3a48234b05e81f63a238e59a18ee8}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a24d3a48234b05e81f63a238e59a18ee8} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeval3d@{hermeval3d}}
\index{hermeval3d@{hermeval3d}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeval3d()}{hermeval3d()}}
{\footnotesize\ttfamily hermeval3d (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{z,  }\item[{}]{c }\end{DoxyParamCaption})}

\begin{DoxyVerb}Evaluate a 3-D Hermite_e series at points (x, y, z).

This function returns the values:

.. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)

The parameters `x`, `y`, and `z` are converted to arrays only if
they are tuples or a lists, otherwise they are treated as a scalars and
they must have the same shape after conversion. In either case, either
`x`, `y`, and `z` or their elements must support multiplication and
addition both with themselves and with the elements of `c`.

If `c` has fewer than 3 dimensions, ones are implicitly appended to its
shape to make it 3-D. The shape of the result will be c.shape[3:] +
x.shape.

Parameters
----------
x, y, z : array_like, compatible object
    The three dimensional series is evaluated at the points
    `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
    any of `x`, `y`, or `z` is a list or tuple, it is first converted
    to an ndarray, otherwise it is left unchanged and if it isn't an
    ndarray it is  treated as a scalar.
c : array_like
    Array of coefficients ordered so that the coefficient of the term of
    multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
    greater than 3 the remaining indices enumerate multiple sets of
    coefficients.

Returns
-------
values : ndarray, compatible object
    The values of the multidimensional polynomial on points formed with
    triples of corresponding values from `x`, `y`, and `z`.

See Also
--------
hermeval, hermeval2d, hermegrid2d, hermegrid3d

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a3d9f6d4b8c394bfc56b815eb348117f4}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a3d9f6d4b8c394bfc56b815eb348117f4} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermevander@{hermevander}}
\index{hermevander@{hermevander}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermevander()}{hermevander()}}
{\footnotesize\ttfamily hermevander (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{deg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = He_i(x),

where `0 <= i <= deg`. The leading indices of `V` index the elements of
`x` and the last index is the degree of the HermiteE polynomial.

If `c` is a 1-D array of coefficients of length `n + 1` and `V` is the
array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and
``hermeval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of HermiteE series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding HermiteE polynomial.  The dtype will be the same as
    the converted `x`.

Examples
--------
>>> from numpy.polynomial.hermite_e import hermevander
>>> x = np.array([-1, 0, 1])
>>> hermevander(x, 3)
array([[ 1., -1.,  0.,  2.],
       [ 1.,  0., -1., -0.],
       [ 1.,  1.,  0., -2.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a1052a2e9eb566575e113a2dff6b5fcaa}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a1052a2e9eb566575e113a2dff6b5fcaa} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermevander2d@{hermevander2d}}
\index{hermevander2d@{hermevander2d}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermevander2d()}{hermevander2d()}}
{\footnotesize\ttfamily hermevander2d (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{deg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y)`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., (deg[1] + 1)*i + j] = He_i(x) * He_j(y),

where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of
`V` index the points `(x, y)` and the last index encodes the degrees of
the HermiteE polynomials.

If ``V = hermevander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
correspond to the elements of a 2-D coefficient array `c` of shape
(xdeg + 1, ydeg + 1) in the order

.. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...

and ``np.dot(V, c.flat)`` and ``hermeval2d(x, y, c)`` will be the same
up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 2-D HermiteE
series of the same degrees and sample points.

Parameters
----------
x, y : array_like
    Arrays of point coordinates, all of the same shape. The dtypes
    will be converted to either float64 or complex128 depending on
    whether any of the elements are complex. Scalars are converted to
    1-D arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg].

Returns
-------
vander2d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
    as the converted `x` and `y`.

See Also
--------
hermevander, hermevander3d. hermeval2d, hermeval3d

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_ad2fc607be3dc86543219225b127a87ed}\label{namespacenumpy_1_1polynomial_1_1hermite__e_ad2fc607be3dc86543219225b127a87ed} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermevander3d@{hermevander3d}}
\index{hermevander3d@{hermevander3d}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermevander3d()}{hermevander3d()}}
{\footnotesize\ttfamily hermevander3d (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{z,  }\item[{}]{deg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l, m, n` are the given degrees in `x, y, z`,
then Hehe pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= j <= n`.  The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the HermiteE polynomials.

If ``V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
of `V` correspond to the elements of a 3-D coefficient array `c` of
shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order

.. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...

and  ``np.dot(V, c.flat)`` and ``hermeval3d(x, y, z, c)`` will be the
same up to roundoff. This equivalence is useful both for least squares
fitting and for the evaluation of a large number of 3-D HermiteE
series of the same degrees and sample points.

Parameters
----------
x, y, z : array_like
    Arrays of point coordinates, all of the same shape. The dtypes will
    be converted to either float64 or complex128 depending on whether
    any of the elements are complex. Scalars are converted to 1-D
    arrays.
deg : list of ints
    List of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : ndarray
    The shape of the returned matrix is ``x.shape + (order,)``, where
    :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
    be the same as the converted `x`, `y`, and `z`.

See Also
--------
hermevander, hermevander3d. hermeval2d, hermeval3d

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_ac40564e2e895c9f6eb17372eedcd65cd}\label{namespacenumpy_1_1polynomial_1_1hermite__e_ac40564e2e895c9f6eb17372eedcd65cd} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeweight@{hermeweight}}
\index{hermeweight@{hermeweight}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeweight()}{hermeweight()}}
{\footnotesize\ttfamily hermeweight (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Weight function of the Hermite_e polynomials.

The weight function is :math:`\\exp(-x^2/2)` and the interval of
integration is :math:`[-\\inf, \\inf]`. the HermiteE polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at `x`.

Notes
-----

.. versionadded:: 1.7.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a210967f5364bc7dec862c82be7f13e0d}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a210967f5364bc7dec862c82be7f13e0d} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!poly2herme@{poly2herme}}
\index{poly2herme@{poly2herme}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{poly2herme()}{poly2herme()}}
{\footnotesize\ttfamily poly2herme (\begin{DoxyParamCaption}\item[{}]{pol }\end{DoxyParamCaption})}

\begin{DoxyVerb}poly2herme(pol)

Convert a polynomial to a Hermite series.

Convert an array representing the coefficients of a polynomial (relative
to the "standard" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Hermite series, ordered
from lowest to highest degree.

Parameters
----------
pol : array_like
    1-D array containing the polynomial coefficients

Returns
-------
c : ndarray
    1-D array containing the coefficients of the equivalent Hermite
    series.

See Also
--------
herme2poly

Notes
-----
The easy way to do conversions between polynomial basis sets
is to use the convert method of a class instance.

Examples
--------
>>> from numpy.polynomial.hermite_e import poly2herme
>>> poly2herme(np.arange(4))
array([  2.,  10.,   2.,   3.])\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a2833ef4d10cb0de286946919f307969f}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a2833ef4d10cb0de286946919f307969f} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermedomain@{hermedomain}}
\index{hermedomain@{hermedomain}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermedomain}{hermedomain}}
{\footnotesize\ttfamily hermedomain = np.\+array(\mbox{[}-\/1, 1\mbox{]})}

\Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a6a7a1e34992a5e4bc1ceb5b2f5a37380}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a6a7a1e34992a5e4bc1ceb5b2f5a37380} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermeone@{hermeone}}
\index{hermeone@{hermeone}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermeone}{hermeone}}
{\footnotesize\ttfamily hermeone = np.\+array(\mbox{[}1\mbox{]})}

\Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a627a4bf12279c6e0a2189238fd6e28c3}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a627a4bf12279c6e0a2189238fd6e28c3} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermetrim@{hermetrim}}
\index{hermetrim@{hermetrim}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermetrim}{hermetrim}}
{\footnotesize\ttfamily hermetrim = pu.\+trimcoef}

\Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a788bbf5a7ef9802a12c36cdfa5075d1e}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a788bbf5a7ef9802a12c36cdfa5075d1e} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermex@{hermex}}
\index{hermex@{hermex}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermex}{hermex}}
{\footnotesize\ttfamily hermex = np.\+array(\mbox{[}0, 1\mbox{]})}

\Hypertarget{namespacenumpy_1_1polynomial_1_1hermite__e_a08e802f90b18a554ddff648d448c6043}\label{namespacenumpy_1_1polynomial_1_1hermite__e_a08e802f90b18a554ddff648d448c6043} 
\index{numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}!hermezero@{hermezero}}
\index{hermezero@{hermezero}!numpy.polynomial.hermite\_e@{numpy.polynomial.hermite\_e}}
\doxysubsubsection{\texorpdfstring{hermezero}{hermezero}}
{\footnotesize\ttfamily hermezero = np.\+array(\mbox{[}0\mbox{]})}

