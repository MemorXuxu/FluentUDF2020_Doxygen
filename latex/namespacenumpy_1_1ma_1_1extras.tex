\doxysection{numpy.\+ma.\+extras Namespace Reference}
\hypertarget{namespacenumpy_1_1ma_1_1extras}{}\label{namespacenumpy_1_1ma_1_1extras}\index{numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction}{\+\_\+fromnxfunction}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__allargs}{\+\_\+fromnxfunction\+\_\+allargs}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__args}{\+\_\+fromnxfunction\+\_\+args}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__single}{\+\_\+fromnxfunction\+\_\+single}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1_m_axis_concatenator}{MAxis\+Concatenator}}
\item 
class \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1mr__class}{mr\+\_\+class}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a2baf4c56a08270bbeb329b7a383a04e8}{issequence}} (seq)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a8b63355938184d1dfb87efee71c89b92}{count\+\_\+masked}} (arr, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_abeffd116292f1027d6f770690560fd8a}{masked\+\_\+all}} (\mbox{\hyperlink{namespacenumpy_1_1ma_1_1core_ae76f0c13b5b0e3ae7c86aaf5aa015e96}{shape}}, dtype=float)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a183375c8556432e8031b9b3f6b632abf}{masked\+\_\+all\+\_\+like}} (arr)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ac785f4a49c28834256f92afd9f23d0bf}{flatten\+\_\+inplace}} (seq)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ab20885baa84a8964818cf3ea7fefabbf}{apply\+\_\+along\+\_\+axis}} (func1d, axis, arr, \texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a3798546ee3338d4befa422abd5d8db83}{apply\+\_\+over\+\_\+axes}} (func, a, axes)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a4153cdb7174f1ab67eb3c7baf3b76e2a}{average}} (a, axis=None, weights=None, returned=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a0901a19189c37fffee8f6d673fc10b8c}{median}} (a, axis=None, out=None, overwrite\+\_\+input=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, keepdims=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_acd0a8b87247f22e36f0a754fab58dda3}{\+\_\+median}} (a, axis=None, out=None, overwrite\+\_\+input=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a1b7a7059d6acd6733ecc80b85e331e7d}{compress\+\_\+nd}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a3c435666b90eff1902b4a8aa5fc674dc}{compress\+\_\+rowcols}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a025550b104dd7f13e7630566f5d1d781}{compress\+\_\+rows}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ab928d9b19c0e03d5730a7ff4b66924e3}{compress\+\_\+cols}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a6629f4c96eac6c1e1a5aff43a0c76e6c}{mask\+\_\+rows}} (a, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ab442bf793f2b07da2c6e39a7afd6d044}{mask\+\_\+cols}} (a, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ac3bec268a407059de54030183dbdf848}{ediff1d}} (arr, to\+\_\+end=None, to\+\_\+begin=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a5e0cea396da40300b612cb2e0611428f}{unique}} (ar1, return\+\_\+index=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, return\+\_\+inverse=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a3a15155c7b399a4463b1631b9d48b0c7}{intersect1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a734ad367bcbd8ee1434a7be8c473ac5c}{setxor1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a28c62c1361517ea4cee63aaa55c38f75}{in1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, invert=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a54ee8925095479d12e999198824ab115}{isin}} (\mbox{\hyperlink{structelement}{element}}, test\+\_\+elements, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, invert=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a76dfbada427ca7b6b64e414b9fd34ea3}{union1d}} (ar1, ar2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a29fa3c52ee76f4fe3c45d8fd79ef9a8f}{setdiff1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a712dc9f1447cdbffe3d0e70435a1e3e7}{\+\_\+covhelper}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y=None, rowvar=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, allow\+\_\+masked=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\begin{DoxyCompactList}\small\item\em Covariance \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_accbc225bcea6f69c98893bd2046b4a06}{cov}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y=None, rowvar=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, bias=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, allow\+\_\+masked=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, ddof=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a9a2e45e75842e940c03e49b6d2cc628f}{corrcoef}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y=None, rowvar=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, bias=np.\+\_\+\+No\+Value, allow\+\_\+masked=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, ddof=np.\+\_\+\+No\+Value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ae7b0cfcf3be019af7242f985bae1de5d}{flatnotmasked\+\_\+edges}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a253f41e0aa8f0aeaa8c4b31e5b6b3f44}{notmasked\+\_\+edges}} (a, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a6d5d872ad2ba13f04025727e4915701a}{flatnotmasked\+\_\+contiguous}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a11def3d9715f46b6c144c0f1a500a116}{notmasked\+\_\+contiguous}} (a, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a6ec09cf3cb3ad0ee7aec56d6bb389d14}{\+\_\+ezclump}} (mask)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a53a47d49a0c93e61f3f4c6dd6ccbf7d5}{clump\+\_\+unmasked}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_aa00c8e2b9b3191ef49646800767896a9}{clump\+\_\+masked}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a7b06d7d578efef1fd42cf0802f16b140}{vander}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, n=None)
\begin{DoxyCompactList}\small\item\em Polynomial fit \#. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a0bb1dec93d11ecc14ff085ef19c7651c}{polyfit}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, y, deg, rcond=None, \mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aedba2594d8fc1c40b727456402f98c6f}{full}}=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, w=None, \mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_accbc225bcea6f69c98893bd2046b4a06}{cov}}=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a1e76b5377881903d86b7aec245d26257}{atleast\+\_\+1d}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__allargs}{\+\_\+fromnxfunction\+\_\+allargs}}(\textquotesingle{}atleast\+\_\+1d\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a7d2fbcfcbcca14aec211ee7dc55717a2}{atleast\+\_\+2d}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__allargs}{\+\_\+fromnxfunction\+\_\+allargs}}(\textquotesingle{}atleast\+\_\+2d\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a1a96cd8a13aafcb85e58fb7cf853ca3e}{atleast\+\_\+3d}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__allargs}{\+\_\+fromnxfunction\+\_\+allargs}}(\textquotesingle{}atleast\+\_\+3d\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a3c3ba338379e2116ca8410aaeb2225ad}{vstack}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}vstack\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ac52d71a73d2156a5480e7a2536041c8a}{hstack}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}hstack\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_ac3cb01e454dca81e06d5cb8f9219c8fb}{column\+\_\+stack}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}column\+\_\+stack\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a627175ae0b038340f0ea06873b20e6f2}{dstack}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}dstack\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a37d7c639a3adefa88200027e9f78ba3f}{stack}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}\mbox{\hyperlink{seem_8h_a808b546b9141ff44ac0c3ea9a3895792}{stack}}\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a19b5d1b06eceaf6cfb4daec742915584}{hsplit}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__single}{\+\_\+fromnxfunction\+\_\+single}}(\textquotesingle{}hsplit\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_aa389efca6afc7d44eed92479e50be422}{diagflat}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__single}{\+\_\+fromnxfunction\+\_\+single}}(\textquotesingle{}diagflat\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1ma_1_1extras_a521c35256d56b306288f49ec9c43c730}{mr\+\_\+}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1mr__class}{mr\+\_\+class}}()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Masked arrays add-ons.

A collection of utilities for `numpy.ma`.

:author: Pierre Gerard-Marchant
:contact: pierregm_at_uga_dot_edu
:version: $Id: extras.py 3473 2007-10-29 15:18:13Z jarrod.millman $\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1ma_1_1extras_a712dc9f1447cdbffe3d0e70435a1e3e7}\label{namespacenumpy_1_1ma_1_1extras_a712dc9f1447cdbffe3d0e70435a1e3e7} 
\index{numpy.ma.extras@{numpy.ma.extras}!\_covhelper@{\_covhelper}}
\index{\_covhelper@{\_covhelper}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{\_covhelper()}{\_covhelper()}}
{\footnotesize\ttfamily \+\_\+covhelper (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y = {\ttfamily None},  }\item[{}]{rowvar = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{allow\+\_\+masked = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Covariance \#. 

\begin{DoxyVerb}Private function for the computation of covariance and correlation
coefficients.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a6ec09cf3cb3ad0ee7aec56d6bb389d14}\label{namespacenumpy_1_1ma_1_1extras_a6ec09cf3cb3ad0ee7aec56d6bb389d14} 
\index{numpy.ma.extras@{numpy.ma.extras}!\_ezclump@{\_ezclump}}
\index{\_ezclump@{\_ezclump}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{\_ezclump()}{\_ezclump()}}
{\footnotesize\ttfamily \+\_\+ezclump (\begin{DoxyParamCaption}\item[{}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Finds the clumps (groups of data with the same values) for a 1D bool array.

Returns a series of slices.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_acd0a8b87247f22e36f0a754fab58dda3}\label{namespacenumpy_1_1ma_1_1extras_acd0a8b87247f22e36f0a754fab58dda3} 
\index{numpy.ma.extras@{numpy.ma.extras}!\_median@{\_median}}
\index{\_median@{\_median}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{\_median()}{\_median()}}
{\footnotesize\ttfamily \+\_\+median (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{out = {\ttfamily None},  }\item[{}]{overwrite\+\_\+input = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_ab20885baa84a8964818cf3ea7fefabbf}\label{namespacenumpy_1_1ma_1_1extras_ab20885baa84a8964818cf3ea7fefabbf} 
\index{numpy.ma.extras@{numpy.ma.extras}!apply\_along\_axis@{apply\_along\_axis}}
\index{apply\_along\_axis@{apply\_along\_axis}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{apply\_along\_axis()}{apply\_along\_axis()}}
{\footnotesize\ttfamily apply\+\_\+along\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{func1d,  }\item[{}]{axis,  }\item[{}]{arr,  }\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}(This docstring should be overwritten)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a3798546ee3338d4befa422abd5d8db83}\label{namespacenumpy_1_1ma_1_1extras_a3798546ee3338d4befa422abd5d8db83} 
\index{numpy.ma.extras@{numpy.ma.extras}!apply\_over\_axes@{apply\_over\_axes}}
\index{apply\_over\_axes@{apply\_over\_axes}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{apply\_over\_axes()}{apply\_over\_axes()}}
{\footnotesize\ttfamily apply\+\_\+over\+\_\+axes (\begin{DoxyParamCaption}\item[{}]{func,  }\item[{}]{a,  }\item[{}]{axes }\end{DoxyParamCaption})}

\begin{DoxyVerb}(This docstring will be overwritten)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a4153cdb7174f1ab67eb3c7baf3b76e2a}\label{namespacenumpy_1_1ma_1_1extras_a4153cdb7174f1ab67eb3c7baf3b76e2a} 
\index{numpy.ma.extras@{numpy.ma.extras}!average@{average}}
\index{average@{average}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{average()}{average()}}
{\footnotesize\ttfamily average (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{weights = {\ttfamily None},  }\item[{}]{returned = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the weighted average of array over the given axis.

Parameters
----------
a : array_like
    Data to be averaged.
    Masked entries are not taken into account in the computation.
axis : int, optional
    Axis along which to average `a`. If `None`, averaging is done over
    the flattened array.
weights : array_like, optional
    The importance that each element has in the computation of the average.
    The weights array can either be 1-D (in which case its length must be
    the size of `a` along the given axis) or of the same shape as `a`.
    If ``weights=None``, then all data in `a` are assumed to have a
    weight equal to one.   If `weights` is complex, the imaginary parts
    are ignored.
returned : bool, optional
    Flag indicating whether a tuple ``(result, sum of weights)``
    should be returned as output (True), or just the result (False).
    Default is False.

Returns
-------
average, [sum_of_weights] : (tuple of) scalar or MaskedArray
    The average along the specified axis. When returned is `True`,
    return a tuple with the average as the first element and the sum
    of the weights as the second element. The return type is `np.float64`
    if `a` is of integer type and floats smaller than `float64`, or the
    input data-type, otherwise. If returned, `sum_of_weights` is always
    `float64`.

Examples
--------
>>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
>>> np.ma.average(a, weights=[3, 1, 0, 0])
1.25

>>> x = np.ma.arange(6.).reshape(3, 2)
>>> print(x)
[[ 0.  1.]
 [ 2.  3.]
 [ 4.  5.]]
>>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],
...                                 returned=True)
>>> print(avg)
[2.66666666667 3.66666666667]\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_aa00c8e2b9b3191ef49646800767896a9}\label{namespacenumpy_1_1ma_1_1extras_aa00c8e2b9b3191ef49646800767896a9} 
\index{numpy.ma.extras@{numpy.ma.extras}!clump\_masked@{clump\_masked}}
\index{clump\_masked@{clump\_masked}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{clump\_masked()}{clump\_masked()}}
{\footnotesize\ttfamily clump\+\_\+masked (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a list of slices corresponding to the masked clumps of a 1-D array.
(A "clump" is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of masked elements
    in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
notmasked_contiguous, clump_unmasked

Examples
--------
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_masked(a)
[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a53a47d49a0c93e61f3f4c6dd6ccbf7d5}\label{namespacenumpy_1_1ma_1_1extras_a53a47d49a0c93e61f3f4c6dd6ccbf7d5} 
\index{numpy.ma.extras@{numpy.ma.extras}!clump\_unmasked@{clump\_unmasked}}
\index{clump\_unmasked@{clump\_unmasked}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{clump\_unmasked()}{clump\_unmasked()}}
{\footnotesize\ttfamily clump\+\_\+unmasked (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return list of slices corresponding to the unmasked clumps of a 1-D array.
(A "clump" is defined as a contiguous region of the array).

Parameters
----------
a : ndarray
    A one-dimensional masked array.

Returns
-------
slices : list of slice
    The list of slices, one for each continuous region of unmasked
    elements in `a`.

Notes
-----
.. versionadded:: 1.4.0

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
notmasked_contiguous, clump_masked

Examples
--------
>>> a = np.ma.masked_array(np.arange(10))
>>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
>>> np.ma.clump_unmasked(a)
[slice(3, 6, None), slice(7, 8, None)]\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_ab928d9b19c0e03d5730a7ff4b66924e3}\label{namespacenumpy_1_1ma_1_1extras_ab928d9b19c0e03d5730a7ff4b66924e3} 
\index{numpy.ma.extras@{numpy.ma.extras}!compress\_cols@{compress\_cols}}
\index{compress\_cols@{compress\_cols}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{compress\_cols()}{compress\_cols()}}
{\footnotesize\ttfamily compress\+\_\+cols (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Suppress whole columns of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a1b7a7059d6acd6733ecc80b85e331e7d}\label{namespacenumpy_1_1ma_1_1extras_a1b7a7059d6acd6733ecc80b85e331e7d} 
\index{numpy.ma.extras@{numpy.ma.extras}!compress\_nd@{compress\_nd}}
\index{compress\_nd@{compress\_nd}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{compress\_nd()}{compress\_nd()}}
{\footnotesize\ttfamily compress\+\_\+nd (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Suppress slices from multiple dimensions which contain masked values.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on. If not a MaskedArray instance (or if no array
    elements are masked, `x` is interpreted as a MaskedArray with `mask`
    set to `nomask`.
axis : tuple of ints or int, optional
    Which dimensions to suppress slices from can be configured with this
    parameter.
    - If axis is a tuple of ints, those are the axes to suppress slices from.
    - If axis is an int, then that is the only axis to suppress slices from.
    - If axis is None, all axis are selected.

Returns
-------
compress_array : ndarray
    The compressed array.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a3c435666b90eff1902b4a8aa5fc674dc}\label{namespacenumpy_1_1ma_1_1extras_a3c435666b90eff1902b4a8aa5fc674dc} 
\index{numpy.ma.extras@{numpy.ma.extras}!compress\_rowcols@{compress\_rowcols}}
\index{compress\_rowcols@{compress\_rowcols}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{compress\_rowcols()}{compress\_rowcols()}}
{\footnotesize\ttfamily compress\+\_\+rowcols (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Suppress the rows and/or columns of a 2-D array that contain
masked values.

The suppression behavior is selected with the `axis` parameter.

- If axis is None, both rows and columns are suppressed.
- If axis is 0, only rows are suppressed.
- If axis is 1 or -1, only columns are suppressed.

Parameters
----------
x : array_like, MaskedArray
    The array to operate on.  If not a MaskedArray instance (or if no array
    elements are masked), `x` is interpreted as a MaskedArray with
    `mask` set to `nomask`. Must be a 2D array.
axis : int, optional
    Axis along which to perform the operation. Default is None.

Returns
-------
compressed_array : ndarray
    The compressed array.

Examples
--------
>>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
...                                                   [1, 0, 0],
...                                                   [0, 0, 0]])
>>> x
masked_array(data =
 [[-- 1 2]
 [-- 4 5]
 [6 7 8]],
             mask =
 [[ True False False]
 [ True False False]
 [False False False]],
       fill_value = 999999)

>>> np.ma.compress_rowcols(x)
array([[7, 8]])
>>> np.ma.compress_rowcols(x, 0)
array([[6, 7, 8]])
>>> np.ma.compress_rowcols(x, 1)
array([[1, 2],
       [4, 5],
       [7, 8]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a025550b104dd7f13e7630566f5d1d781}\label{namespacenumpy_1_1ma_1_1extras_a025550b104dd7f13e7630566f5d1d781} 
\index{numpy.ma.extras@{numpy.ma.extras}!compress\_rows@{compress\_rows}}
\index{compress\_rows@{compress\_rows}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{compress\_rows()}{compress\_rows()}}
{\footnotesize\ttfamily compress\+\_\+rows (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Suppress whole rows of a 2-D array that contain masked values.

This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see
`extras.compress_rowcols` for details.

See Also
--------
extras.compress_rowcols\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a9a2e45e75842e940c03e49b6d2cc628f}\label{namespacenumpy_1_1ma_1_1extras_a9a2e45e75842e940c03e49b6d2cc628f} 
\index{numpy.ma.extras@{numpy.ma.extras}!corrcoef@{corrcoef}}
\index{corrcoef@{corrcoef}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{corrcoef()}{corrcoef()}}
{\footnotesize\ttfamily corrcoef (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y = {\ttfamily None},  }\item[{}]{rowvar = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{bias = {\ttfamily np.\+\_\+NoValue},  }\item[{}]{allow\+\_\+masked = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{ddof = {\ttfamily np.\+\_\+NoValue} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return Pearson product-moment correlation coefficients.

Except for the handling of missing data this function does the same as
`numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    shape as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises an exception.  Because `bias` is deprecated, this
    argument needs to be treated as keyword only to avoid a warning.
ddof : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.10.0

See Also
--------
numpy.corrcoef : Equivalent function in top-level NumPy module.
cov : Estimate the covariance matrix.

Notes
-----
This function accepts but discards arguments `bias` and `ddof`.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a8b63355938184d1dfb87efee71c89b92}\label{namespacenumpy_1_1ma_1_1extras_a8b63355938184d1dfb87efee71c89b92} 
\index{numpy.ma.extras@{numpy.ma.extras}!count\_masked@{count\_masked}}
\index{count\_masked@{count\_masked}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{count\_masked()}{count\_masked()}}
{\footnotesize\ttfamily count\+\_\+masked (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Count the number of masked elements along the given axis.

Parameters
----------
arr : array_like
    An array with (possibly) masked elements.
axis : int, optional
    Axis along which to count. If None (default), a flattened
    version of the array is used.

Returns
-------
count : int, ndarray
    The total number of masked elements (axis=None) or the number
    of masked elements along each slice of the given axis.

See Also
--------
MaskedArray.count : Count non-masked elements.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.arange(9).reshape((3,3))
>>> a = ma.array(a)
>>> a[1, 0] = ma.masked
>>> a[1, 2] = ma.masked
>>> a[2, 1] = ma.masked
>>> a
masked_array(data =
 [[0 1 2]
 [-- 4 --]
 [6 -- 8]],
      mask =
 [[False False False]
 [ True False  True]
 [False  True False]],
      fill_value=999999)
>>> ma.count_masked(a)
3

When the `axis` keyword is used an array is returned.

>>> ma.count_masked(a, axis=0)
array([1, 1, 1])
>>> ma.count_masked(a, axis=1)
array([0, 2, 1])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_accbc225bcea6f69c98893bd2046b4a06}\label{namespacenumpy_1_1ma_1_1extras_accbc225bcea6f69c98893bd2046b4a06} 
\index{numpy.ma.extras@{numpy.ma.extras}!cov@{cov}}
\index{cov@{cov}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{cov()}{cov()}}
{\footnotesize\ttfamily cov (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y = {\ttfamily None},  }\item[{}]{rowvar = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{bias = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{allow\+\_\+masked = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{ddof = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Estimate the covariance matrix.

Except for the handling of missing data this function does the same as
`numpy.cov`. For more details and examples, see `numpy.cov`.

By default, masked values are recognized as such. If `x` and `y` have the
same shape, a common mask is allocated: if ``x[i,j]`` is masked, then
``y[i,j]`` will also be masked.
Setting `allow_masked` to False will raise an exception if values are
missing in either of the input arrays.

Parameters
----------
x : array_like
    A 1-D or 2-D array containing multiple variables and observations.
    Each row of `x` represents a variable, and each column a single
    observation of all those variables. Also see `rowvar` below.
y : array_like, optional
    An additional set of variables and observations. `y` has the same
    form as `x`.
rowvar : bool, optional
    If `rowvar` is True (default), then each row represents a
    variable, with observations in the columns. Otherwise, the relationship
    is transposed: each column represents a variable, while the rows
    contain observations.
bias : bool, optional
    Default normalization (False) is by ``(N-1)``, where ``N`` is the
    number of observations given (unbiased estimate). If `bias` is True,
    then normalization is by ``N``. This keyword can be overridden by
    the keyword ``ddof`` in numpy versions >= 1.5.
allow_masked : bool, optional
    If True, masked values are propagated pair-wise: if a value is masked
    in `x`, the corresponding value is masked in `y`.
    If False, raises a `ValueError` exception when some values are missing.
ddof : {None, int}, optional
    If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
    the number of observations; this overrides the value implied by
    ``bias``. The default value is ``None``.

    .. versionadded:: 1.5

Raises
------
ValueError
    Raised if some values are missing and `allow_masked` is False.

See Also
--------
numpy.cov\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_ac3bec268a407059de54030183dbdf848}\label{namespacenumpy_1_1ma_1_1extras_ac3bec268a407059de54030183dbdf848} 
\index{numpy.ma.extras@{numpy.ma.extras}!ediff1d@{ediff1d}}
\index{ediff1d@{ediff1d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{ediff1d()}{ediff1d()}}
{\footnotesize\ttfamily ediff1d (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{to\+\_\+end = {\ttfamily None},  }\item[{}]{to\+\_\+begin = {\ttfamily None} }\end{DoxyParamCaption})}

\DoxyHorRuler{0}
 \hypertarget{namespacenumpy_1_1ma_1_1extras_autotoc_md3}{}\doxysubsubsection{\texorpdfstring{-\/— — arraysetops —}{-— — arraysetops —}}\label{namespacenumpy_1_1ma_1_1extras_autotoc_md3}
\begin{DoxyVerb}Compute the differences between consecutive elements of an array.

This function is the equivalent of `numpy.ediff1d` that takes masked
values into account, see `numpy.ediff1d` for details.

See Also
--------
numpy.ediff1d : Equivalent function for ndarrays.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a6d5d872ad2ba13f04025727e4915701a}\label{namespacenumpy_1_1ma_1_1extras_a6d5d872ad2ba13f04025727e4915701a} 
\index{numpy.ma.extras@{numpy.ma.extras}!flatnotmasked\_contiguous@{flatnotmasked\_contiguous}}
\index{flatnotmasked\_contiguous@{flatnotmasked\_contiguous}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{flatnotmasked\_contiguous()}{flatnotmasked\_contiguous()}}
{\footnotesize\ttfamily flatnotmasked\+\_\+contiguous (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : narray
    The input array.

Returns
-------
slice_list : list
    A sorted sequence of `slice` objects (start index, end index).

    ..versionchanged:: 1.15.0
        Now returns an empty list instead of None for a fully masked array

See Also
--------
flatnotmasked_edges, notmasked_contiguous, notmasked_edges,
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
>>> a = np.ma.arange(10)
>>> np.ma.flatnotmasked_contiguous(a)
[slice(0, 10, None)]

>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

>>> np.ma.flatnotmasked_contiguous(a)
[slice(3, 5, None), slice(6, 9, None)]
>>> a[:] = np.ma.masked
>>> np.ma.flatnotmasked_contiguous(a)
[]\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_ae7b0cfcf3be019af7242f985bae1de5d}\label{namespacenumpy_1_1ma_1_1extras_ae7b0cfcf3be019af7242f985bae1de5d} 
\index{numpy.ma.extras@{numpy.ma.extras}!flatnotmasked\_edges@{flatnotmasked\_edges}}
\index{flatnotmasked\_edges@{flatnotmasked\_edges}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{flatnotmasked\_edges()}{flatnotmasked\_edges()}}
{\footnotesize\ttfamily flatnotmasked\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\DoxyHorRuler{0}
 \hypertarget{namespacenumpy_1_1ma_1_1extras_autotoc_md5}{}\doxysubsubsection{\texorpdfstring{-\/— Find unmasked data —}{-— Find unmasked data —}}\label{namespacenumpy_1_1ma_1_1extras_autotoc_md5}
\begin{DoxyVerb}Find the indices of the first and last unmasked values.

Expects a 1-D `MaskedArray`, returns None if all values are masked.

Parameters
----------
a : array_like
    Input 1-D `MaskedArray`

Returns
-------
edges : ndarray or None
    The indices of first and last non-masked value in the array.
    Returns None if all values are masked.

See Also
--------
flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges,
clump_masked, clump_unmasked

Notes
-----
Only accepts 1-D arrays.

Examples
--------
>>> a = np.ma.arange(10)
>>> flatnotmasked_edges(a)
[0,-1]

>>> mask = (a < 3) | (a > 8) | (a == 5)
>>> a[mask] = np.ma.masked
>>> np.array(a[~a.mask])
array([3, 4, 6, 7, 8])

>>> flatnotmasked_edges(a)
array([3, 8])

>>> a[:] = np.ma.masked
>>> print(flatnotmasked_edges(ma))
None\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_ac785f4a49c28834256f92afd9f23d0bf}\label{namespacenumpy_1_1ma_1_1extras_ac785f4a49c28834256f92afd9f23d0bf} 
\index{numpy.ma.extras@{numpy.ma.extras}!flatten\_inplace@{flatten\_inplace}}
\index{flatten\_inplace@{flatten\_inplace}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{flatten\_inplace()}{flatten\_inplace()}}
{\footnotesize\ttfamily flatten\+\_\+inplace (\begin{DoxyParamCaption}\item[{}]{seq }\end{DoxyParamCaption})}

\hypertarget{namespacenumpy_1_1ma_1_1extras_autotoc_md2}{}\doxysubsubsection{\texorpdfstring{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/—}{-----------------------------------------------------------------------—}}\label{namespacenumpy_1_1ma_1_1extras_autotoc_md2}
\DoxyHorRuler{0}


\begin{DoxyVerb}Flatten a sequence in place.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a28c62c1361517ea4cee63aaa55c38f75}\label{namespacenumpy_1_1ma_1_1extras_a28c62c1361517ea4cee63aaa55c38f75} 
\index{numpy.ma.extras@{numpy.ma.extras}!in1d@{in1d}}
\index{in1d@{in1d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{in1d()}{in1d()}}
{\footnotesize\ttfamily in1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{invert = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Test whether each element of an array is also present in a second
array.

The output is always a masked array. See `numpy.in1d` for more details.

We recommend using :func:`isin` instead of `in1d` for new code.

See Also
--------
isin       : Version of this function that preserves the shape of ar1.
numpy.in1d : Equivalent function for ndarrays.

Notes
-----
.. versionadded:: 1.4.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a3a15155c7b399a4463b1631b9d48b0c7}\label{namespacenumpy_1_1ma_1_1extras_a3a15155c7b399a4463b1631b9d48b0c7} 
\index{numpy.ma.extras@{numpy.ma.extras}!intersect1d@{intersect1d}}
\index{intersect1d@{intersect1d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{intersect1d()}{intersect1d()}}
{\footnotesize\ttfamily intersect1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the unique elements common to both arrays.

Masked values are considered equal one to the other.
The output is always a masked array.

See `numpy.intersect1d` for more details.

See Also
--------
numpy.intersect1d : Equivalent function for ndarrays.

Examples
--------
>>> x = array([1, 3, 3, 3], mask=[0, 0, 0, 1])
>>> y = array([3, 1, 1, 1], mask=[0, 0, 0, 1])
>>> intersect1d(x, y)
masked_array(data = [1 3 --],
             mask = [False False  True],
       fill_value = 999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a54ee8925095479d12e999198824ab115}\label{namespacenumpy_1_1ma_1_1extras_a54ee8925095479d12e999198824ab115} 
\index{numpy.ma.extras@{numpy.ma.extras}!isin@{isin}}
\index{isin@{isin}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{isin()}{isin()}}
{\footnotesize\ttfamily isin (\begin{DoxyParamCaption}\item[{}]{element,  }\item[{}]{test\+\_\+elements,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{invert = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculates `element in test_elements`, broadcasting over
`element` only.

The output is always a masked array of the same shape as `element`.
See `numpy.isin` for more details.

See Also
--------
in1d       : Flattened version of this function.
numpy.isin : Equivalent function for ndarrays.

Notes
-----
.. versionadded:: 1.13.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a2baf4c56a08270bbeb329b7a383a04e8}\label{namespacenumpy_1_1ma_1_1extras_a2baf4c56a08270bbeb329b7a383a04e8} 
\index{numpy.ma.extras@{numpy.ma.extras}!issequence@{issequence}}
\index{issequence@{issequence}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{issequence()}{issequence()}}
{\footnotesize\ttfamily issequence (\begin{DoxyParamCaption}\item[{}]{seq }\end{DoxyParamCaption})}

\begin{DoxyVerb}Is seq a sequence (ndarray, list or tuple)?\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_ab442bf793f2b07da2c6e39a7afd6d044}\label{namespacenumpy_1_1ma_1_1extras_ab442bf793f2b07da2c6e39a7afd6d044} 
\index{numpy.ma.extras@{numpy.ma.extras}!mask\_cols@{mask\_cols}}
\index{mask\_cols@{mask\_cols}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{mask\_cols()}{mask\_cols()}}
{\footnotesize\ttfamily mask\+\_\+cols (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask columns of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(data =
 [[0 0 0]
 [0 -- 0]
 [0 0 0]],
      mask =
 [[False False False]
 [False  True False]
 [False False False]],
      fill_value=999999)
>>> ma.mask_cols(a)
masked_array(data =
 [[0 -- 0]
 [0 -- 0]
 [0 -- 0]],
      mask =
 [[False  True False]
 [False  True False]
 [False  True False]],
      fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a6629f4c96eac6c1e1a5aff43a0c76e6c}\label{namespacenumpy_1_1ma_1_1extras_a6629f4c96eac6c1e1a5aff43a0c76e6c} 
\index{numpy.ma.extras@{numpy.ma.extras}!mask\_rows@{mask\_rows}}
\index{mask\_rows@{mask\_rows}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{mask\_rows()}{mask\_rows()}}
{\footnotesize\ttfamily mask\+\_\+rows (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Mask rows of a 2D array that contain masked values.

This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.

See Also
--------
mask_rowcols : Mask rows and/or columns of a 2D array.
masked_where : Mask where a condition is met.

Examples
--------
>>> import numpy.ma as ma
>>> a = np.zeros((3, 3), dtype=int)
>>> a[1, 1] = 1
>>> a
array([[0, 0, 0],
       [0, 1, 0],
       [0, 0, 0]])
>>> a = ma.masked_equal(a, 1)
>>> a
masked_array(data =
 [[0 0 0]
 [0 -- 0]
 [0 0 0]],
      mask =
 [[False False False]
 [False  True False]
 [False False False]],
      fill_value=999999)
>>> ma.mask_rows(a)
masked_array(data =
 [[0 0 0]
 [-- -- --]
 [0 0 0]],
      mask =
 [[False False False]
 [ True  True  True]
 [False False False]],
      fill_value=999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_abeffd116292f1027d6f770690560fd8a}\label{namespacenumpy_1_1ma_1_1extras_abeffd116292f1027d6f770690560fd8a} 
\index{numpy.ma.extras@{numpy.ma.extras}!masked\_all@{masked\_all}}
\index{masked\_all@{masked\_all}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{masked\_all()}{masked\_all()}}
{\footnotesize\ttfamily masked\+\_\+all (\begin{DoxyParamCaption}\item[{}]{shape,  }\item[{}]{dtype = {\ttfamily float} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Empty masked array with all elements masked.

Return an empty masked array of the given shape and dtype, where all the
data are masked.

Parameters
----------
shape : tuple
    Shape of the required MaskedArray.
dtype : dtype, optional
    Data type of the output.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

See Also
--------
masked_all_like : Empty masked array modelled on an existing array.

Examples
--------
>>> import numpy.ma as ma
>>> ma.masked_all((3, 3))
masked_array(data =
 [[-- -- --]
 [-- -- --]
 [-- -- --]],
      mask =
 [[ True  True  True]
 [ True  True  True]
 [ True  True  True]],
      fill_value=1e+20)

The `dtype` parameter defines the underlying data type.

>>> a = ma.masked_all((3, 3))
>>> a.dtype
dtype('float64')
>>> a = ma.masked_all((3, 3), dtype=np.int32)
>>> a.dtype
dtype('int32')\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a183375c8556432e8031b9b3f6b632abf}\label{namespacenumpy_1_1ma_1_1extras_a183375c8556432e8031b9b3f6b632abf} 
\index{numpy.ma.extras@{numpy.ma.extras}!masked\_all\_like@{masked\_all\_like}}
\index{masked\_all\_like@{masked\_all\_like}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{masked\_all\_like()}{masked\_all\_like()}}
{\footnotesize\ttfamily masked\+\_\+all\+\_\+like (\begin{DoxyParamCaption}\item[{}]{arr }\end{DoxyParamCaption})}

\begin{DoxyVerb}Empty masked array with the properties of an existing array.

Return an empty masked array of the same shape and dtype as
the array `arr`, where all the data are masked.

Parameters
----------
arr : ndarray
    An array describing the shape and dtype of the required MaskedArray.

Returns
-------
a : MaskedArray
    A masked array with all data masked.

Raises
------
AttributeError
    If `arr` doesn't have a shape attribute (i.e. not an ndarray)

See Also
--------
masked_all : Empty masked array with all elements masked.

Examples
--------
>>> import numpy.ma as ma
>>> arr = np.zeros((2, 3), dtype=np.float32)
>>> arr
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]], dtype=float32)
>>> ma.masked_all_like(arr)
masked_array(data =
 [[-- -- --]
 [-- -- --]],
      mask =
 [[ True  True  True]
 [ True  True  True]],
      fill_value=1e+20)

The dtype of the masked array matches the dtype of `arr`.

>>> arr.dtype
dtype('float32')
>>> ma.masked_all_like(arr).dtype
dtype('float32')\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a0901a19189c37fffee8f6d673fc10b8c}\label{namespacenumpy_1_1ma_1_1extras_a0901a19189c37fffee8f6d673fc10b8c} 
\index{numpy.ma.extras@{numpy.ma.extras}!median@{median}}
\index{median@{median}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{median()}{median()}}
{\footnotesize\ttfamily median (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None},  }\item[{}]{out = {\ttfamily None},  }\item[{}]{overwrite\+\_\+input = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{keepdims = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the median along the specified axis.

Returns the median of the array elements.

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : int, optional
    Axis along which the medians are computed. The default (None) is
    to compute the median along a flattened version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow use of memory of input array (a) for
    calculations. The input array will be modified by the call to
    median. This will save memory when you do not need to preserve
    the contents of the input array. Treat the input as undefined,
    but it will probably be fully or partially sorted. Default is
    False. Note that, if `overwrite_input` is True, and the input
    is not already an `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    .. versionadded:: 1.10.0

Returns
-------
median : ndarray
    A new array holding the result is returned unless out is
    specified, in which case a reference to out is returned.
    Return data-type is `float64` for integers and floats smaller than
    `float64`, or the input data-type, otherwise.

See Also
--------
mean

Notes
-----
Given a vector ``V`` with ``N`` non masked values, the median of ``V``
is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.
``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``
when ``N`` is even.

Examples
--------
>>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
>>> np.ma.median(x)
1.5

>>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
>>> np.ma.median(x)
2.5
>>> np.ma.median(x, axis=-1, overwrite_input=True)
masked_array(data = [ 2.  5.],
             mask = False,
       fill_value = 1e+20)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a11def3d9715f46b6c144c0f1a500a116}\label{namespacenumpy_1_1ma_1_1extras_a11def3d9715f46b6c144c0f1a500a116} 
\index{numpy.ma.extras@{numpy.ma.extras}!notmasked\_contiguous@{notmasked\_contiguous}}
\index{notmasked\_contiguous@{notmasked\_contiguous}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{notmasked\_contiguous()}{notmasked\_contiguous()}}
{\footnotesize\ttfamily notmasked\+\_\+contiguous (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find contiguous unmasked data in a masked array along the given axis.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array, and this
    is the same as `flatnotmasked_contiguous`.

Returns
-------
endpoints : list
    A list of slices (start and end indexes) of unmasked indexes
    in the array.

    If the input is 2d and axis is specified, the result is a list of lists.

See Also
--------
flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,
clump_masked, clump_unmasked

Notes
-----
Only accepts 2-D arrays at most.

Examples
--------
>>> a = np.arange(12).reshape((3, 4))
>>> mask = np.zeros_like(a)
>>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0
>>> ma = np.ma.array(a, mask=mask)
>>> ma
masked_array(
  data=[[0, --, 2, 3],
        [--, --, --, 7],
        [8, --, --, 11]],
  mask=[[False,  True, False, False],
        [ True,  True,  True, False],
        [False,  True,  True, False]],
  fill_value=999999)
>>> np.array(ma[~ma.mask])
array([ 0,  2,  3,  7, 8, 11])

>>> np.ma.notmasked_contiguous(ma)
[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]

>>> np.ma.notmasked_contiguous(ma, axis=0)
[[slice(0, 1, None), slice(2, 3, None)],  # column broken into two segments
 [],                                      # fully masked column
 [slice(0, 1, None)],
 [slice(0, 3, None)]]

>>> np.ma.notmasked_contiguous(ma, axis=1)
[[slice(0, 1, None), slice(2, 4, None)],  # row broken into two segments
 [slice(3, 4, None)],
 [slice(0, 1, None), slice(3, 4, None)]]
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a253f41e0aa8f0aeaa8c4b31e5b6b3f44}\label{namespacenumpy_1_1ma_1_1extras_a253f41e0aa8f0aeaa8c4b31e5b6b3f44} 
\index{numpy.ma.extras@{numpy.ma.extras}!notmasked\_edges@{notmasked\_edges}}
\index{notmasked\_edges@{notmasked\_edges}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{notmasked\_edges()}{notmasked\_edges()}}
{\footnotesize\ttfamily notmasked\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the indices of the first and last unmasked values along an axis.

If all values are masked, return None.  Otherwise, return a list
of two tuples, corresponding to the indices of the first and last
unmasked values respectively.

Parameters
----------
a : array_like
    The input array.
axis : int, optional
    Axis along which to perform the operation.
    If None (default), applies to a flattened version of the array.

Returns
-------
edges : ndarray or list
    An array of start and end indexes if there are any masked data in
    the array. If there are no masked data in the array, `edges` is a
    list of the first and last index.

See Also
--------
flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous,
clump_masked, clump_unmasked

Examples
--------
>>> a = np.arange(9).reshape((3, 3))
>>> m = np.zeros_like(a)
>>> m[1:, 1:] = 1

>>> am = np.ma.array(a, mask=m)
>>> np.array(am[~am.mask])
array([0, 1, 2, 3, 6])

>>> np.ma.notmasked_edges(ma)
array([0, 6])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a0bb1dec93d11ecc14ff085ef19c7651c}\label{namespacenumpy_1_1ma_1_1extras_a0bb1dec93d11ecc14ff085ef19c7651c} 
\index{numpy.ma.extras@{numpy.ma.extras}!polyfit@{polyfit}}
\index{polyfit@{polyfit}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{polyfit()}{polyfit()}}
{\footnotesize\ttfamily polyfit (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y,  }\item[{}]{deg,  }\item[{}]{rcond = {\ttfamily None},  }\item[{}]{full = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{w = {\ttfamily None},  }\item[{}]{cov = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Any masked values in x is propagated in y, and vice-versa.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a29fa3c52ee76f4fe3c45d8fd79ef9a8f}\label{namespacenumpy_1_1ma_1_1extras_a29fa3c52ee76f4fe3c45d8fd79ef9a8f} 
\index{numpy.ma.extras@{numpy.ma.extras}!setdiff1d@{setdiff1d}}
\index{setdiff1d@{setdiff1d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{setdiff1d()}{setdiff1d()}}
{\footnotesize\ttfamily setdiff1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set difference of 1D arrays with unique elements.

The output is always a masked array. See `numpy.setdiff1d` for more
details.

See Also
--------
numpy.setdiff1d : Equivalent function for ndarrays.

Examples
--------
>>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
>>> np.ma.setdiff1d(x, [1, 2])
masked_array(data = [3 --],
             mask = [False  True],
       fill_value = 999999)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a734ad367bcbd8ee1434a7be8c473ac5c}\label{namespacenumpy_1_1ma_1_1extras_a734ad367bcbd8ee1434a7be8c473ac5c} 
\index{numpy.ma.extras@{numpy.ma.extras}!setxor1d@{setxor1d}}
\index{setxor1d@{setxor1d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{setxor1d()}{setxor1d()}}
{\footnotesize\ttfamily setxor1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set exclusive-or of 1-D arrays with unique elements.

The output is always a masked array. See `numpy.setxor1d` for more details.

See Also
--------
numpy.setxor1d : Equivalent function for ndarrays.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a76dfbada427ca7b6b64e414b9fd34ea3}\label{namespacenumpy_1_1ma_1_1extras_a76dfbada427ca7b6b64e414b9fd34ea3} 
\index{numpy.ma.extras@{numpy.ma.extras}!union1d@{union1d}}
\index{union1d@{union1d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{union1d()}{union1d()}}
{\footnotesize\ttfamily union1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Union of two arrays.

The output is always a masked array. See `numpy.union1d` for more details.

See also
--------
numpy.union1d : Equivalent function for ndarrays.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a5e0cea396da40300b612cb2e0611428f}\label{namespacenumpy_1_1ma_1_1extras_a5e0cea396da40300b612cb2e0611428f} 
\index{numpy.ma.extras@{numpy.ma.extras}!unique@{unique}}
\index{unique@{unique}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily unique (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{return\+\_\+index = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{return\+\_\+inverse = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Finds the unique elements of an array.

Masked values are considered the same element (masked). The output array
is always a masked array. See `numpy.unique` for more details.

See Also
--------
numpy.unique : Equivalent function for ndarrays.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1ma_1_1extras_a7b06d7d578efef1fd42cf0802f16b140}\label{namespacenumpy_1_1ma_1_1extras_a7b06d7d578efef1fd42cf0802f16b140} 
\index{numpy.ma.extras@{numpy.ma.extras}!vander@{vander}}
\index{vander@{vander}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{vander()}{vander()}}
{\footnotesize\ttfamily vander (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{n = {\ttfamily None} }\end{DoxyParamCaption})}



Polynomial fit \#. 

\begin{DoxyVerb}Masked values in the input array result in rows of zeros.\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1ma_1_1extras_a1e76b5377881903d86b7aec245d26257}\label{namespacenumpy_1_1ma_1_1extras_a1e76b5377881903d86b7aec245d26257} 
\index{numpy.ma.extras@{numpy.ma.extras}!atleast\_1d@{atleast\_1d}}
\index{atleast\_1d@{atleast\_1d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{atleast\_1d}{atleast\_1d}}
{\footnotesize\ttfamily atleast\+\_\+1d = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__allargs}{\+\_\+fromnxfunction\+\_\+allargs}}(\textquotesingle{}atleast\+\_\+1d\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_a7d2fbcfcbcca14aec211ee7dc55717a2}\label{namespacenumpy_1_1ma_1_1extras_a7d2fbcfcbcca14aec211ee7dc55717a2} 
\index{numpy.ma.extras@{numpy.ma.extras}!atleast\_2d@{atleast\_2d}}
\index{atleast\_2d@{atleast\_2d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{atleast\_2d}{atleast\_2d}}
{\footnotesize\ttfamily atleast\+\_\+2d = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__allargs}{\+\_\+fromnxfunction\+\_\+allargs}}(\textquotesingle{}atleast\+\_\+2d\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_a1a96cd8a13aafcb85e58fb7cf853ca3e}\label{namespacenumpy_1_1ma_1_1extras_a1a96cd8a13aafcb85e58fb7cf853ca3e} 
\index{numpy.ma.extras@{numpy.ma.extras}!atleast\_3d@{atleast\_3d}}
\index{atleast\_3d@{atleast\_3d}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{atleast\_3d}{atleast\_3d}}
{\footnotesize\ttfamily atleast\+\_\+3d = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__allargs}{\+\_\+fromnxfunction\+\_\+allargs}}(\textquotesingle{}atleast\+\_\+3d\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_ac3cb01e454dca81e06d5cb8f9219c8fb}\label{namespacenumpy_1_1ma_1_1extras_ac3cb01e454dca81e06d5cb8f9219c8fb} 
\index{numpy.ma.extras@{numpy.ma.extras}!column\_stack@{column\_stack}}
\index{column\_stack@{column\_stack}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{column\_stack}{column\_stack}}
{\footnotesize\ttfamily column\+\_\+stack = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}column\+\_\+stack\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_aa389efca6afc7d44eed92479e50be422}\label{namespacenumpy_1_1ma_1_1extras_aa389efca6afc7d44eed92479e50be422} 
\index{numpy.ma.extras@{numpy.ma.extras}!diagflat@{diagflat}}
\index{diagflat@{diagflat}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{diagflat}{diagflat}}
{\footnotesize\ttfamily diagflat = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__single}{\+\_\+fromnxfunction\+\_\+single}}(\textquotesingle{}diagflat\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_a627175ae0b038340f0ea06873b20e6f2}\label{namespacenumpy_1_1ma_1_1extras_a627175ae0b038340f0ea06873b20e6f2} 
\index{numpy.ma.extras@{numpy.ma.extras}!dstack@{dstack}}
\index{dstack@{dstack}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{dstack}{dstack}}
{\footnotesize\ttfamily dstack = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}dstack\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_a19b5d1b06eceaf6cfb4daec742915584}\label{namespacenumpy_1_1ma_1_1extras_a19b5d1b06eceaf6cfb4daec742915584} 
\index{numpy.ma.extras@{numpy.ma.extras}!hsplit@{hsplit}}
\index{hsplit@{hsplit}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{hsplit}{hsplit}}
{\footnotesize\ttfamily hsplit = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__single}{\+\_\+fromnxfunction\+\_\+single}}(\textquotesingle{}hsplit\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_ac52d71a73d2156a5480e7a2536041c8a}\label{namespacenumpy_1_1ma_1_1extras_ac52d71a73d2156a5480e7a2536041c8a} 
\index{numpy.ma.extras@{numpy.ma.extras}!hstack@{hstack}}
\index{hstack@{hstack}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{hstack}{hstack}}
{\footnotesize\ttfamily hstack = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}hstack\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_a521c35256d56b306288f49ec9c43c730}\label{namespacenumpy_1_1ma_1_1extras_a521c35256d56b306288f49ec9c43c730} 
\index{numpy.ma.extras@{numpy.ma.extras}!mr\_@{mr\_}}
\index{mr\_@{mr\_}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{mr\_}{mr\_}}
{\footnotesize\ttfamily mr\+\_\+ = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1mr__class}{mr\+\_\+class}}()}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_a37d7c639a3adefa88200027e9f78ba3f}\label{namespacenumpy_1_1ma_1_1extras_a37d7c639a3adefa88200027e9f78ba3f} 
\index{numpy.ma.extras@{numpy.ma.extras}!stack@{stack}}
\index{stack@{stack}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{stack}{stack}}
{\footnotesize\ttfamily \mbox{\hyperlink{seem_8h_a808b546b9141ff44ac0c3ea9a3895792}{stack}} = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}\mbox{\hyperlink{seem_8h_a808b546b9141ff44ac0c3ea9a3895792}{stack}}\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1ma_1_1extras_a3c3ba338379e2116ca8410aaeb2225ad}\label{namespacenumpy_1_1ma_1_1extras_a3c3ba338379e2116ca8410aaeb2225ad} 
\index{numpy.ma.extras@{numpy.ma.extras}!vstack@{vstack}}
\index{vstack@{vstack}!numpy.ma.extras@{numpy.ma.extras}}
\doxysubsubsection{\texorpdfstring{vstack}{vstack}}
{\footnotesize\ttfamily vstack = \mbox{\hyperlink{classnumpy_1_1ma_1_1extras_1_1__fromnxfunction__seq}{\+\_\+fromnxfunction\+\_\+seq}}(\textquotesingle{}vstack\textquotesingle{})}

