\doxysection{numpy.\+lib.\+type\+\_\+check Namespace Reference}
\hypertarget{namespacenumpy_1_1lib_1_1type__check}{}\label{namespacenumpy_1_1lib_1_1type__check}\index{numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a2ea8323faee621b7960d999169b4d03e}{mintypecode}} (typechars, typeset=\textquotesingle{}GDFgdf\textquotesingle{}, default=\textquotesingle{}d\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_af9cbf4c40720cddc082c1cef1242ca73}{asfarray}} (a, dtype=\+\_\+nx.\+float\+\_\+)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a7f54b31d2ec3ba21479ffe2279df991d}{real}} (val)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a73cd2fb69eb7e7b4b44527a8918bb584}{imag}} (val)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_adf0e9c922fde44a2b13fdf9d64159d08}{iscomplex}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_aee5e488547fc0383c182ad6e7ed3b7b2}{isreal}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a5ad5dcd1513532fad58736b80e75faa6}{iscomplexobj}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a6681f698b7df5899eaa63ee1155b48d5}{isrealobj}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a7812ec6cc2ebd16aba648aebb1a6f0ef}{\+\_\+getmaxmin}} (t)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a8383015f965d9dc5f844c1cbbc79304f}{nan\+\_\+to\+\_\+num}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1function__base_a2fe28201b1e88676712651ddf07a90d3}{copy}}=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a18ddde7a062d67186a88b8c0be6b15a9}{real\+\_\+if\+\_\+close}} (a, tol=100)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a51c31209a1e51486c40b90407a751234}{asscalar}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_ad0305f66e82950cc7efab06a584ad8d0}{typename}} (char)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a4601b795d689aa8b0d7726833b7395d0}{common\+\_\+type}} (\texorpdfstring{$\ast$}{*}arrays)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
str \mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_ab6d1950081c6dc92c2227cc774b621fd}{\+\_\+typecodes\+\_\+by\+\_\+elsize}} = \textquotesingle{}GDFgdf\+Qq\+Ll\+Ii\+Hh\+Bb?\textquotesingle{}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a03e0300f978131344b6d050a078ae2ea}{\+\_\+namefromtype}}
\item 
list \mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_a50c2d77eb11a72beb25a41878ccecee9}{array\+\_\+type}}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1lib_1_1type__check_affcac574730c3f38760af090ab1f4aac}{array\+\_\+precision}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Automatically adapted for numpy Sep 19, 2005 by convertcode.py\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1type__check_a7812ec6cc2ebd16aba648aebb1a6f0ef}\label{namespacenumpy_1_1lib_1_1type__check_a7812ec6cc2ebd16aba648aebb1a6f0ef} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!\_getmaxmin@{\_getmaxmin}}
\index{\_getmaxmin@{\_getmaxmin}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{\_getmaxmin()}{\_getmaxmin()}}
{\footnotesize\ttfamily \+\_\+getmaxmin (\begin{DoxyParamCaption}\item[{}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1type__check_af9cbf4c40720cddc082c1cef1242ca73}\label{namespacenumpy_1_1lib_1_1type__check_af9cbf4c40720cddc082c1cef1242ca73} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!asfarray@{asfarray}}
\index{asfarray@{asfarray}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{asfarray()}{asfarray()}}
{\footnotesize\ttfamily asfarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily \+\_\+nx.float\+\_\+} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array converted to a float type.

Parameters
----------
a : array_like
    The input array.
dtype : str or dtype object, optional
    Float type code to coerce input array `a`.  If `dtype` is one of the
    'int' dtypes, it is replaced with float64.

Returns
-------
out : ndarray
    The input `a` as a float ndarray.

Examples
--------
>>> np.asfarray([2, 3])
array([ 2.,  3.])
>>> np.asfarray([2, 3], dtype='float')
array([ 2.,  3.])
>>> np.asfarray([2, 3], dtype='int8')
array([ 2.,  3.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a51c31209a1e51486c40b90407a751234}\label{namespacenumpy_1_1lib_1_1type__check_a51c31209a1e51486c40b90407a751234} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!asscalar@{asscalar}}
\index{asscalar@{asscalar}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{asscalar()}{asscalar()}}
{\footnotesize\ttfamily asscalar (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert an array of size 1 to its scalar equivalent.

Parameters
----------
a : ndarray
    Input array of size 1.

Returns
-------
out : scalar
    Scalar representation of `a`. The output data type is the same type
    returned by the input's `item` method.

Examples
--------
>>> np.asscalar(np.array([24]))
24\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a4601b795d689aa8b0d7726833b7395d0}\label{namespacenumpy_1_1lib_1_1type__check_a4601b795d689aa8b0d7726833b7395d0} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!common\_type@{common\_type}}
\index{common\_type@{common\_type}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{common\_type()}{common\_type()}}
{\footnotesize\ttfamily common\+\_\+type (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{arrays }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a scalar type which is common to the input arrays.

The return type will always be an inexact (i.e. floating point) scalar
type, even if all the arrays are integer arrays. If one of the inputs is
an integer array, the minimum precision type that is returned is a
64-bit floating point dtype.

All input arrays except int64 and uint64 can be safely cast to the
returned dtype without loss of information.

Parameters
----------
array1, array2, ... : ndarrays
    Input arrays.

Returns
-------
out : data type code
    Data type code.

See Also
--------
dtype, mintypecode

Examples
--------
>>> np.common_type(np.arange(2, dtype=np.float32))
<type 'numpy.float32'>
>>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))
<type 'numpy.float64'>
>>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))
<type 'numpy.complex128'>\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a73cd2fb69eb7e7b4b44527a8918bb584}\label{namespacenumpy_1_1lib_1_1type__check_a73cd2fb69eb7e7b4b44527a8918bb584} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!imag@{imag}}
\index{imag@{imag}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{imag()}{imag()}}
{\footnotesize\ttfamily imag (\begin{DoxyParamCaption}\item[{}]{val }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the imaginary part of the complex argument.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray or scalar
    The imaginary component of the complex argument. If `val` is real,
    the type of `val` is used for the output.  If `val` has complex
    elements, the returned type is float.

See Also
--------
real, angle, real_if_close

Examples
--------
>>> a = np.array([1+2j, 3+4j, 5+6j])
>>> a.imag
array([ 2.,  4.,  6.])
>>> a.imag = np.array([8, 10, 12])
>>> a
array([ 1. +8.j,  3.+10.j,  5.+12.j])
>>> np.imag(1 + 1j)
1.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_adf0e9c922fde44a2b13fdf9d64159d08}\label{namespacenumpy_1_1lib_1_1type__check_adf0e9c922fde44a2b13fdf9d64159d08} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!iscomplex@{iscomplex}}
\index{iscomplex@{iscomplex}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{iscomplex()}{iscomplex()}}
{\footnotesize\ttfamily iscomplex (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a bool array, where True if input element is complex.

What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray of bools
    Output array.

See Also
--------
isreal
iscomplexobj : Return True if x is a complex type or an array of complex
               numbers.

Examples
--------
>>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([ True, False, False, False, False,  True])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a5ad5dcd1513532fad58736b80e75faa6}\label{namespacenumpy_1_1lib_1_1type__check_a5ad5dcd1513532fad58736b80e75faa6} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!iscomplexobj@{iscomplexobj}}
\index{iscomplexobj@{iscomplexobj}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{iscomplexobj()}{iscomplexobj()}}
{\footnotesize\ttfamily iscomplexobj (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check for a complex type or an array of complex numbers.

The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, `iscomplexobj` evaluates to True.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
iscomplexobj : bool
    The return value, True if `x` is of a complex type or has at least
    one complex element.

See Also
--------
isrealobj, iscomplex

Examples
--------
>>> np.iscomplexobj(1)
False
>>> np.iscomplexobj(1+0j)
True
>>> np.iscomplexobj([3, 1+0j, True])
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_aee5e488547fc0383c182ad6e7ed3b7b2}\label{namespacenumpy_1_1lib_1_1type__check_aee5e488547fc0383c182ad6e7ed3b7b2} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!isreal@{isreal}}
\index{isreal@{isreal}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{isreal()}{isreal()}}
{\footnotesize\ttfamily isreal (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a bool array, where True if input element is real.

If element has complex type with zero complex part, the return value
for that element is True.

Parameters
----------
x : array_like
    Input array.

Returns
-------
out : ndarray, bool
    Boolean array of same shape as `x`.

See Also
--------
iscomplex
isrealobj : Return True if x is not a complex type.

Examples
--------
>>> np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])
array([False,  True,  True,  True,  True, False])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a6681f698b7df5899eaa63ee1155b48d5}\label{namespacenumpy_1_1lib_1_1type__check_a6681f698b7df5899eaa63ee1155b48d5} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!isrealobj@{isrealobj}}
\index{isrealobj@{isrealobj}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{isrealobj()}{isrealobj()}}
{\footnotesize\ttfamily isrealobj (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True if x is a not complex type or an array of complex numbers.

The type of the input is checked, not the value. So even if the input
has an imaginary part equal to zero, `isrealobj` evaluates to False
if the data type is complex.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
y : bool
    The return value, False if `x` is of a complex type.

See Also
--------
iscomplexobj, isreal

Examples
--------
>>> np.isrealobj(1)
True
>>> np.isrealobj(1+0j)
False
>>> np.isrealobj([3, 1+0j, True])
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a2ea8323faee621b7960d999169b4d03e}\label{namespacenumpy_1_1lib_1_1type__check_a2ea8323faee621b7960d999169b4d03e} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!mintypecode@{mintypecode}}
\index{mintypecode@{mintypecode}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{mintypecode()}{mintypecode()}}
{\footnotesize\ttfamily mintypecode (\begin{DoxyParamCaption}\item[{}]{typechars,  }\item[{}]{typeset = {\ttfamily \textquotesingle{}GDFgdf\textquotesingle{}},  }\item[{}]{default = {\ttfamily \textquotesingle{}d\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the character for the minimum-size type to which given types can
be safely cast.

The returned type character must represent the smallest size dtype such
that an array of the returned type can handle the data from an array of
all types in `typechars` (or if `typechars` is an array, then its
dtype.char).

Parameters
----------
typechars : list of str or array_like
    If a list of strings, each string should represent a dtype.
    If array_like, the character representation of the array dtype is used.
typeset : str or list of str, optional
    The set of characters that the returned character is chosen from.
    The default set is 'GDFgdf'.
default : str, optional
    The default character, this is returned if none of the characters in
    `typechars` matches a character in `typeset`.

Returns
-------
typechar : str
    The character representing the minimum-size type that was found.

See Also
--------
dtype, sctype2char, maximum_sctype

Examples
--------
>>> np.mintypecode(['d', 'f', 'S'])
'd'
>>> x = np.array([1.1, 2-3.j])
>>> np.mintypecode(x)
'D'

>>> np.mintypecode('abceh', default='G')
'G'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a8383015f965d9dc5f844c1cbbc79304f}\label{namespacenumpy_1_1lib_1_1type__check_a8383015f965d9dc5f844c1cbbc79304f} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!nan\_to\_num@{nan\_to\_num}}
\index{nan\_to\_num@{nan\_to\_num}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{nan\_to\_num()}{nan\_to\_num()}}
{\footnotesize\ttfamily nan\+\_\+to\+\_\+num (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{copy = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Replace NaN with zero and infinity with large finite numbers.

If `x` is inexact, NaN is replaced by zero, and infinity and -infinity
replaced by the respectively largest and most negative finite floating
point values representable by ``x.dtype``.

For complex dtypes, the above is applied to each of the real and
imaginary components of `x` separately.

If `x` is not inexact, then no replacements are made.

Parameters
----------
x : scalar or array_like
    Input data.
copy : bool, optional
    Whether to create a copy of `x` (True) or to replace values
    in-place (False). The in-place operation only occurs if
    casting to an array does not require a copy.
    Default is True.

    .. versionadded:: 1.13

Returns
-------
out : ndarray
    `x`, with the non-finite values replaced. If `copy` is False, this may
    be `x` itself.

See Also
--------
isinf : Shows which elements are positive or negative infinity.
isneginf : Shows which elements are negative infinity.
isposinf : Shows which elements are positive infinity.
isnan : Shows which elements are Not a Number (NaN).
isfinite : Shows which elements are finite (not NaN, not infinity)

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.

Examples
--------
>>> np.nan_to_num(np.inf)
1.7976931348623157e+308
>>> np.nan_to_num(-np.inf)
-1.7976931348623157e+308
>>> np.nan_to_num(np.nan)
0.0
>>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
>>> np.nan_to_num(x)
array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,
        -1.28000000e+002,   1.28000000e+002])
>>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
>>> np.nan_to_num(y)
array([  1.79769313e+308 +0.00000000e+000j,
         0.00000000e+000 +0.00000000e+000j,
         0.00000000e+000 +1.79769313e+308j])
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a7f54b31d2ec3ba21479ffe2279df991d}\label{namespacenumpy_1_1lib_1_1type__check_a7f54b31d2ec3ba21479ffe2279df991d} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!real@{real}}
\index{real@{real}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{real()}{real()}}
{\footnotesize\ttfamily real (\begin{DoxyParamCaption}\item[{}]{val }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the real part of the complex argument.

Parameters
----------
val : array_like
    Input array.

Returns
-------
out : ndarray or scalar
    The real component of the complex argument. If `val` is real, the type
    of `val` is used for the output.  If `val` has complex elements, the
    returned type is float.

See Also
--------
real_if_close, imag, angle

Examples
--------
>>> a = np.array([1+2j, 3+4j, 5+6j])
>>> a.real
array([ 1.,  3.,  5.])
>>> a.real = 9
>>> a
array([ 9.+2.j,  9.+4.j,  9.+6.j])
>>> a.real = np.array([9, 8, 7])
>>> a
array([ 9.+2.j,  8.+4.j,  7.+6.j])
>>> np.real(1 + 1j)
1.0\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_a18ddde7a062d67186a88b8c0be6b15a9}\label{namespacenumpy_1_1lib_1_1type__check_a18ddde7a062d67186a88b8c0be6b15a9} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!real\_if\_close@{real\_if\_close}}
\index{real\_if\_close@{real\_if\_close}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{real\_if\_close()}{real\_if\_close()}}
{\footnotesize\ttfamily real\+\_\+if\+\_\+close (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{tol = {\ttfamily 100} }\end{DoxyParamCaption})}

\begin{DoxyVerb}If complex input returns a real array if complex parts are close to zero.

"Close to zero" is defined as `tol` * (machine epsilon of the type for
`a`).

Parameters
----------
a : array_like
    Input array.
tol : float
    Tolerance in machine epsilons for the complex part of the elements
    in the array.

Returns
-------
out : ndarray
    If `a` is real, the type of `a` is used for the output.  If `a`
    has complex elements, the returned type is float.

See Also
--------
real, imag, angle

Notes
-----
Machine epsilon varies from machine to machine and between data types
but Python floats on most platforms have a machine epsilon equal to
2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print
out the machine epsilon for floats.

Examples
--------
>>> np.finfo(float).eps
2.2204460492503131e-16

>>> np.real_if_close([2.1 + 4e-14j], tol=1000)
array([ 2.1])
>>> np.real_if_close([2.1 + 4e-13j], tol=1000)
array([ 2.1 +4.00000000e-13j])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1type__check_ad0305f66e82950cc7efab06a584ad8d0}\label{namespacenumpy_1_1lib_1_1type__check_ad0305f66e82950cc7efab06a584ad8d0} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!typename@{typename}}
\index{typename@{typename}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{typename()}{typename()}}
{\footnotesize\ttfamily typename (\begin{DoxyParamCaption}\item[{}]{char }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a description for the given data type code.

Parameters
----------
char : str
    Data type code.

Returns
-------
out : str
    Description of the input data type code.

See Also
--------
dtype, typecodes

Examples
--------
>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
>>> for typechar in typechars:
...     print(typechar, ' : ', np.typename(typechar))
...
S1  :  character
?  :  bool
B  :  unsigned char
D  :  complex double precision
G  :  complex long double precision
F  :  complex single precision
I  :  unsigned integer
H  :  unsigned short
L  :  unsigned long integer
O  :  object
Q  :  unsigned long long integer
S  :  string
U  :  unicode
V  :  void
b  :  signed char
d  :  double precision
g  :  long precision
f  :  single precision
i  :  integer
h  :  short
l  :  long integer
q  :  long long integer\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1type__check_a03e0300f978131344b6d050a078ae2ea}\label{namespacenumpy_1_1lib_1_1type__check_a03e0300f978131344b6d050a078ae2ea} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!\_namefromtype@{\_namefromtype}}
\index{\_namefromtype@{\_namefromtype}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{\_namefromtype}{\_namefromtype}}
{\footnotesize\ttfamily dict \+\_\+namefromtype\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{'S1'}:\ \textcolor{stringliteral}{'character'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'?'}:\ \textcolor{stringliteral}{'bool'},}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'b'}:\ \textcolor{stringliteral}{'signed\ char'},}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'B'}:\ \textcolor{stringliteral}{'unsigned\ char'},}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'h'}:\ \textcolor{stringliteral}{'short'},}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'H'}:\ \textcolor{stringliteral}{'unsigned\ short'},}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'i'}:\ \textcolor{stringliteral}{'integer'},}
\DoxyCodeLine{00008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'I'}:\ \textcolor{stringliteral}{'unsigned\ integer'},}
\DoxyCodeLine{00009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'l'}:\ \textcolor{stringliteral}{'long\ integer'},}
\DoxyCodeLine{00010\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'L'}:\ \textcolor{stringliteral}{'unsigned\ long\ integer'},}
\DoxyCodeLine{00011\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'q'}:\ \textcolor{stringliteral}{'long\ long\ integer'},}
\DoxyCodeLine{00012\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'Q'}:\ \textcolor{stringliteral}{'unsigned\ long\ long\ integer'},}
\DoxyCodeLine{00013\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'f'}:\ \textcolor{stringliteral}{'single\ precision'},}
\DoxyCodeLine{00014\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'d'}:\ \textcolor{stringliteral}{'double\ precision'},}
\DoxyCodeLine{00015\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'g'}:\ \textcolor{stringliteral}{'long\ precision'},}
\DoxyCodeLine{00016\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'F'}:\ \textcolor{stringliteral}{'complex\ single\ precision'},}
\DoxyCodeLine{00017\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'D'}:\ \textcolor{stringliteral}{'complex\ double\ precision'},}
\DoxyCodeLine{00018\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'G'}:\ \textcolor{stringliteral}{'complex\ long\ double\ precision'},}
\DoxyCodeLine{00019\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'S'}:\ \textcolor{stringliteral}{'string'},}
\DoxyCodeLine{00020\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'U'}:\ \textcolor{stringliteral}{'unicode'},}
\DoxyCodeLine{00021\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'V'}:\ \textcolor{stringliteral}{'void'},}
\DoxyCodeLine{00022\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'O'}:\ \textcolor{stringliteral}{'object'}}
\DoxyCodeLine{00023\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1lib_1_1type__check_ab6d1950081c6dc92c2227cc774b621fd}\label{namespacenumpy_1_1lib_1_1type__check_ab6d1950081c6dc92c2227cc774b621fd} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!\_typecodes\_by\_elsize@{\_typecodes\_by\_elsize}}
\index{\_typecodes\_by\_elsize@{\_typecodes\_by\_elsize}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{\_typecodes\_by\_elsize}{\_typecodes\_by\_elsize}}
{\footnotesize\ttfamily str \+\_\+typecodes\+\_\+by\+\_\+elsize = \textquotesingle{}GDFgdf\+Qq\+Ll\+Ii\+Hh\+Bb?\textquotesingle{}\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1lib_1_1type__check_affcac574730c3f38760af090ab1f4aac}\label{namespacenumpy_1_1lib_1_1type__check_affcac574730c3f38760af090ab1f4aac} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!array\_precision@{array\_precision}}
\index{array\_precision@{array\_precision}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{array\_precision}{array\_precision}}
{\footnotesize\ttfamily dict array\+\_\+precision}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\_nx.half:\ 0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_nx.single:\ 1,}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_nx.double:\ 2,}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_nx.longdouble:\ 3,}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_nx.csingle:\ 1,}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_nx.cdouble:\ 2,}
\DoxyCodeLine{00007\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \_nx.clongdouble:\ 3\}}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1lib_1_1type__check_a50c2d77eb11a72beb25a41878ccecee9}\label{namespacenumpy_1_1lib_1_1type__check_a50c2d77eb11a72beb25a41878ccecee9} 
\index{numpy.lib.type\_check@{numpy.lib.type\_check}!array\_type@{array\_type}}
\index{array\_type@{array\_type}!numpy.lib.type\_check@{numpy.lib.type\_check}}
\doxysubsubsection{\texorpdfstring{array\_type}{array\_type}}
{\footnotesize\ttfamily list array\+\_\+type}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ [[\_nx.half,\ \_nx.single,\ \_nx.double,\ \_nx.longdouble],}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [\textcolor{keywordtype}{None},\ \_nx.csingle,\ \_nx.cdouble,\ \_nx.clongdouble]]}

\end{DoxyCode}
