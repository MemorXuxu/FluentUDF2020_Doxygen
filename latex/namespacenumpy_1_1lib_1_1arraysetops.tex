\doxysection{numpy.\+lib.\+arraysetops Namespace Reference}
\hypertarget{namespacenumpy_1_1lib_1_1arraysetops}{}\label{namespacenumpy_1_1lib_1_1arraysetops}\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a376a515a8a5187b0fe144064a79bd3e9}{ediff1d}} (ary, to\+\_\+end=None, to\+\_\+begin=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_aa99ff32505a884a89e5e9ed948f810c3}{\+\_\+unpack\+\_\+tuple}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a350d02d0f9d40999067311aaf8f38fb9}{unique}} (ar, return\+\_\+index=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, return\+\_\+inverse=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, return\+\_\+counts=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_ad71fd59740de9f6945bd7d68c0927ac0}{\+\_\+unique1d}} (ar, return\+\_\+index=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, return\+\_\+inverse=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, return\+\_\+counts=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a1877a7167fd3cf07f3269e2c1cfc7733}{intersect1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, return\+\_\+indices=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a734ad367bcbd8ee1434a7be8c473ac5c}{setxor1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a28c62c1361517ea4cee63aaa55c38f75}{in1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, invert=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a54ee8925095479d12e999198824ab115}{isin}} (\mbox{\hyperlink{structelement}{element}}, test\+\_\+elements, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, invert=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a76dfbada427ca7b6b64e414b9fd34ea3}{union1d}} (ar1, ar2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a29fa3c52ee76f4fe3c45d8fd79ef9a8f}{setdiff1d}} (ar1, ar2, assume\+\_\+unique=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Set operations for arrays based on sorting.

:Contains:
  unique,
  isin,
  ediff1d,
  intersect1d,
  setxor1d,
  in1d,
  union1d,
  setdiff1d

:Notes:

For floating point arrays, inaccurate results may appear due to usual round-off
and floating point comparison issues.

Speed could be gained in some operations by an implementation of
sort(), that can provide directly the permutation vectors, avoiding
thus calls to argsort().

To do: Optionally return indices analogously to unique for all functions.

:Author: Robert Cimrman\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_ad71fd59740de9f6945bd7d68c0927ac0}\label{namespacenumpy_1_1lib_1_1arraysetops_ad71fd59740de9f6945bd7d68c0927ac0} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!\_unique1d@{\_unique1d}}
\index{\_unique1d@{\_unique1d}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{\_unique1d()}{\_unique1d()}}
{\footnotesize\ttfamily \+\_\+unique1d (\begin{DoxyParamCaption}\item[{}]{ar,  }\item[{}]{return\+\_\+index = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{return\+\_\+inverse = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{return\+\_\+counts = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Find the unique elements of an array, ignoring shape.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_aa99ff32505a884a89e5e9ed948f810c3}\label{namespacenumpy_1_1lib_1_1arraysetops_aa99ff32505a884a89e5e9ed948f810c3} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!\_unpack\_tuple@{\_unpack\_tuple}}
\index{\_unpack\_tuple@{\_unpack\_tuple}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{\_unpack\_tuple()}{\_unpack\_tuple()}}
{\footnotesize\ttfamily \+\_\+unpack\+\_\+tuple (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb} Unpacks one-element tuples for use as return values \end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a376a515a8a5187b0fe144064a79bd3e9}\label{namespacenumpy_1_1lib_1_1arraysetops_a376a515a8a5187b0fe144064a79bd3e9} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!ediff1d@{ediff1d}}
\index{ediff1d@{ediff1d}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{ediff1d()}{ediff1d()}}
{\footnotesize\ttfamily ediff1d (\begin{DoxyParamCaption}\item[{}]{ary,  }\item[{}]{to\+\_\+end = {\ttfamily None},  }\item[{}]{to\+\_\+begin = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}The differences between consecutive elements of an array.

Parameters
----------
ary : array_like
    If necessary, will be flattened before the differences are taken.
to_end : array_like, optional
    Number(s) to append at the end of the returned differences.
to_begin : array_like, optional
    Number(s) to prepend at the beginning of the returned differences.

Returns
-------
ediff1d : ndarray
    The differences. Loosely, this is ``ary.flat[1:] - ary.flat[:-1]``.

See Also
--------
diff, gradient

Notes
-----
When applied to masked arrays, this function drops the mask information
if the `to_begin` and/or `to_end` parameters are used.

Examples
--------
>>> x = np.array([1, 2, 4, 7, 0])
>>> np.ediff1d(x)
array([ 1,  2,  3, -7])

>>> np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))
array([-99,   1,   2,   3,  -7,  88,  99])

The returned array is always 1D.

>>> y = [[1, 2, 4], [1, 6, 24]]
>>> np.ediff1d(y)
array([ 1,  2, -3,  5, 18])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a28c62c1361517ea4cee63aaa55c38f75}\label{namespacenumpy_1_1lib_1_1arraysetops_a28c62c1361517ea4cee63aaa55c38f75} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!in1d@{in1d}}
\index{in1d@{in1d}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{in1d()}{in1d()}}
{\footnotesize\ttfamily in1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{invert = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Test whether each element of a 1-D array is also present in a second array.

Returns a boolean array the same length as `ar1` that is True
where an element of `ar1` is in `ar2` and False otherwise.

We recommend using :func:`isin` instead of `in1d` for new code.

Parameters
----------
ar1 : (M,) array_like
    Input array.
ar2 : array_like
    The values against which to test each value of `ar1`.
assume_unique : bool, optional
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
invert : bool, optional
    If True, the values in the returned array are inverted (that is,
    False where an element of `ar1` is in `ar2` and True otherwise).
    Default is False. ``np.in1d(a, b, invert=True)`` is equivalent
    to (but is faster than) ``np.invert(in1d(a, b))``.

    .. versionadded:: 1.8.0

Returns
-------
in1d : (M,) ndarray, bool
    The values `ar1[in1d]` are in `ar2`.

See Also
--------
isin                  : Version of this function that preserves the
                        shape of ar1.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----
`in1d` can be considered as an element-wise function version of the
python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly
equivalent to ``np.array([item in b for item in a])``.
However, this idea fails if `ar2` is a set, or similar (non-sequence)
container:  As ``ar2`` is converted to an array, in those cases
``asarray(ar2)`` is an object array rather than the expected array of
contained values.

.. versionadded:: 1.4.0

Examples
--------
>>> test = np.array([0, 1, 2, 5, 0])
>>> states = [0, 2]
>>> mask = np.in1d(test, states)
>>> mask
array([ True, False,  True, False,  True])
>>> test[mask]
array([0, 2, 0])
>>> mask = np.in1d(test, states, invert=True)
>>> mask
array([False,  True, False,  True, False])
>>> test[mask]
array([1, 5])
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a1877a7167fd3cf07f3269e2c1cfc7733}\label{namespacenumpy_1_1lib_1_1arraysetops_a1877a7167fd3cf07f3269e2c1cfc7733} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!intersect1d@{intersect1d}}
\index{intersect1d@{intersect1d}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{intersect1d()}{intersect1d()}}
{\footnotesize\ttfamily intersect1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{return\+\_\+indices = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the intersection of two arrays.

Return the sorted, unique values that are in both of the input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays. Will be flattened if not already 1D.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
return_indices : bool
    If True, the indices which correspond to the intersection of the two
    arrays are returned. The first instance of a value is used if there are
    multiple. Default is False.

    .. versionadded:: 1.15.0

Returns
-------
intersect1d : ndarray
    Sorted 1D array of common and unique elements.
comm1 : ndarray
    The indices of the first occurrences of the common values in `ar1`.
    Only provided if `return_indices` is True.
comm2 : ndarray
    The indices of the first occurrences of the common values in `ar2`.
    Only provided if `return_indices` is True.


See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
>>> np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])
array([1, 3])

To intersect more than two arrays, use functools.reduce:

>>> from functools import reduce
>>> reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([3])

To return the indices of the values common to the input arrays
along with the intersected values:
>>> x = np.array([1, 1, 2, 3, 4])
>>> y = np.array([2, 1, 4, 6])
>>> xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)
>>> x_ind, y_ind
(array([0, 2, 4]), array([1, 0, 2]))
>>> xy, x[x_ind], y[y_ind]
(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a54ee8925095479d12e999198824ab115}\label{namespacenumpy_1_1lib_1_1arraysetops_a54ee8925095479d12e999198824ab115} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!isin@{isin}}
\index{isin@{isin}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{isin()}{isin()}}
{\footnotesize\ttfamily isin (\begin{DoxyParamCaption}\item[{}]{element,  }\item[{}]{test\+\_\+elements,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{invert = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculates `element in test_elements`, broadcasting over `element` only.
Returns a boolean array of the same shape as `element` that is True
where an element of `element` is in `test_elements` and False otherwise.

Parameters
----------
element : array_like
    Input array.
test_elements : array_like
    The values against which to test each value of `element`.
    This argument is flattened if it is an array or array_like.
    See notes for behavior with non-array-like parameters.
assume_unique : bool, optional
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.
invert : bool, optional
    If True, the values in the returned array are inverted, as if
    calculating `element not in test_elements`. Default is False.
    ``np.isin(a, b, invert=True)`` is equivalent to (but faster
    than) ``np.invert(np.isin(a, b))``.

Returns
-------
isin : ndarray, bool
    Has the same shape as `element`. The values `element[isin]`
    are in `test_elements`.

See Also
--------
in1d                  : Flattened version of this function.
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----

`isin` is an element-wise function version of the python keyword `in`.
``isin(a, b)`` is roughly equivalent to
``np.array([item in b for item in a])`` if `a` and `b` are 1-D sequences.

`element` and `test_elements` are converted to arrays if they are not
already. If `test_elements` is a set (or other non-sequence collection)
it will be converted to an object array with one element, rather than an
array of the values contained in `test_elements`. This is a consequence
of the `array` constructor's way of handling non-sequence collections.
Converting the set to a list usually gives the desired behavior.

.. versionadded:: 1.13.0

Examples
--------
>>> element = 2*np.arange(4).reshape((2, 2))
>>> element
array([[0, 2],
       [4, 6]])
>>> test_elements = [1, 2, 4, 8]
>>> mask = np.isin(element, test_elements)
>>> mask
array([[ False,  True],
       [ True,  False]])
>>> element[mask]
array([2, 4])
>>> mask = np.isin(element, test_elements, invert=True)
>>> mask
array([[ True, False],
       [ False, True]])
>>> element[mask]
array([0, 6])

Because of how `array` handles sets, the following does not
work as expected:

>>> test_set = {1, 2, 4, 8}
>>> np.isin(element, test_set)
array([[ False, False],
       [ False, False]])

Casting the set to a list gives the expected result:

>>> np.isin(element, list(test_set))
array([[ False,  True],
       [ True,  False]])
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a29fa3c52ee76f4fe3c45d8fd79ef9a8f}\label{namespacenumpy_1_1lib_1_1arraysetops_a29fa3c52ee76f4fe3c45d8fd79ef9a8f} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!setdiff1d@{setdiff1d}}
\index{setdiff1d@{setdiff1d}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{setdiff1d()}{setdiff1d()}}
{\footnotesize\ttfamily setdiff1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the set difference of two arrays.

Return the sorted, unique values in `ar1` that are not in `ar2`.

Parameters
----------
ar1 : array_like
    Input array.
ar2 : array_like
    Input comparison array.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.

Returns
-------
setdiff1d : ndarray
    Sorted 1D array of values in `ar1` that are not in `ar2`.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
>>> a = np.array([1, 2, 3, 2, 4, 1])
>>> b = np.array([3, 4, 5, 6])
>>> np.setdiff1d(a, b)
array([1, 2])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a734ad367bcbd8ee1434a7be8c473ac5c}\label{namespacenumpy_1_1lib_1_1arraysetops_a734ad367bcbd8ee1434a7be8c473ac5c} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!setxor1d@{setxor1d}}
\index{setxor1d@{setxor1d}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{setxor1d()}{setxor1d()}}
{\footnotesize\ttfamily setxor1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2,  }\item[{}]{assume\+\_\+unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the set exclusive-or of two arrays.

Return the sorted, unique values that are in only one (not both) of the
input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays.
assume_unique : bool
    If True, the input arrays are both assumed to be unique, which
    can speed up the calculation.  Default is False.

Returns
-------
setxor1d : ndarray
    Sorted 1D array of unique values that are in only one of the input
    arrays.

Examples
--------
>>> a = np.array([1, 2, 3, 2, 4])
>>> b = np.array([2, 3, 5, 7, 5])
>>> np.setxor1d(a,b)
array([1, 4, 5, 7])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a76dfbada427ca7b6b64e414b9fd34ea3}\label{namespacenumpy_1_1lib_1_1arraysetops_a76dfbada427ca7b6b64e414b9fd34ea3} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!union1d@{union1d}}
\index{union1d@{union1d}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{union1d()}{union1d()}}
{\footnotesize\ttfamily union1d (\begin{DoxyParamCaption}\item[{}]{ar1,  }\item[{}]{ar2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the union of two arrays.

Return the unique, sorted array of values that are in either of the two
input arrays.

Parameters
----------
ar1, ar2 : array_like
    Input arrays. They are flattened if they are not already 1D.

Returns
-------
union1d : ndarray
    Unique, sorted union of the input arrays.

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Examples
--------
>>> np.union1d([-1, 0, 1], [-2, 0, 2])
array([-2, -1,  0,  1,  2])

To find the union of more than two arrays, use functools.reduce:

>>> from functools import reduce
>>> reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))
array([1, 2, 3, 4, 6])
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1arraysetops_a350d02d0f9d40999067311aaf8f38fb9}\label{namespacenumpy_1_1lib_1_1arraysetops_a350d02d0f9d40999067311aaf8f38fb9} 
\index{numpy.lib.arraysetops@{numpy.lib.arraysetops}!unique@{unique}}
\index{unique@{unique}!numpy.lib.arraysetops@{numpy.lib.arraysetops}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily unique (\begin{DoxyParamCaption}\item[{}]{ar,  }\item[{}]{return\+\_\+index = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{return\+\_\+inverse = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{return\+\_\+counts = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the unique elements of an array.

Returns the sorted unique elements of an array. There are three optional
outputs in addition to the unique elements:

* the indices of the input array that give the unique values
* the indices of the unique array that reconstruct the input array
* the number of times each unique value comes up in the input array

Parameters
----------
ar : array_like
    Input array. Unless `axis` is specified, this will be flattened if it
    is not already 1-D.
return_index : bool, optional
    If True, also return the indices of `ar` (along the specified axis,
    if provided, or in the flattened array) that result in the unique array.
return_inverse : bool, optional
    If True, also return the indices of the unique array (for the specified
    axis, if provided) that can be used to reconstruct `ar`.
return_counts : bool, optional
    If True, also return the number of times each unique item appears
    in `ar`.

    .. versionadded:: 1.9.0

axis : int or None, optional
    The axis to operate on. If None, `ar` will be flattened. If an integer,
    the subarrays indexed by the given axis will be flattened and treated
    as the elements of a 1-D array with the dimension of the given axis,
    see the notes for more details.  Object arrays or structured arrays
    that contain objects are not supported if the `axis` kwarg is used. The
    default is None.

    .. versionadded:: 1.13.0

Returns
-------
unique : ndarray
    The sorted unique values.
unique_indices : ndarray, optional
    The indices of the first occurrences of the unique values in the
    original array. Only provided if `return_index` is True.
unique_inverse : ndarray, optional
    The indices to reconstruct the original array from the
    unique array. Only provided if `return_inverse` is True.
unique_counts : ndarray, optional
    The number of times each of the unique values comes up in the
    original array. Only provided if `return_counts` is True.

    .. versionadded:: 1.9.0

See Also
--------
numpy.lib.arraysetops : Module with a number of other functions for
                        performing set operations on arrays.

Notes
-----
When an axis is specified the subarrays indexed by the axis are sorted.
This is done by making the specified axis the first dimension of the array
and then flattening the subarrays in C order. The flattened subarrays are
then viewed as a structured type with each element given a label, with the
effect that we end up with a 1-D array of structured types that can be
treated in the same way as any other 1-D array. The result is that the
flattened subarrays are sorted in lexicographic order starting with the
first element.

Examples
--------
>>> np.unique([1, 1, 2, 2, 3, 3])
array([1, 2, 3])
>>> a = np.array([[1, 1], [2, 3]])
>>> np.unique(a)
array([1, 2, 3])

Return the unique rows of a 2D array

>>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
>>> np.unique(a, axis=0)
array([[1, 0, 0], [2, 3, 4]])

Return the indices of the original array that give the unique values:

>>> a = np.array(['a', 'b', 'b', 'c', 'a'])
>>> u, indices = np.unique(a, return_index=True)
>>> u
array(['a', 'b', 'c'],
       dtype='|S1')
>>> indices
array([0, 1, 3])
>>> a[indices]
array(['a', 'b', 'c'],
       dtype='|S1')

Reconstruct the input array from the unique values:

>>> a = np.array([1, 2, 6, 4, 2, 3, 2])
>>> u, indices = np.unique(a, return_inverse=True)
>>> u
array([1, 2, 3, 4, 6])
>>> indices
array([0, 1, 4, 3, 1, 2, 1])
>>> u[indices]
array([1, 2, 6, 4, 2, 3, 2])\end{DoxyVerb}
 