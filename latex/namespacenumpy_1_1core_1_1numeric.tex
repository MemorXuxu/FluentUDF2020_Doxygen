\doxysection{numpy.\+core.\+numeric Namespace Reference}
\hypertarget{namespacenumpy_1_1core_1_1numeric}{}\label{namespacenumpy_1_1core_1_1numeric}\index{numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1numeric_1_1__unspecified}{\+\_\+unspecified}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1numeric_1_1_complex_warning}{Complex\+Warning}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1numeric_1_1errstate}{errstate}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ad77cd440041ccedba33e31e3ea4a8bc5}{loads}} (\texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aeed5561ec35eff09e9ce7b1c757441b4}{zeros\+\_\+like}} (a, dtype=None, order=\textquotesingle{}K\textquotesingle{}, subok=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a5b5954221cf8ffcbfcafbd540faf5e53}{ones}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_a149f0ed3f02491db0c249840e2aff84f}{shape}}, dtype=None, order=\textquotesingle{}C\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ab7769ce7127b4b31b480ddd3323dfd67}{ones\+\_\+like}} (a, dtype=None, order=\textquotesingle{}K\textquotesingle{}, subok=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aedba2594d8fc1c40b727456402f98c6f}{full}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_a149f0ed3f02491db0c249840e2aff84f}{shape}}, fill\+\_\+value, dtype=None, order=\textquotesingle{}C\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ac10d8bc6db85ff700ba55cf4a02f5de2}{full\+\_\+like}} (a, fill\+\_\+value, dtype=None, order=\textquotesingle{}K\textquotesingle{}, subok=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a8b8d87f38a2df98e0bf2036d0a4d1b34}{count\+\_\+nonzero}} (a, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a7efa3dc38e0735a06b860f623bde3ff5}{asarray}} (a, dtype=None, order=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a7aff97f14c1f87872a8d98fa732e03ab}{asanyarray}} (a, dtype=None, order=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_afe397eefa5f915723bdaefbec5e6f87b}{ascontiguousarray}} (a, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aab60fa0d79a0c4a974c9c2e369d3e4ae}{asfortranarray}} (a, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a9f2eb9ac9bd6e9bfd31f153debbb173f}{require}} (a, dtype=None, requirements=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ad7e5b32aed91afd5299d92a3a31e2a14}{isfortran}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ae79a12a2cbe41fb1c95cfd93d1fab9d2}{argwhere}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a540380bbe214868db334c0f6c672134b}{flatnonzero}} (a)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a9f7d2741be2958024e71949d73f5f050}{\+\_\+mode\+\_\+from\+\_\+name}} (mode)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ab8454851688fe37d552e1ae7638f46c4}{correlate}} (a, v, mode=\textquotesingle{}valid\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_afa18ce9d012cd3f885a8eef4012affee}{convolve}} (a, v, mode=\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aedba2594d8fc1c40b727456402f98c6f}{full}}\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a670d32b25afaf9b35fd35891173e8b75}{outer}} (a, b, out=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aa8ae72904798e11b173e975752fd3b80}{tensordot}} (a, b, axes=2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ace9cdd8dd48db11f666a6ca219df5eef}{roll}} (a, shift, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ac7a999206352aa2d43ad94aacafaec84}{rollaxis}} (a, axis, start=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a633e6e3bdb3c4381173586ff31b8b8a1}{normalize\+\_\+axis\+\_\+tuple}} (axis, \mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_a3c6c503ff6f2eccb515295f59180ff72}{ndim}}, argname=None, allow\+\_\+duplicate=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aeb4e8a5ca55c3cb146eb3f6be26ecb14}{moveaxis}} (a, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1utils_a5e32f58f7b085a7b1b484dc5c165fad9}{source}}, destination)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_abee9bdf0d0e1d8c4e4becc6080588bef}{\+\_\+move\+\_\+axis\+\_\+to\+\_\+0}} (a, axis)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ada05b1dd7ae630c33b4636b661b6b7bf}{cross}} (a, b, axisa=-\/1, axisb=-\/1, axisc=-\/1, axis=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a15cc0d5f58abbccc68308d3e9950c281}{indices}} (dimensions, dtype=int)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aa4569b71e48d54af6ecb554fbaa2ee33}{fromfunction}} (\mbox{\hyperlink{num_8c_a34c1b818c2b60ca9884153ee8891e7b0}{function}}, \mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_a149f0ed3f02491db0c249840e2aff84f}{shape}}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ab97e06ecccb727b560bfc0279b69755f}{isscalar}} (num)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ac8012de91b4c4a50600bac38265bdc2c}{binary\+\_\+repr}} (num, width=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a52b23db4ce6fa90f6418ce2fc13d304d}{base\+\_\+repr}} (number, base=2, padding=0)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a82d9979314ac7ed2dc9071139101c8f3}{load}} (file)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ab597e17391b4f3a033bb068fd602a8a8}{\+\_\+maketup}} (descr, val)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_addf06f9095931663abcdcb3087b50a03}{identity}} (n, dtype=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aa1de8b64af45f36f652f9dfaa45429a9}{allclose}} (a, b, rtol=1.e-\/5, atol=1.e-\/8, equal\+\_\+nan=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a78d9c60ae7804c7ad02f362537a2c221}{isclose}} (a, b, rtol=1.e-\/5, atol=1.e-\/8, equal\+\_\+nan=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a92cd63051598c7eb85958c794d287186}{array\+\_\+equal}} (a1, a2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a1edaae6ad4c65e3e3588ca7a76365e87}{array\+\_\+equiv}} (a1, a2)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a89f05e9f89cd563821bae91ae8e56d1a}{seterr}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_a07fd125ebb24e774c426264785469599}{all}}=None, divide=None, over=None, under=None, invalid=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a5e4bfcb9fa745a8a0f8bcc91b91ea7c4}{geterr}} ()
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a0f9f3a5cd1bd622ccebc34cef0a44886}{setbufsize}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1fromnumeric_a3b9f1ff427c60c7fd31a961e05581e9f}{size}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a7a1946c02c639c372df7726cbf881b4c}{getbufsize}} ()
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a1f5feeb8e8dc11011309cefdd855a421}{seterrcall}} (func)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a79ed745c1a77d11847c2e8f7319c1efc}{geterrcall}} ()
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a933c9a57fadf69667096aaf5bde4b1a0}{\+\_\+setdef}} ()
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_ac6403845e3139ed279e19a818874ad7c}{extend\+\_\+all}} (module)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a59e478f8d9c3e54bb7f3e0c4d92ca6f2}{bitwise\+\_\+not}} = invert
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aaecf86ba873f20737a9f7fe5eb11dcdd}{ufunc}} = type(sin)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a99cfcf7602411359d94844953c47380f}{newaxis}} = None
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a4e790eefd40bafcbf3c482435de1b20a}{basestring}} = str
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a6f03d55c27d0e45f584ad1cafb2e8029}{\+\_\+mode\+\_\+from\+\_\+name\+\_\+dict}}
\item 
tuple \mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a244cdc355af046c5ff10118116412b10}{little\+\_\+endian}} = (sys.\+byteorder == \textquotesingle{}little\textquotesingle{})
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a3d9b7116bfe8942f848ca36543854ef9}{\+\_\+errdict}}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aada950c2ab91b77b46937a6b23ff444e}{\+\_\+errdict\+\_\+rev}} = \{\}
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a2af58d7a2abd912fd174aad825cc7c5c}{\+\_\+\+Unspecified}} = \mbox{\hyperlink{classnumpy_1_1core_1_1numeric_1_1__unspecified}{\+\_\+unspecified}}()
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a1c8a517864e31bca74fc3c730d6b47e8}{Inf}} = PINF
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a32077e33a08c1e9ba02bbdabfe645c24}{nan}} = NAN
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aec6fbaee51d57a0e44dcc3a1481a5fc3}{False\+\_\+}} = bool\+\_\+(\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_a22996eb6fafcf22551460f22d235d649}{True\+\_\+}} = bool\+\_\+(\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1core_1_1numeric_ab597e17391b4f3a033bb068fd602a8a8}\label{namespacenumpy_1_1core_1_1numeric_ab597e17391b4f3a033bb068fd602a8a8} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_maketup@{\_maketup}}
\index{\_maketup@{\_maketup}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_maketup()}{\_maketup()}}
{\footnotesize\ttfamily \+\_\+maketup (\begin{DoxyParamCaption}\item[{}]{descr,  }\item[{}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a9f7d2741be2958024e71949d73f5f050}\label{namespacenumpy_1_1core_1_1numeric_a9f7d2741be2958024e71949d73f5f050} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_mode\_from\_name@{\_mode\_from\_name}}
\index{\_mode\_from\_name@{\_mode\_from\_name}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_mode\_from\_name()}{\_mode\_from\_name()}}
{\footnotesize\ttfamily \+\_\+mode\+\_\+from\+\_\+name (\begin{DoxyParamCaption}\item[{}]{mode }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_abee9bdf0d0e1d8c4e4becc6080588bef}\label{namespacenumpy_1_1core_1_1numeric_abee9bdf0d0e1d8c4e4becc6080588bef} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_move\_axis\_to\_0@{\_move\_axis\_to\_0}}
\index{\_move\_axis\_to\_0@{\_move\_axis\_to\_0}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_move\_axis\_to\_0()}{\_move\_axis\_to\_0()}}
{\footnotesize\ttfamily \+\_\+move\+\_\+axis\+\_\+to\+\_\+0 (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a933c9a57fadf69667096aaf5bde4b1a0}\label{namespacenumpy_1_1core_1_1numeric_a933c9a57fadf69667096aaf5bde4b1a0} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_setdef@{\_setdef}}
\index{\_setdef@{\_setdef}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_setdef()}{\_setdef()}}
{\footnotesize\ttfamily \+\_\+setdef (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_aa1de8b64af45f36f652f9dfaa45429a9}\label{namespacenumpy_1_1core_1_1numeric_aa1de8b64af45f36f652f9dfaa45429a9} 
\index{numpy.core.numeric@{numpy.core.numeric}!allclose@{allclose}}
\index{allclose@{allclose}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{allclose()}{allclose()}}
{\footnotesize\ttfamily allclose (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{rtol = {\ttfamily 1.e-\/5},  }\item[{}]{atol = {\ttfamily 1.e-\/8},  }\item[{}]{equal\+\_\+nan = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if two arrays are element-wise equal within a tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

If either array contains one or more NaNs, False is returned.
Infs are treated as equal if they are in the same place and of the same
sign in both arrays.

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

    .. versionadded:: 1.10.0

Returns
-------
allclose : bool
    Returns True if the two arrays are equal within the given
    tolerance; False otherwise.

See Also
--------
isclose, all, any, equal

Notes
-----
If the following equation is element-wise True, then allclose returns
True.

 absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

The above equation is not symmetric in `a` and `b`, so that
``allclose(a, b)`` might be different from ``allclose(b, a)`` in
some rare cases.

The comparison of `a` and `b` uses standard broadcasting, which
means that `a` and `b` need not have the same shape in order for
``allclose(a, b)`` to evaluate to True.  The same is true for
`equal` but not `array_equal`.

Examples
--------
>>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
False
>>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
True
>>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
False
>>> np.allclose([1.0, np.nan], [1.0, np.nan])
False
>>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ae79a12a2cbe41fb1c95cfd93d1fab9d2}\label{namespacenumpy_1_1core_1_1numeric_ae79a12a2cbe41fb1c95cfd93d1fab9d2} 
\index{numpy.core.numeric@{numpy.core.numeric}!argwhere@{argwhere}}
\index{argwhere@{argwhere}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{argwhere()}{argwhere()}}
{\footnotesize\ttfamily argwhere (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the indices of array elements that are non-zero, grouped by element.

Parameters
----------
a : array_like
    Input data.

Returns
-------
index_array : ndarray
    Indices of elements that are non-zero. Indices are grouped by element.

See Also
--------
where, nonzero

Notes
-----
``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.

The output of ``argwhere`` is not suitable for indexing arrays.
For this purpose use ``nonzero(a)`` instead.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.argwhere(x>1)
array([[0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a92cd63051598c7eb85958c794d287186}\label{namespacenumpy_1_1core_1_1numeric_a92cd63051598c7eb85958c794d287186} 
\index{numpy.core.numeric@{numpy.core.numeric}!array\_equal@{array\_equal}}
\index{array\_equal@{array\_equal}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{array\_equal()}{array\_equal()}}
{\footnotesize\ttfamily array\+\_\+equal (\begin{DoxyParamCaption}\item[{}]{a1,  }\item[{}]{a2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}True if two arrays have the same shape and elements, False otherwise.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
b : bool
    Returns True if the arrays are equal.

See Also
--------
allclose: Returns True if two arrays are element-wise equal within a
          tolerance.
array_equiv: Returns True if input arrays are shape consistent and all
             elements equal.

Examples
--------
>>> np.array_equal([1, 2], [1, 2])
True
>>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
True
>>> np.array_equal([1, 2], [1, 2, 3])
False
>>> np.array_equal([1, 2], [1, 4])
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a1edaae6ad4c65e3e3588ca7a76365e87}\label{namespacenumpy_1_1core_1_1numeric_a1edaae6ad4c65e3e3588ca7a76365e87} 
\index{numpy.core.numeric@{numpy.core.numeric}!array\_equiv@{array\_equiv}}
\index{array\_equiv@{array\_equiv}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{array\_equiv()}{array\_equiv()}}
{\footnotesize\ttfamily array\+\_\+equiv (\begin{DoxyParamCaption}\item[{}]{a1,  }\item[{}]{a2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if input arrays are shape consistent and all elements equal.

Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
out : bool
    True if equivalent, False otherwise.

Examples
--------
>>> np.array_equiv([1, 2], [1, 2])
True
>>> np.array_equiv([1, 2], [1, 3])
False

Showing the shape equivalence:

>>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
True
>>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
False

>>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a7aff97f14c1f87872a8d98fa732e03ab}\label{namespacenumpy_1_1core_1_1numeric_a7aff97f14c1f87872a8d98fa732e03ab} 
\index{numpy.core.numeric@{numpy.core.numeric}!asanyarray@{asanyarray}}
\index{asanyarray@{asanyarray}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{asanyarray()}{asanyarray()}}
{\footnotesize\ttfamily asanyarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert the input to an ndarray, but pass ndarray subclasses through.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes scalars, lists, lists of tuples, tuples, tuples of tuples,
    tuples of lists, and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or column-major
    (Fortran-style) memory representation.  Defaults to 'C'.

Returns
-------
out : ndarray or an ndarray subclass
    Array interpretation of `a`.  If `a` is an ndarray or a subclass
    of ndarray, it is returned as-is and no copy is performed.

See Also
--------
asarray : Similar function which always returns ndarrays.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and
                    Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asanyarray(a)
array([1, 2])

Instances of `ndarray` subclasses are passed through as-is:

>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asanyarray(a) is a
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a7efa3dc38e0735a06b860f623bde3ff5}\label{namespacenumpy_1_1core_1_1numeric_a7efa3dc38e0735a06b860f623bde3ff5} 
\index{numpy.core.numeric@{numpy.core.numeric}!asarray@{asarray}}
\index{asarray@{asarray}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{asarray()}{asarray()}}
{\footnotesize\ttfamily asarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert the input to an array.

Parameters
----------
a : array_like
    Input data, in any form that can be converted to an array.  This
    includes lists, lists of tuples, tuples, tuples of tuples, tuples
    of lists and ndarrays.
dtype : data-type, optional
    By default, the data-type is inferred from the input data.
order : {'C', 'F'}, optional
    Whether to use row-major (C-style) or
    column-major (Fortran-style) memory representation.
    Defaults to 'C'.

Returns
-------
out : ndarray
    Array interpretation of `a`.  No copy is performed if the input
    is already an ndarray with matching dtype and order.  If `a` is a
    subclass of ndarray, a base class ndarray is returned.

See Also
--------
asanyarray : Similar function which passes through subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfarray : Convert input to a floating point ndarray.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
asarray_chkfinite : Similar function which checks input for NaNs and Infs.
fromiter : Create an array from an iterator.
fromfunction : Construct an array by executing a function on grid
               positions.

Examples
--------
Convert a list into an array:

>>> a = [1, 2]
>>> np.asarray(a)
array([1, 2])

Existing arrays are not copied:

>>> a = np.array([1, 2])
>>> np.asarray(a) is a
True

If `dtype` is set, array is copied only if dtype does not match:

>>> a = np.array([1, 2], dtype=np.float32)
>>> np.asarray(a, dtype=np.float32) is a
True
>>> np.asarray(a, dtype=np.float64) is a
False

Contrary to `asanyarray`, ndarray subclasses are not passed through:

>>> issubclass(np.recarray, np.ndarray)
True
>>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
>>> np.asarray(a) is a
False
>>> np.asanyarray(a) is a
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_afe397eefa5f915723bdaefbec5e6f87b}\label{namespacenumpy_1_1core_1_1numeric_afe397eefa5f915723bdaefbec5e6f87b} 
\index{numpy.core.numeric@{numpy.core.numeric}!ascontiguousarray@{ascontiguousarray}}
\index{ascontiguousarray@{ascontiguousarray}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{ascontiguousarray()}{ascontiguousarray()}}
{\footnotesize\ttfamily ascontiguousarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a contiguous array in memory (C order).

Parameters
----------
a : array_like
    Input array.
dtype : str or dtype object, optional
    Data-type of returned array.

Returns
-------
out : ndarray
    Contiguous array of same shape and content as `a`, with type `dtype`
    if specified.

See Also
--------
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> np.ascontiguousarray(x, dtype=np.float32)
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.]], dtype=float32)
>>> x.flags['C_CONTIGUOUS']
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_aab60fa0d79a0c4a974c9c2e369d3e4ae}\label{namespacenumpy_1_1core_1_1numeric_aab60fa0d79a0c4a974c9c2e369d3e4ae} 
\index{numpy.core.numeric@{numpy.core.numeric}!asfortranarray@{asfortranarray}}
\index{asfortranarray@{asfortranarray}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{asfortranarray()}{asfortranarray()}}
{\footnotesize\ttfamily asfortranarray (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array laid out in Fortran order in memory.

Parameters
----------
a : array_like
    Input array.
dtype : str or dtype object, optional
    By default, the data-type is inferred from the input data.

Returns
-------
out : ndarray
    The input `a` in Fortran, or column-major, order.

See Also
--------
ascontiguousarray : Convert input to a contiguous (C order) array.
asanyarray : Convert input to an ndarray with either row or
    column-major memory order.
require : Return an ndarray that satisfies requirements.
ndarray.flags : Information about the memory layout of the array.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> y = np.asfortranarray(x)
>>> x.flags['F_CONTIGUOUS']
False
>>> y.flags['F_CONTIGUOUS']
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a52b23db4ce6fa90f6418ce2fc13d304d}\label{namespacenumpy_1_1core_1_1numeric_a52b23db4ce6fa90f6418ce2fc13d304d} 
\index{numpy.core.numeric@{numpy.core.numeric}!base\_repr@{base\_repr}}
\index{base\_repr@{base\_repr}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{base\_repr()}{base\_repr()}}
{\footnotesize\ttfamily base\+\_\+repr (\begin{DoxyParamCaption}\item[{}]{number,  }\item[{}]{base = {\ttfamily 2},  }\item[{}]{padding = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a string representation of a number in the given base system.

Parameters
----------
number : int
    The value to convert. Positive and negative values are handled.
base : int, optional
    Convert `number` to the `base` number system. The valid range is 2-36,
    the default value is 2.
padding : int, optional
    Number of zeros padded on the left. Default is 0 (no padding).

Returns
-------
out : str
    String representation of `number` in `base` system.

See Also
--------
binary_repr : Faster version of `base_repr` for base 2.

Examples
--------
>>> np.base_repr(5)
'101'
>>> np.base_repr(6, 5)
'11'
>>> np.base_repr(7, base=5, padding=3)
'00012'

>>> np.base_repr(10, base=16)
'A'
>>> np.base_repr(32, base=16)
'20'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ac8012de91b4c4a50600bac38265bdc2c}\label{namespacenumpy_1_1core_1_1numeric_ac8012de91b4c4a50600bac38265bdc2c} 
\index{numpy.core.numeric@{numpy.core.numeric}!binary\_repr@{binary\_repr}}
\index{binary\_repr@{binary\_repr}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{binary\_repr()}{binary\_repr()}}
{\footnotesize\ttfamily binary\+\_\+repr (\begin{DoxyParamCaption}\item[{}]{num,  }\item[{}]{width = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the binary representation of the input number as a string.

For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two's complement of the number is
returned, with respect to that width.

In a two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit two's-complement
system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
num : int
    Only an integer decimal number can be used.
width : int, optional
    The length of the returned string if `num` is positive, or the length
    of the two's complement if `num` is negative, provided that `width` is
    at least a sufficient number of bits for `num` to be represented in the
    designated form.

    If the `width` value is insufficient, it will be ignored, and `num` will
    be returned in binary (`num` > 0) or two's complement (`num` < 0) form
    with its width equal to the minimum number of bits needed to represent
    the number in the designated form. This behavior is deprecated and will
    later raise an error.

    .. deprecated:: 1.12.0

Returns
-------
bin : str
    Binary representation of `num` or two's complement of `num`.

See Also
--------
base_repr: Return a string representation of a number in the given base
           system.
bin: Python's built-in binary representation generator of an integer.

Notes
-----
`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
faster.

References
----------
.. [1] Wikipedia, "Two's complement",
    http://en.wikipedia.org/wiki/Two's_complement

Examples
--------
>>> np.binary_repr(3)
'11'
>>> np.binary_repr(-3)
'-11'
>>> np.binary_repr(3, width=4)
'0011'

The two's complement is returned when the input number is negative and
width is specified:

>>> np.binary_repr(-3, width=3)
'101'
>>> np.binary_repr(-3, width=5)
'11101'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_afa18ce9d012cd3f885a8eef4012affee}\label{namespacenumpy_1_1core_1_1numeric_afa18ce9d012cd3f885a8eef4012affee} 
\index{numpy.core.numeric@{numpy.core.numeric}!convolve@{convolve}}
\index{convolve@{convolve}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{convolve()}{convolve()}}
{\footnotesize\ttfamily convolve (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily \textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1numeric_aedba2594d8fc1c40b727456402f98c6f}{full}}\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the discrete, linear convolution of two one-dimensional sequences.

The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal [1]_.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.

If `v` is longer than `a`, the arrays are swapped before computation.

Parameters
----------
a : (N,) array_like
    First one-dimensional input array.
v : (M,) array_like
    Second one-dimensional input array.
mode : {'full', 'valid', 'same'}, optional
    'full':
      By default, mode is 'full'.  This returns the convolution
      at each point of overlap, with an output shape of (N+M-1,). At
      the end-points of the convolution, the signals do not overlap
      completely, and boundary effects may be seen.

    'same':
      Mode 'same' returns output of length ``max(M, N)``.  Boundary
      effects are still visible.

    'valid':
      Mode 'valid' returns output of length
      ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
      for points where the signals overlap completely.  Values outside
      the signal boundary have no effect.

Returns
-------
out : ndarray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
                           Transform.
scipy.linalg.toeplitz : Used to construct the convolution operator.
polymul : Polynomial multiplication. Same output as convolve, but also
          accepts poly1d objects as input.

Notes
-----
The discrete convolution operation is defined as

.. math:: (a * v)[n] = \\sum_{m = -\\infty}^{\\infty} a[m] v[n - m]

It can be shown that a convolution :math:`x(t) * y(t)` in time/space
is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function `scipy.signal.fftconvolve` exploits the
FFT to calculate the convolution of large data-sets.

References
----------
.. [1] Wikipedia, "Convolution", http://en.wikipedia.org/wiki/Convolution.

Examples
--------
Note how the convolution operator flips the second array
before "sliding" the two across one another:

>>> np.convolve([1, 2, 3], [0, 1, 0.5])
array([ 0. ,  1. ,  2.5,  4. ,  1.5])

Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:

>>> np.convolve([1,2,3],[0,1,0.5], 'same')
array([ 1. ,  2.5,  4. ])

The two arrays are of the same length, so there
is only one position where they completely overlap:

>>> np.convolve([1,2,3],[0,1,0.5], 'valid')
array([ 2.5])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ab8454851688fe37d552e1ae7638f46c4}\label{namespacenumpy_1_1core_1_1numeric_ab8454851688fe37d552e1ae7638f46c4} 
\index{numpy.core.numeric@{numpy.core.numeric}!correlate@{correlate}}
\index{correlate@{correlate}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{correlate()}{correlate()}}
{\footnotesize\ttfamily correlate (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{v,  }\item[{}]{mode = {\ttfamily \textquotesingle{}valid\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Cross-correlation of two 1-dimensional sequences.

This function computes the correlation as generally defined in signal
processing texts::

    c_{av}[k] = sum_n a[n+k] * conj(v[n])

with a and v sequences being zero-padded where necessary and conj being
the conjugate.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `convolve` docstring.  Note that the default
    is 'valid', unlike `convolve`, which uses 'full'.
old_behavior : bool
    `old_behavior` was removed in NumPy 1.10. If you need the old
    behavior, use `multiarray.correlate`.

Returns
-------
out : ndarray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
convolve : Discrete, linear convolution of two one-dimensional sequences.
multiarray.correlate : Old, no conjugate, version of correlate.

Notes
-----
The definition of correlation above is not unique and sometimes correlation
may be defined differently. Another common definition is::

    c'_{av}[k] = sum_n a[n] conj(v[n+k])

which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.

Examples
--------
>>> np.correlate([1, 2, 3], [0, 1, 0.5])
array([ 3.5])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], "same")
array([ 2. ,  3.5,  3. ])
>>> np.correlate([1, 2, 3], [0, 1, 0.5], "full")
array([ 0.5,  2. ,  3.5,  3. ,  0. ])

Using complex sequences:

>>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])

Note that you get the time reversed, complex conjugated result
when the two input sequences change places, i.e.,
``c_{va}[k] = c^{*}_{av}[-k]``:

>>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a8b8d87f38a2df98e0bf2036d0a4d1b34}\label{namespacenumpy_1_1core_1_1numeric_a8b8d87f38a2df98e0bf2036d0a4d1b34} 
\index{numpy.core.numeric@{numpy.core.numeric}!count\_nonzero@{count\_nonzero}}
\index{count\_nonzero@{count\_nonzero}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{count\_nonzero()}{count\_nonzero()}}
{\footnotesize\ttfamily count\+\_\+nonzero (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Counts the number of non-zero values in the array ``a``.

The word "non-zero" is in reference to the Python 2.x
built-in method ``__nonzero__()`` (renamed ``__bool__()``
in Python 3.x) of Python objects that tests an object's
"truthfulness". For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in ``a`` (and in
sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
method evaluated to ``True``.

Parameters
----------
a : array_like
    The array for which to count non-zeros.
axis : int or tuple, optional
    Axis or tuple of axes along which to count non-zeros.
    Default is None, meaning that non-zeros will be counted
    along a flattened version of ``a``.

    .. versionadded:: 1.12.0

Returns
-------
count : int or array of int
    Number of non-zero values in the array along a given axis.
    Otherwise, the total number of non-zero values in the array
    is returned.

See Also
--------
nonzero : Return the coordinates of all the non-zero values.

Examples
--------
>>> np.count_nonzero(np.eye(4))
4
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
5
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)
array([1, 1, 1, 1, 1])
>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)
array([2, 3])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ada05b1dd7ae630c33b4636b661b6b7bf}\label{namespacenumpy_1_1core_1_1numeric_ada05b1dd7ae630c33b4636b661b6b7bf} 
\index{numpy.core.numeric@{numpy.core.numeric}!cross@{cross}}
\index{cross@{cross}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{cross()}{cross()}}
{\footnotesize\ttfamily cross (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{axisa = {\ttfamily -\/1},  }\item[{}]{axisb = {\ttfamily -\/1},  }\item[{}]{axisc = {\ttfamily -\/1},  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the cross product of two (arrays of) vectors.

The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
are defined by the last axis of `a` and `b` by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.

Parameters
----------
a : array_like
    Components of the first vector(s).
b : array_like
    Components of the second vector(s).
axisa : int, optional
    Axis of `a` that defines the vector(s).  By default, the last axis.
axisb : int, optional
    Axis of `b` that defines the vector(s).  By default, the last axis.
axisc : int, optional
    Axis of `c` containing the cross product vector(s).  Ignored if
    both input vectors have dimension 2, as the return is scalar.
    By default, the last axis.
axis : int, optional
    If defined, the axis of `a`, `b` and `c` that defines the vector(s)
    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.

Returns
-------
c : ndarray
    Vector cross product(s).

Raises
------
ValueError
    When the dimension of the vector(s) in `a` and/or `b` does not
    equal 2 or 3.

See Also
--------
inner : Inner product
outer : Outer product.
ix_ : Construct index arrays.

Notes
-----
.. versionadded:: 1.9.0

Supports full broadcasting of the inputs.

Examples
--------
Vector cross-product.

>>> x = [1, 2, 3]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([-3,  6, -3])

One vector with dimension 2.

>>> x = [1, 2]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])

Equivalently:

>>> x = [1, 2, 0]
>>> y = [4, 5, 6]
>>> np.cross(x, y)
array([12, -6, -3])

Both vectors with dimension 2.

>>> x = [1,2]
>>> y = [4,5]
>>> np.cross(x, y)
-3

Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the `right-hand rule`.

>>> x = np.array([[1,2,3], [4,5,6]])
>>> y = np.array([[4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])

The orientation of `c` can be changed using the `axisc` keyword.

>>> np.cross(x, y, axisc=0)
array([[-3,  3],
       [ 6, -6],
       [-3,  3]])

Change the vector definition of `x` and `y` using `axisa` and `axisb`.

>>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
>>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
>>> np.cross(x, y)
array([[ -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6]])
>>> np.cross(x, y, axisa=0, axisb=0)
array([[-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ac6403845e3139ed279e19a818874ad7c}\label{namespacenumpy_1_1core_1_1numeric_ac6403845e3139ed279e19a818874ad7c} 
\index{numpy.core.numeric@{numpy.core.numeric}!extend\_all@{extend\_all}}
\index{extend\_all@{extend\_all}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{extend\_all()}{extend\_all()}}
{\footnotesize\ttfamily extend\+\_\+all (\begin{DoxyParamCaption}\item[{}]{module }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a540380bbe214868db334c0f6c672134b}\label{namespacenumpy_1_1core_1_1numeric_a540380bbe214868db334c0f6c672134b} 
\index{numpy.core.numeric@{numpy.core.numeric}!flatnonzero@{flatnonzero}}
\index{flatnonzero@{flatnonzero}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{flatnonzero()}{flatnonzero()}}
{\footnotesize\ttfamily flatnonzero (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return indices that are non-zero in the flattened version of a.

This is equivalent to np.nonzero(np.ravel(a))[0].

Parameters
----------
a : array_like
    Input data.

Returns
-------
res : ndarray
    Output array, containing the indices of the elements of `a.ravel()`
    that are non-zero.

See Also
--------
nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.

Examples
--------
>>> x = np.arange(-2, 3)
>>> x
array([-2, -1,  0,  1,  2])
>>> np.flatnonzero(x)
array([0, 1, 3, 4])

Use the indices of the non-zero elements as an index array to extract
these elements:

>>> x.ravel()[np.flatnonzero(x)]
array([-2, -1,  1,  2])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_aa4569b71e48d54af6ecb554fbaa2ee33}\label{namespacenumpy_1_1core_1_1numeric_aa4569b71e48d54af6ecb554fbaa2ee33} 
\index{numpy.core.numeric@{numpy.core.numeric}!fromfunction@{fromfunction}}
\index{fromfunction@{fromfunction}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{fromfunction()}{fromfunction()}}
{\footnotesize\ttfamily fromfunction (\begin{DoxyParamCaption}\item[{}]{function,  }\item[{}]{shape,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Construct an array by executing a function over each coordinate.

The resulting array therefore has a value ``fn(x, y, z)`` at
coordinate ``(x, y, z)``.

Parameters
----------
function : callable
    The function is called with N parameters, where N is the rank of
    `shape`.  Each parameter represents the coordinates of the array
    varying along a specific axis.  For example, if `shape`
    were ``(2, 2)``, then the parameters would be
    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
shape : (N,) tuple of ints
    Shape of the output array, which also determines the shape of
    the coordinate arrays passed to `function`.
dtype : data-type, optional
    Data-type of the coordinate arrays passed to `function`.
    By default, `dtype` is float.

Returns
-------
fromfunction : any
    The result of the call to `function` is passed back directly.
    Therefore the shape of `fromfunction` is completely determined by
    `function`.  If `function` returns a scalar value, the shape of
    `fromfunction` would match the `shape` parameter.

See Also
--------
indices, meshgrid

Notes
-----
Keywords other than `dtype` are passed to `function`.

Examples
--------
>>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

>>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_aedba2594d8fc1c40b727456402f98c6f}\label{namespacenumpy_1_1core_1_1numeric_aedba2594d8fc1c40b727456402f98c6f} 
\index{numpy.core.numeric@{numpy.core.numeric}!full@{full}}
\index{full@{full}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{full()}{full()}}
{\footnotesize\ttfamily full (\begin{DoxyParamCaption}\item[{}]{shape,  }\item[{}]{fill\+\_\+value,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}C\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new array of given shape and type, filled with `fill_value`.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
fill_value : scalar
    Fill value.
dtype : data-type, optional
    The desired data-type for the array  The default, `None`, means
     `np.array(fill_value).dtype`.
order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory.

Returns
-------
out : ndarray
    Array of `fill_value` with the given shape, dtype, and order.

See Also
--------
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.

Examples
--------
>>> np.full((2, 2), np.inf)
array([[ inf,  inf],
       [ inf,  inf]])
>>> np.full((2, 2), 10)
array([[10, 10],
       [10, 10]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ac10d8bc6db85ff700ba55cf4a02f5de2}\label{namespacenumpy_1_1core_1_1numeric_ac10d8bc6db85ff700ba55cf4a02f5de2} 
\index{numpy.core.numeric@{numpy.core.numeric}!full\_like@{full\_like}}
\index{full\_like@{full\_like}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{full\_like()}{full\_like()}}
{\footnotesize\ttfamily full\+\_\+like (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{fill\+\_\+value,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}K\textquotesingle{}},  }\item[{}]{subok = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a full array with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
fill_value : scalar
    Fill value.
dtype : data-type, optional
    Overrides the data type of the result.
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.

Returns
-------
out : ndarray
    Array of `fill_value` with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full : Return a new array of given shape filled with value.

Examples
--------
>>> x = np.arange(6, dtype=int)
>>> np.full_like(x, 1)
array([1, 1, 1, 1, 1, 1])
>>> np.full_like(x, 0.1)
array([0, 0, 0, 0, 0, 0])
>>> np.full_like(x, 0.1, dtype=np.double)
array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])
>>> np.full_like(x, np.nan, dtype=np.double)
array([ nan,  nan,  nan,  nan,  nan,  nan])

>>> y = np.arange(6, dtype=np.double)
>>> np.full_like(y, 0.1)
array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a7a1946c02c639c372df7726cbf881b4c}\label{namespacenumpy_1_1core_1_1numeric_a7a1946c02c639c372df7726cbf881b4c} 
\index{numpy.core.numeric@{numpy.core.numeric}!getbufsize@{getbufsize}}
\index{getbufsize@{getbufsize}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{getbufsize()}{getbufsize()}}
{\footnotesize\ttfamily getbufsize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the size of the buffer used in ufuncs.

Returns
-------
getbufsize : int
    Size of ufunc buffer in bytes.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a5e4bfcb9fa745a8a0f8bcc91b91ea7c4}\label{namespacenumpy_1_1core_1_1numeric_a5e4bfcb9fa745a8a0f8bcc91b91ea7c4} 
\index{numpy.core.numeric@{numpy.core.numeric}!geterr@{geterr}}
\index{geterr@{geterr}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{geterr()}{geterr()}}
{\footnotesize\ttfamily geterr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Get the current way of handling floating-point errors.

Returns
-------
res : dict
    A dictionary with keys "divide", "over", "under", and "invalid",
    whose values are from the strings "ignore", "print", "log", "warn",
    "raise", and "call". The keys represent possible floating-point
    exceptions, and the values define how these exceptions are handled.

See Also
--------
geterrcall, seterr, seterrcall

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> np.geterr()
{'over': 'warn', 'divide': 'warn', 'invalid': 'warn',
'under': 'ignore'}
>>> np.arange(3.) / np.arange(3.)
array([ NaN,   1.,   1.])

>>> oldsettings = np.seterr(all='warn', over='raise')
>>> np.geterr()
{'over': 'raise', 'divide': 'warn', 'invalid': 'warn', 'under': 'warn'}
>>> np.arange(3.) / np.arange(3.)
__main__:1: RuntimeWarning: invalid value encountered in divide
array([ NaN,   1.,   1.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a79ed745c1a77d11847c2e8f7319c1efc}\label{namespacenumpy_1_1core_1_1numeric_a79ed745c1a77d11847c2e8f7319c1efc} 
\index{numpy.core.numeric@{numpy.core.numeric}!geterrcall@{geterrcall}}
\index{geterrcall@{geterrcall}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{geterrcall()}{geterrcall()}}
{\footnotesize\ttfamily geterrcall (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the current callback function used on floating-point errors.

When the error handling for a floating-point error (one of "divide",
"over", "under", or "invalid") is set to 'call' or 'log', the function
that is called or the log instance that is written to is returned by
`geterrcall`. This function or log instance has been set with
`seterrcall`.

Returns
-------
errobj : callable, log instance or None
    The current error handler. If no handler was set through `seterrcall`,
    ``None`` is returned.

See Also
--------
seterrcall, seterr, geterr

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> np.geterrcall()  # we did not yet set a handler, returns None

>>> oldsettings = np.seterr(all='call')
>>> def err_handler(type, flag):
...     print("Floating point error (%s), with flag %s" % (type, flag))
>>> oldhandler = np.seterrcall(err_handler)
>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([ Inf,  Inf,  Inf])

>>> cur_handler = np.geterrcall()
>>> cur_handler is err_handler
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_addf06f9095931663abcdcb3087b50a03}\label{namespacenumpy_1_1core_1_1numeric_addf06f9095931663abcdcb3087b50a03} 
\index{numpy.core.numeric@{numpy.core.numeric}!identity@{identity}}
\index{identity@{identity}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{identity()}{identity()}}
{\footnotesize\ttfamily identity (\begin{DoxyParamCaption}\item[{}]{n,  }\item[{}]{dtype = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the identity array.

The identity array is a square array with ones on
the main diagonal.

Parameters
----------
n : int
    Number of rows (and columns) in `n` x `n` output.
dtype : data-type, optional
    Data-type of the output.  Defaults to ``float``.

Returns
-------
out : ndarray
    `n` x `n` array with its main diagonal set to one,
    and all other elements 0.

Examples
--------
>>> np.identity(3)
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a15cc0d5f58abbccc68308d3e9950c281}\label{namespacenumpy_1_1core_1_1numeric_a15cc0d5f58abbccc68308d3e9950c281} 
\index{numpy.core.numeric@{numpy.core.numeric}!indices@{indices}}
\index{indices@{indices}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{indices()}{indices()}}
{\footnotesize\ttfamily indices (\begin{DoxyParamCaption}\item[{}]{dimensions,  }\item[{}]{dtype = {\ttfamily int} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0,1,...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : dtype, optional
    Data type of the result.

Returns
-------
grid : ndarray
    The array of grid indices,
    ``grid.shape = (len(dimensions),) + tuple(dimensions)``.

See Also
--------
mgrid, meshgrid

Notes
-----
The output shape is obtained by prepending the number of dimensions
in front of the tuple of dimensions, i.e. if `dimensions` is a tuple
``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N,r0,...,rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k,i0,i1,...,iN-1] = ik

Examples
--------
>>> grid = np.indices((2, 3))
>>> grid.shape
(2, 2, 3)
>>> grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
>>> grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

The indices can be used as an index into an array.

>>> x = np.arange(20).reshape(5, 4)
>>> row, col = np.indices((2, 3))
>>> x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])

Note that it would be more straightforward in the above example to
extract the required elements directly with ``x[:2, :3]``.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a78d9c60ae7804c7ad02f362537a2c221}\label{namespacenumpy_1_1core_1_1numeric_a78d9c60ae7804c7ad02f362537a2c221} 
\index{numpy.core.numeric@{numpy.core.numeric}!isclose@{isclose}}
\index{isclose@{isclose}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{isclose()}{isclose()}}
{\footnotesize\ttfamily isclose (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{rtol = {\ttfamily 1.e-\/5},  }\item[{}]{atol = {\ttfamily 1.e-\/8},  }\item[{}]{equal\+\_\+nan = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a boolean array where two arrays are element-wise equal within a
tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

.. warning:: The default `atol` is not appropriate for comparing numbers
             that are much smaller than one (see Notes).

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

Returns
-------
y : array_like
    Returns a boolean array of where `a` and `b` are equal within the
    given tolerance. If both `a` and `b` are scalars, returns a single
    boolean value.

See Also
--------
allclose

Notes
-----
.. versionadded:: 1.7.0

For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.

 absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))

Unlike the built-in `math.isclose`, the above equation is not symmetric
in `a` and `b` -- it assumes `b` is the reference value -- so that
`isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,
the default value of atol is not zero, and is used to determine what
small values should be considered close to zero. The default value is
appropriate for expected values of order unity: if the expected values
are significantly smaller than one, it can result in false positives.
`atol` should be carefully selected for the use case at hand. A zero value
for `atol` will result in `False` if either `a` or `b` is zero.

Examples
--------
>>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
array([True, False])
>>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
array([True, True])
>>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
array([False, True])
>>> np.isclose([1.0, np.nan], [1.0, np.nan])
array([True, False])
>>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
array([True, True])
>>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
array([ True, False], dtype=bool)
>>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
array([False, False], dtype=bool)
>>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
array([ True,  True], dtype=bool)
>>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
array([False,  True], dtype=bool)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ad7e5b32aed91afd5299d92a3a31e2a14}\label{namespacenumpy_1_1core_1_1numeric_ad7e5b32aed91afd5299d92a3a31e2a14} 
\index{numpy.core.numeric@{numpy.core.numeric}!isfortran@{isfortran}}
\index{isfortran@{isfortran}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{isfortran()}{isfortran()}}
{\footnotesize\ttfamily isfortran (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if the array is Fortran contiguous but *not* C contiguous.

This function is obsolete and, because of changes due to relaxed stride
checking, its return value for the same array may differ for versions
of NumPy >= 1.10.0 and previous versions. If you only want to check if an
array is Fortran contiguous use ``a.flags.f_contiguous`` instead.

Parameters
----------
a : ndarray
    Input array.


Examples
--------

np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).

>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False

>>> b = np.array([[1, 2, 3], [4, 5, 6]], order='FORTRAN')
>>> b
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(b)
True


The transpose of a C-ordered array is a FORTRAN-ordered array.

>>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
>>> a
array([[1, 2, 3],
       [4, 5, 6]])
>>> np.isfortran(a)
False
>>> b = a.T
>>> b
array([[1, 4],
       [2, 5],
       [3, 6]])
>>> np.isfortran(b)
True

C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.

>>> np.isfortran(np.array([1, 2], order='FORTRAN'))
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ab97e06ecccb727b560bfc0279b69755f}\label{namespacenumpy_1_1core_1_1numeric_ab97e06ecccb727b560bfc0279b69755f} 
\index{numpy.core.numeric@{numpy.core.numeric}!isscalar@{isscalar}}
\index{isscalar@{isscalar}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{isscalar()}{isscalar()}}
{\footnotesize\ttfamily isscalar (\begin{DoxyParamCaption}\item[{}]{num }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if the type of `num` is a scalar type.

Parameters
----------
num : any
    Input argument, can be of any type and shape.

Returns
-------
val : bool
    True if `num` is a scalar type, False if it is not.

Examples
--------
>>> np.isscalar(3.1)
True
>>> np.isscalar([3.1])
False
>>> np.isscalar(False)
True
>>> np.isscalar('numpy')
True

NumPy supports PEP 3141 numbers:

>>> from fractions import Fraction
>>> isscalar(Fraction(5, 17))
True
>>> from numbers import Number
>>> isscalar(Number())
True\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a82d9979314ac7ed2dc9071139101c8f3}\label{namespacenumpy_1_1core_1_1numeric_a82d9979314ac7ed2dc9071139101c8f3} 
\index{numpy.core.numeric@{numpy.core.numeric}!load@{load}}
\index{load@{load}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{load()}{load()}}
{\footnotesize\ttfamily load (\begin{DoxyParamCaption}\item[{}]{file }\end{DoxyParamCaption})}

\begin{DoxyVerb}Wrapper around cPickle.load which accepts either a file-like object or
a filename.

Note that the NumPy binary format is not based on pickle/cPickle anymore.
For details on the preferred way of loading and saving files, see `load`
and `save`.

See Also
--------
load, save\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ad77cd440041ccedba33e31e3ea4a8bc5}\label{namespacenumpy_1_1core_1_1numeric_ad77cd440041ccedba33e31e3ea4a8bc5} 
\index{numpy.core.numeric@{numpy.core.numeric}!loads@{loads}}
\index{loads@{loads}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{loads()}{loads()}}
{\footnotesize\ttfamily loads (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_aeb4e8a5ca55c3cb146eb3f6be26ecb14}\label{namespacenumpy_1_1core_1_1numeric_aeb4e8a5ca55c3cb146eb3f6be26ecb14} 
\index{numpy.core.numeric@{numpy.core.numeric}!moveaxis@{moveaxis}}
\index{moveaxis@{moveaxis}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{moveaxis()}{moveaxis()}}
{\footnotesize\ttfamily moveaxis (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{source,  }\item[{}]{destination }\end{DoxyParamCaption})}

\begin{DoxyVerb}Move axes of an array to new positions.

Other axes remain in their original order.

.. versionadded:: 1.11.0

Parameters
----------
a : np.ndarray
    The array whose axes should be reordered.
source : int or sequence of int
    Original positions of the axes to move. These must be unique.
destination : int or sequence of int
    Destination positions for each of the original axes. These must also be
    unique.

Returns
-------
result : np.ndarray
    Array with moved axes. This array is a view of the input array.

See Also
--------
transpose: Permute the dimensions of an array.
swapaxes: Interchange two axes of an array.

Examples
--------

>>> x = np.zeros((3, 4, 5))
>>> np.moveaxis(x, 0, -1).shape
(4, 5, 3)
>>> np.moveaxis(x, -1, 0).shape
(5, 3, 4)

These all achieve the same result:

>>> np.transpose(x).shape
(5, 4, 3)
>>> np.swapaxes(x, 0, -1).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1], [-1, -2]).shape
(5, 4, 3)
>>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
(5, 4, 3)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a633e6e3bdb3c4381173586ff31b8b8a1}\label{namespacenumpy_1_1core_1_1numeric_a633e6e3bdb3c4381173586ff31b8b8a1} 
\index{numpy.core.numeric@{numpy.core.numeric}!normalize\_axis\_tuple@{normalize\_axis\_tuple}}
\index{normalize\_axis\_tuple@{normalize\_axis\_tuple}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{normalize\_axis\_tuple()}{normalize\_axis\_tuple()}}
{\footnotesize\ttfamily normalize\+\_\+axis\+\_\+tuple (\begin{DoxyParamCaption}\item[{}]{axis,  }\item[{}]{ndim,  }\item[{}]{argname = {\ttfamily None},  }\item[{}]{allow\+\_\+duplicate = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Normalizes an axis argument into a tuple of non-negative integer axes.

This handles shorthands such as ``1`` and converts them to ``(1,)``,
as well as performing the handling of negative indices covered by
`normalize_axis_index`.

By default, this forbids axes from being specified multiple times.

Used internally by multi-axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int, iterable of int
    The un-normalized index or indices of the axis.
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against.
argname : str, optional
    A prefix to put before the error message, typically the name of the
    argument.
allow_duplicate : bool, optional
    If False, the default, disallow an axis from being specified twice.

Returns
-------
normalized_axes : tuple of int
    The normalized axis index, such that `0 <= normalized_axis < ndim`

Raises
------
AxisError
    If any axis provided is out of range
ValueError
    If an axis is repeated

See also
--------
normalize_axis_index : normalizing a single scalar axis
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a5b5954221cf8ffcbfcafbd540faf5e53}\label{namespacenumpy_1_1core_1_1numeric_a5b5954221cf8ffcbfcafbd540faf5e53} 
\index{numpy.core.numeric@{numpy.core.numeric}!ones@{ones}}
\index{ones@{ones}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{ones()}{ones()}}
{\footnotesize\ttfamily ones (\begin{DoxyParamCaption}\item[{}]{shape,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}C\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new array of given shape and type, filled with ones.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: C
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.

Returns
-------
out : ndarray
    Array of ones with the given shape, dtype, and order.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Examples
--------
>>> np.ones(5)
array([ 1.,  1.,  1.,  1.,  1.])

>>> np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])

>>> np.ones((2, 1))
array([[ 1.],
       [ 1.]])

>>> s = (2,2)
>>> np.ones(s)
array([[ 1.,  1.],
       [ 1.,  1.]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ab7769ce7127b4b31b480ddd3323dfd67}\label{namespacenumpy_1_1core_1_1numeric_ab7769ce7127b4b31b480ddd3323dfd67} 
\index{numpy.core.numeric@{numpy.core.numeric}!ones\_like@{ones\_like}}
\index{ones\_like@{ones\_like}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{ones\_like()}{ones\_like()}}
{\footnotesize\ttfamily ones\+\_\+like (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}K\textquotesingle{}},  }\item[{}]{subok = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array of ones with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.

Returns
-------
out : ndarray
    Array of ones with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.

Examples
--------
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])

>>> y = np.arange(3, dtype=float)
>>> y
array([ 0.,  1.,  2.])
>>> np.ones_like(y)
array([ 1.,  1.,  1.])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a670d32b25afaf9b35fd35891173e8b75}\label{namespacenumpy_1_1core_1_1numeric_a670d32b25afaf9b35fd35891173e8b75} 
\index{numpy.core.numeric@{numpy.core.numeric}!outer@{outer}}
\index{outer@{outer}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{outer()}{outer()}}
{\footnotesize\ttfamily outer (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{out = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to N dimensions and other operations.
              ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.

References
----------
.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a (*very* coarse) grid for computing a Mandelbrot set:

>>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
>>> rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
>>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
>>> im
array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
>>> grid = rl + im
>>> grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a "vector" of letters:

>>> x = np.array(['a', 'b', 'c'], dtype=object)
>>> np.outer(x, [1, 2, 3])
array([[a, aa, aaa],
       [b, bb, bbb],
       [c, cc, ccc]], dtype=object)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a9f2eb9ac9bd6e9bfd31f153debbb173f}\label{namespacenumpy_1_1core_1_1numeric_a9f2eb9ac9bd6e9bfd31f153debbb173f} 
\index{numpy.core.numeric@{numpy.core.numeric}!require@{require}}
\index{require@{require}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{require()}{require()}}
{\footnotesize\ttfamily require (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{requirements = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an ndarray of the provided type that satisfies requirements.

This function is useful to be sure that an array with the correct flags
is returned for passing to compiled code (perhaps through ctypes).

Parameters
----------
a : array_like
   The object to be converted to a type-and-requirement-satisfying array.
dtype : data-type
   The required data-type. If None preserve the current dtype. If your
   application requires the data to be in native byteorder, include
   a byteorder specification as a part of the dtype specification.
requirements : str or list of str
   The requirements list can be any of the following

   * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array
   * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array
   * 'ALIGNED' ('A')      - ensure a data-type aligned array
   * 'WRITEABLE' ('W')    - ensure a writable array
   * 'OWNDATA' ('O')      - ensure an array that owns its own data
   * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass

See Also
--------
asarray : Convert input to an ndarray.
asanyarray : Convert to an ndarray, but pass through ndarray subclasses.
ascontiguousarray : Convert input to a contiguous array.
asfortranarray : Convert input to an ndarray with column-major
                 memory order.
ndarray.flags : Information about the memory layout of the array.

Notes
-----
The returned array will be guaranteed to have the listed requirements
by making a copy if needed.

Examples
--------
>>> x = np.arange(6).reshape(2,3)
>>> x.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False

>>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])
>>> y.flags
  C_CONTIGUOUS : False
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
  UPDATEIFCOPY : False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ace9cdd8dd48db11f666a6ca219df5eef}\label{namespacenumpy_1_1core_1_1numeric_ace9cdd8dd48db11f666a6ca219df5eef} 
\index{numpy.core.numeric@{numpy.core.numeric}!roll@{roll}}
\index{roll@{roll}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{roll()}{roll()}}
{\footnotesize\ttfamily roll (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{shift,  }\item[{}]{axis = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Roll array elements along a given axis.

Elements that roll beyond the last position are re-introduced at
the first.

Parameters
----------
a : array_like
    Input array.
shift : int or tuple of ints
    The number of places by which elements are shifted.  If a tuple,
    then `axis` must be a tuple of the same size, and each of the
    given axes is shifted by the corresponding number.  If an int
    while `axis` is a tuple of ints, then the same value is used for
    all given axes.
axis : int or tuple of ints, optional
    Axis or axes along which elements are shifted.  By default, the
    array is flattened before shifting, after which the original
    shape is restored.

Returns
-------
res : ndarray
    Output array, with the same shape as `a`.

See Also
--------
rollaxis : Roll the specified axis backwards, until it lies in a
           given position.

Notes
-----
.. versionadded:: 1.12.0

Supports rolling over multiple dimensions simultaneously.

Examples
--------
>>> x = np.arange(10)
>>> np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])

>>> x2 = np.reshape(x, (2,5))
>>> x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
>>> np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
>>> np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_ac7a999206352aa2d43ad94aacafaec84}\label{namespacenumpy_1_1core_1_1numeric_ac7a999206352aa2d43ad94aacafaec84} 
\index{numpy.core.numeric@{numpy.core.numeric}!rollaxis@{rollaxis}}
\index{rollaxis@{rollaxis}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{rollaxis()}{rollaxis()}}
{\footnotesize\ttfamily rollaxis (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis,  }\item[{}]{start = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Roll the specified axis backwards, until it lies in a given position.

This function continues to be supported for backward compatibility, but you
should prefer `moveaxis`. The `moveaxis` function was added in NumPy
1.11.

Parameters
----------
a : ndarray
    Input array.
axis : int
    The axis to roll backwards.  The positions of the other axes do not
    change relative to one another.
start : int, optional
    The axis is rolled until it lies before this position.  The default,
    0, results in a "complete" roll.

Returns
-------
res : ndarray
    For NumPy >= 1.10.0 a view of `a` is always returned. For earlier
    NumPy versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

See Also
--------
moveaxis : Move array axes to new positions.
roll : Roll the elements of an array by a number of positions along a
    given axis.

Examples
--------
>>> a = np.ones((3,4,5,6))
>>> np.rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
>>> np.rollaxis(a, 2).shape
(5, 3, 4, 6)
>>> np.rollaxis(a, 1, 4).shape
(3, 5, 6, 4)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a0f9f3a5cd1bd622ccebc34cef0a44886}\label{namespacenumpy_1_1core_1_1numeric_a0f9f3a5cd1bd622ccebc34cef0a44886} 
\index{numpy.core.numeric@{numpy.core.numeric}!setbufsize@{setbufsize}}
\index{setbufsize@{setbufsize}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{setbufsize()}{setbufsize()}}
{\footnotesize\ttfamily setbufsize (\begin{DoxyParamCaption}\item[{}]{size }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set the size of the buffer used in ufuncs.

Parameters
----------
size : int
    Size of buffer.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a89f05e9f89cd563821bae91ae8e56d1a}\label{namespacenumpy_1_1core_1_1numeric_a89f05e9f89cd563821bae91ae8e56d1a} 
\index{numpy.core.numeric@{numpy.core.numeric}!seterr@{seterr}}
\index{seterr@{seterr}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{seterr()}{seterr()}}
{\footnotesize\ttfamily seterr (\begin{DoxyParamCaption}\item[{}]{all = {\ttfamily None},  }\item[{}]{divide = {\ttfamily None},  }\item[{}]{over = {\ttfamily None},  }\item[{}]{under = {\ttfamily None},  }\item[{}]{invalid = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set how floating-point errors are handled.

Note that operations on integer scalar types (such as `int16`) are
handled like floating point, and are affected by these settings.

Parameters
----------
all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Set treatment for all types of floating-point errors at once:

    - ignore: Take no action when the exception occurs.
    - warn: Print a `RuntimeWarning` (via the Python `warnings` module).
    - raise: Raise a `FloatingPointError`.
    - call: Call a function specified using the `seterrcall` function.
    - print: Print a warning directly to ``stdout``.
    - log: Record error in a Log object specified by `seterrcall`.

    The default is not to change the current behavior.
divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for division by zero.
over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for floating-point overflow.
under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for floating-point underflow.
invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for invalid floating-point operation.

Returns
-------
old_settings : dict
    Dictionary containing the old settings.

See also
--------
seterrcall : Set a callback function for the 'call' mode.
geterr, geterrcall, errstate

Notes
-----
The floating-point exceptions are defined in the IEEE 754 standard [1]_:

- Division by zero: infinite result obtained from finite numbers.
- Overflow: result too large to be expressed.
- Underflow: result so close to zero that some precision
  was lost.
- Invalid operation: result is not an expressible number, typically
  indicates that a NaN was produced.

.. [1] http://en.wikipedia.org/wiki/IEEE_754

Examples
--------
>>> old_settings = np.seterr(all='ignore')  #seterr to known value
>>> np.seterr(over='raise')
{'over': 'ignore', 'divide': 'ignore', 'invalid': 'ignore',
 'under': 'ignore'}
>>> np.seterr(**old_settings)  # reset to default
{'over': 'raise', 'divide': 'ignore', 'invalid': 'ignore',
 'under': 'ignore'}

>>> np.int16(32000) * np.int16(3)
30464
>>> old_settings = np.seterr(all='warn', over='raise')
>>> np.int16(32000) * np.int16(3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FloatingPointError: overflow encountered in short_scalars

>>> old_settings = np.seterr(all='print')
>>> np.geterr()
{'over': 'print', 'divide': 'print', 'invalid': 'print', 'under': 'print'}
>>> np.int16(32000) * np.int16(3)
Warning: overflow encountered in short_scalars
30464\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_a1f5feeb8e8dc11011309cefdd855a421}\label{namespacenumpy_1_1core_1_1numeric_a1f5feeb8e8dc11011309cefdd855a421} 
\index{numpy.core.numeric@{numpy.core.numeric}!seterrcall@{seterrcall}}
\index{seterrcall@{seterrcall}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{seterrcall()}{seterrcall()}}
{\footnotesize\ttfamily seterrcall (\begin{DoxyParamCaption}\item[{}]{func }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set the floating-point error callback function or log object.

There are two ways to capture floating-point error messages.  The first
is to set the error-handler to 'call', using `seterr`.  Then, set
the function to call using this function.

The second is to set the error-handler to 'log', using `seterr`.
Floating-point errors then trigger a call to the 'write' method of
the provided object.

Parameters
----------
func : callable f(err, flag) or object with write method
    Function to call upon floating-point errors ('call'-mode) or
    object whose 'write' method is used to log such message ('log'-mode).

    The call function takes two arguments. The first is a string describing
    the type of error (such as "divide by zero", "overflow", "underflow",
    or "invalid value"), and the second is the status flag.  The flag is a
    byte, whose four least-significant bits indicate the type of error, one
    of "divide", "over", "under", "invalid"::

      [0 0 0 0 divide over under invalid]

    In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.

    If an object is provided, its write method should take one argument,
    a string.

Returns
-------
h : callable, log instance or None
    The old error handler.

See Also
--------
seterr, geterr, geterrcall

Examples
--------
Callback upon error:

>>> def err_handler(type, flag):
...     print("Floating point error (%s), with flag %s" % (type, flag))
...

>>> saved_handler = np.seterrcall(err_handler)
>>> save_err = np.seterr(all='call')

>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([ Inf,  Inf,  Inf])

>>> np.seterrcall(saved_handler)
<function err_handler at 0x...>
>>> np.seterr(**save_err)
{'over': 'call', 'divide': 'call', 'invalid': 'call', 'under': 'call'}

Log error message:

>>> class Log(object):
...     def write(self, msg):
...         print("LOG: %s" % msg)
...

>>> log = Log()
>>> saved_handler = np.seterrcall(log)
>>> save_err = np.seterr(all='log')

>>> np.array([1, 2, 3]) / 0.0
LOG: Warning: divide by zero encountered in divide
<BLANKLINE>
array([ Inf,  Inf,  Inf])

>>> np.seterrcall(saved_handler)
<__main__.Log object at 0x...>
>>> np.seterr(**save_err)
{'over': 'log', 'divide': 'log', 'invalid': 'log', 'under': 'log'}\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_aa8ae72904798e11b173e975752fd3b80}\label{namespacenumpy_1_1core_1_1numeric_aa8ae72904798e11b173e975752fd3b80} 
\index{numpy.core.numeric@{numpy.core.numeric}!tensordot@{tensordot}}
\index{tensordot@{tensordot}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{tensordot()}{tensordot()}}
{\footnotesize\ttfamily tensordot (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b,  }\item[{}]{axes = {\ttfamily 2} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute tensor dot product along specified axes for arrays >= 1-D.

Given two tensors (arrays of dimension greater than or equal to one),
`a` and `b`, and an array_like object containing two array_like
objects, ``(a_axes, b_axes)``, sum the products of `a`'s and `b`'s
elements (components) over the axes specified by ``a_axes`` and
``b_axes``. The third argument can be a single non-negative
integer_like scalar, ``N``; if it is such, then the last ``N``
dimensions of `a` and the first ``N`` dimensions of `b` are summed
over.

Parameters
----------
a, b : array_like, len(shape) >= 1
    Tensors to "dot".

axes : int or (2,) array_like
    * integer_like
      If an int N, sum over the last N axes of `a` and the first N axes
      of `b` in order. The sizes of the corresponding axes must match.
    * (2,) array_like
      Or, a list of axes to be summed over, first sequence applying to `a`,
      second to `b`. Both elements array_like must be of the same length.

See Also
--------
dot, einsum

Notes
-----
Three common use cases are:
    * ``axes = 0`` : tensor product :math:`a\\otimes b`
    * ``axes = 1`` : tensor dot product :math:`a\\cdot b`
    * ``axes = 2`` : (default) tensor double contraction :math:`a:b`

When `axes` is integer_like, the sequence for evaluation will be: first
the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and
Nth axis in `b` last.

When there is more than one axis to sum over - and they are not the last
(first) axes of `a` (`b`) - the argument `axes` should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.

Examples
--------
A "traditional" example:

>>> a = np.arange(60.).reshape(3,4,5)
>>> b = np.arange(24.).reshape(4,3,2)
>>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
>>> c.shape
(5, 2)
>>> c
array([[ 4400.,  4730.],
       [ 4532.,  4874.],
       [ 4664.,  5018.],
       [ 4796.,  5162.],
       [ 4928.,  5306.]])
>>> # A slower but equivalent way of computing the same...
>>> d = np.zeros((5,2))
>>> for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         d[i,j] += a[k,n,i] * b[n,k,j]
>>> c == d
array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]])

An extended example taking advantage of the overloading of + and \\*:

>>> a = np.array(range(1, 9))
>>> a.shape = (2, 2, 2)
>>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
>>> A.shape = (2, 2)
>>> a; A
array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
array([[a, b],
       [c, d]], dtype=object)

>>> np.tensordot(a, A) # third argument default is 2 for double-contraction
array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)

>>> np.tensordot(a, A, 1)
array([[[acc, bdd],
        [aaacccc, bbbdddd]],
       [[aaaaacccccc, bbbbbdddddd],
        [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)

>>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
array([[[[[a, b],
          [c, d]],
          ...

>>> np.tensordot(a, A, (0, 1))
array([[[abbbbb, cddddd],
        [aabbbbbb, ccdddddd]],
       [[aaabbbbbbb, cccddddddd],
        [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)

>>> np.tensordot(a, A, (2, 1))
array([[[abb, cdd],
        [aaabbbb, cccdddd]],
       [[aaaaabbbbbb, cccccdddddd],
        [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)

>>> np.tensordot(a, A, ((0, 1), (0, 1)))
array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)

>>> np.tensordot(a, A, ((2, 1), (1, 0)))
array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1numeric_aeed5561ec35eff09e9ce7b1c757441b4}\label{namespacenumpy_1_1core_1_1numeric_aeed5561ec35eff09e9ce7b1c757441b4} 
\index{numpy.core.numeric@{numpy.core.numeric}!zeros\_like@{zeros\_like}}
\index{zeros\_like@{zeros\_like}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{zeros\_like()}{zeros\_like()}}
{\footnotesize\ttfamily zeros\+\_\+like (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily \textquotesingle{}K\textquotesingle{}},  }\item[{}]{subok = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return an array of zeros with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of 'a', otherwise it will be a base-class array. Defaults
    to True.

Returns
-------
out : ndarray
    Array of zeros with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.

Examples
--------
>>> x = np.arange(6)
>>> x = x.reshape((2, 3))
>>> x
array([[0, 1, 2],
       [3, 4, 5]])
>>> np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])

>>> y = np.arange(3, dtype=float)
>>> y
array([ 0.,  1.,  2.])
>>> np.zeros_like(y)
array([ 0.,  0.,  0.])\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1core_1_1numeric_a3d9b7116bfe8942f848ca36543854ef9}\label{namespacenumpy_1_1core_1_1numeric_a3d9b7116bfe8942f848ca36543854ef9} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_errdict@{\_errdict}}
\index{\_errdict@{\_errdict}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_errdict}{\_errdict}}
{\footnotesize\ttfamily dict \+\_\+errdict\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{"{}ignore"{}}:\ ERR\_IGNORE,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}warn"{}}:\ ERR\_WARN,}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}raise"{}}:\ ERR\_RAISE,}
\DoxyCodeLine{00004\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}call"{}}:\ ERR\_CALL,}
\DoxyCodeLine{00005\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}print"{}}:\ ERR\_PRINT,}
\DoxyCodeLine{00006\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}log"{}}:\ ERR\_LOG\}}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1core_1_1numeric_aada950c2ab91b77b46937a6b23ff444e}\label{namespacenumpy_1_1core_1_1numeric_aada950c2ab91b77b46937a6b23ff444e} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_errdict\_rev@{\_errdict\_rev}}
\index{\_errdict\_rev@{\_errdict\_rev}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_errdict\_rev}{\_errdict\_rev}}
{\footnotesize\ttfamily dict \+\_\+errdict\+\_\+rev = \{\}\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a6f03d55c27d0e45f584ad1cafb2e8029}\label{namespacenumpy_1_1core_1_1numeric_a6f03d55c27d0e45f584ad1cafb2e8029} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_mode\_from\_name\_dict@{\_mode\_from\_name\_dict}}
\index{\_mode\_from\_name\_dict@{\_mode\_from\_name\_dict}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_mode\_from\_name\_dict}{\_mode\_from\_name\_dict}}
{\footnotesize\ttfamily dict \+\_\+mode\+\_\+from\+\_\+name\+\_\+dict\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{\textcolor{stringliteral}{'v'}:\ 0,}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'s'}:\ 1,}
\DoxyCodeLine{00003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'f'}:\ 2\}}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1core_1_1numeric_a2af58d7a2abd912fd174aad825cc7c5c}\label{namespacenumpy_1_1core_1_1numeric_a2af58d7a2abd912fd174aad825cc7c5c} 
\index{numpy.core.numeric@{numpy.core.numeric}!\_Unspecified@{\_Unspecified}}
\index{\_Unspecified@{\_Unspecified}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{\_Unspecified}{\_Unspecified}}
{\footnotesize\ttfamily \+\_\+\+Unspecified = \mbox{\hyperlink{classnumpy_1_1core_1_1numeric_1_1__unspecified}{\+\_\+unspecified}}()\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a4e790eefd40bafcbf3c482435de1b20a}\label{namespacenumpy_1_1core_1_1numeric_a4e790eefd40bafcbf3c482435de1b20a} 
\index{numpy.core.numeric@{numpy.core.numeric}!basestring@{basestring}}
\index{basestring@{basestring}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{basestring}{basestring}}
{\footnotesize\ttfamily basestring = str}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a59e478f8d9c3e54bb7f3e0c4d92ca6f2}\label{namespacenumpy_1_1core_1_1numeric_a59e478f8d9c3e54bb7f3e0c4d92ca6f2} 
\index{numpy.core.numeric@{numpy.core.numeric}!bitwise\_not@{bitwise\_not}}
\index{bitwise\_not@{bitwise\_not}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{bitwise\_not}{bitwise\_not}}
{\footnotesize\ttfamily bitwise\+\_\+not = invert}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_aec6fbaee51d57a0e44dcc3a1481a5fc3}\label{namespacenumpy_1_1core_1_1numeric_aec6fbaee51d57a0e44dcc3a1481a5fc3} 
\index{numpy.core.numeric@{numpy.core.numeric}!False\_@{False\_}}
\index{False\_@{False\_}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{False\_}{False\_}}
{\footnotesize\ttfamily False\+\_\+ = bool\+\_\+(\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a1c8a517864e31bca74fc3c730d6b47e8}\label{namespacenumpy_1_1core_1_1numeric_a1c8a517864e31bca74fc3c730d6b47e8} 
\index{numpy.core.numeric@{numpy.core.numeric}!Inf@{Inf}}
\index{Inf@{Inf}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{Inf}{Inf}}
{\footnotesize\ttfamily Inf = PINF}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a244cdc355af046c5ff10118116412b10}\label{namespacenumpy_1_1core_1_1numeric_a244cdc355af046c5ff10118116412b10} 
\index{numpy.core.numeric@{numpy.core.numeric}!little\_endian@{little\_endian}}
\index{little\_endian@{little\_endian}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{little\_endian}{little\_endian}}
{\footnotesize\ttfamily tuple little\+\_\+endian = (sys.\+byteorder == \textquotesingle{}little\textquotesingle{})}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a32077e33a08c1e9ba02bbdabfe645c24}\label{namespacenumpy_1_1core_1_1numeric_a32077e33a08c1e9ba02bbdabfe645c24} 
\index{numpy.core.numeric@{numpy.core.numeric}!nan@{nan}}
\index{nan@{nan}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{nan}{nan}}
{\footnotesize\ttfamily nan = NAN}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a99cfcf7602411359d94844953c47380f}\label{namespacenumpy_1_1core_1_1numeric_a99cfcf7602411359d94844953c47380f} 
\index{numpy.core.numeric@{numpy.core.numeric}!newaxis@{newaxis}}
\index{newaxis@{newaxis}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{newaxis}{newaxis}}
{\footnotesize\ttfamily newaxis = None}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_a22996eb6fafcf22551460f22d235d649}\label{namespacenumpy_1_1core_1_1numeric_a22996eb6fafcf22551460f22d235d649} 
\index{numpy.core.numeric@{numpy.core.numeric}!True\_@{True\_}}
\index{True\_@{True\_}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{True\_}{True\_}}
{\footnotesize\ttfamily True\+\_\+ = bool\+\_\+(\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})}

\Hypertarget{namespacenumpy_1_1core_1_1numeric_aaecf86ba873f20737a9f7fe5eb11dcdd}\label{namespacenumpy_1_1core_1_1numeric_aaecf86ba873f20737a9f7fe5eb11dcdd} 
\index{numpy.core.numeric@{numpy.core.numeric}!ufunc@{ufunc}}
\index{ufunc@{ufunc}!numpy.core.numeric@{numpy.core.numeric}}
\doxysubsubsection{\texorpdfstring{ufunc}{ufunc}}
{\footnotesize\ttfamily ufunc = type(sin)}

