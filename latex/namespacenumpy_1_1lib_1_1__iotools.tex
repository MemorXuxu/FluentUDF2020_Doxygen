\doxysection{numpy.\+lib.\+\_\+iotools Namespace Reference}
\hypertarget{namespacenumpy_1_1lib_1_1__iotools}{}\label{namespacenumpy_1_1lib_1_1__iotools}\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1_conversion_warning}{Conversion\+Warning}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1_converter_error}{Converter\+Error}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1_converter_lock_error}{Converter\+Lock\+Error}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1_line_splitter}{Line\+Splitter}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1_name_validator}{Name\+Validator}}
\item 
class \mbox{\hyperlink{classnumpy_1_1lib_1_1__iotools_1_1_string_converter}{String\+Converter}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_a079229ab8072153f5e8cd338c77b4266}{\+\_\+decode\+\_\+line}} (line, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1npyio_ab1000d1f2ea9878f60bc119650013894}{encoding}}=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_a95ffd37924979b2d34ca1a7efe380d5d}{\+\_\+is\+\_\+string\+\_\+like}} (\mbox{\hyperlink{structobj}{obj}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_ac8cc01892645ad1bcf7c9cca20dd203c}{\+\_\+is\+\_\+bytes\+\_\+like}} (\mbox{\hyperlink{structobj}{obj}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_aa33c755f912e13d9b6c04f9779b74258}{\+\_\+to\+\_\+filehandle}} (fname, flag=\textquotesingle{}r\textquotesingle{}, return\+\_\+opened=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_af689452c5a1f47d2895282ea83483a6b}{has\+\_\+nested\+\_\+fields}} (ndtype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_a7bad33542832387a7c0fe87f5edd8b21}{flatten\+\_\+dtype}} (ndtype, flatten\+\_\+base=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_a2b8f762ba60384b0c65e8036e7e35d0b}{str2bool}} (value)
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_aec64489d2269621cfab8c784652d75f1}{easy\+\_\+dtype}} (ndtype, names=None, defaultfmt="{}f\%i"{}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}validationargs)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1lib_1_1__iotools_aa3c0e7a8f2695defce5d510420b4f347}{unicode}} = str
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}A collection of functions designed to help I/O with ascii files.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a079229ab8072153f5e8cd338c77b4266}\label{namespacenumpy_1_1lib_1_1__iotools_a079229ab8072153f5e8cd338c77b4266} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!\_decode\_line@{\_decode\_line}}
\index{\_decode\_line@{\_decode\_line}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{\_decode\_line()}{\_decode\_line()}}
{\footnotesize\ttfamily \+\_\+decode\+\_\+line (\begin{DoxyParamCaption}\item[{}]{line,  }\item[{}]{encoding = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Decode bytes from binary input streams.

Defaults to decoding from 'latin1'. That differs from the behavior of
np.compat.asunicode that decodes from 'ascii'.

Parameters
----------
line : str or bytes
     Line to be decoded.

Returns
-------
decoded_line : unicode
     Unicode in Python 2, a str (unicode) in Python 3.\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__iotools_ac8cc01892645ad1bcf7c9cca20dd203c}\label{namespacenumpy_1_1lib_1_1__iotools_ac8cc01892645ad1bcf7c9cca20dd203c} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!\_is\_bytes\_like@{\_is\_bytes\_like}}
\index{\_is\_bytes\_like@{\_is\_bytes\_like}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{\_is\_bytes\_like()}{\_is\_bytes\_like()}}
{\footnotesize\ttfamily \+\_\+is\+\_\+bytes\+\_\+like (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check whether obj behaves like a bytes object.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a95ffd37924979b2d34ca1a7efe380d5d}\label{namespacenumpy_1_1lib_1_1__iotools_a95ffd37924979b2d34ca1a7efe380d5d} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!\_is\_string\_like@{\_is\_string\_like}}
\index{\_is\_string\_like@{\_is\_string\_like}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{\_is\_string\_like()}{\_is\_string\_like()}}
{\footnotesize\ttfamily \+\_\+is\+\_\+string\+\_\+like (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Check whether obj behaves like a string.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__iotools_aa33c755f912e13d9b6c04f9779b74258}\label{namespacenumpy_1_1lib_1_1__iotools_aa33c755f912e13d9b6c04f9779b74258} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!\_to\_filehandle@{\_to\_filehandle}}
\index{\_to\_filehandle@{\_to\_filehandle}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{\_to\_filehandle()}{\_to\_filehandle()}}
{\footnotesize\ttfamily \+\_\+to\+\_\+filehandle (\begin{DoxyParamCaption}\item[{}]{fname,  }\item[{}]{flag = {\ttfamily \textquotesingle{}r\textquotesingle{}},  }\item[{}]{return\+\_\+opened = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns the filehandle corresponding to a string or a file.
If the string ends in '.gz', the file is automatically unzipped.

Parameters
----------
fname : string, filehandle
    Name of the file whose filehandle must be returned.
flag : string, optional
    Flag indicating the status of the file ('r' for read, 'w' for write).
return_opened : boolean, optional
    Whether to return the opening status of the file.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__iotools_aec64489d2269621cfab8c784652d75f1}\label{namespacenumpy_1_1lib_1_1__iotools_aec64489d2269621cfab8c784652d75f1} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!easy\_dtype@{easy\_dtype}}
\index{easy\_dtype@{easy\_dtype}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{easy\_dtype()}{easy\_dtype()}}
{\footnotesize\ttfamily easy\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{ndtype,  }\item[{}]{names = {\ttfamily None},  }\item[{}]{defaultfmt = {\ttfamily "{}f\%i"{}},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{validationargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convenience function to create a `np.dtype` object.

The function processes the input `dtype` and matches it with the given
names.

Parameters
----------
ndtype : var
    Definition of the dtype. Can be any string or dictionary recognized
    by the `np.dtype` function, or a sequence of types.
names : str or sequence, optional
    Sequence of strings to use as field names for a structured dtype.
    For convenience, `names` can be a string of a comma-separated list
    of names.
defaultfmt : str, optional
    Format string used to define missing names, such as ``"f%i"``
    (default) or ``"fields_%02i"``.
validationargs : optional
    A series of optional arguments used to initialize a
    `NameValidator`.

Examples
--------
>>> np.lib._iotools.easy_dtype(float)
dtype('float64')
>>> np.lib._iotools.easy_dtype("i4, f8")
dtype([('f0', '<i4'), ('f1', '<f8')])
>>> np.lib._iotools.easy_dtype("i4, f8", defaultfmt="field_%03i")
dtype([('field_000', '<i4'), ('field_001', '<f8')])

>>> np.lib._iotools.easy_dtype((int, float, float), names="a,b,c")
dtype([('a', '<i8'), ('b', '<f8'), ('c', '<f8')])
>>> np.lib._iotools.easy_dtype(float, names="a,b,c")
dtype([('a', '<f8'), ('b', '<f8'), ('c', '<f8')])\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a7bad33542832387a7c0fe87f5edd8b21}\label{namespacenumpy_1_1lib_1_1__iotools_a7bad33542832387a7c0fe87f5edd8b21} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!flatten\_dtype@{flatten\_dtype}}
\index{flatten\_dtype@{flatten\_dtype}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{flatten\_dtype()}{flatten\_dtype()}}
{\footnotesize\ttfamily flatten\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{ndtype,  }\item[{}]{flatten\+\_\+base = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Unpack a structured data-type by collapsing nested fields and/or fields
with a shape.

Note that the field names are lost.

Parameters
----------
ndtype : dtype
    The datatype to collapse
flatten_base : bool, optional
   If True, transform a field with a shape into several fields. Default is
   False.

Examples
--------
>>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),
...                ('block', int, (2, 3))])
>>> np.lib._iotools.flatten_dtype(dt)
[dtype('|S4'), dtype('float64'), dtype('float64'), dtype('int32')]
>>> np.lib._iotools.flatten_dtype(dt, flatten_base=True)
[dtype('|S4'), dtype('float64'), dtype('float64'), dtype('int32'),
 dtype('int32'), dtype('int32'), dtype('int32'), dtype('int32'),
 dtype('int32')]\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__iotools_af689452c5a1f47d2895282ea83483a6b}\label{namespacenumpy_1_1lib_1_1__iotools_af689452c5a1f47d2895282ea83483a6b} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!has\_nested\_fields@{has\_nested\_fields}}
\index{has\_nested\_fields@{has\_nested\_fields}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{has\_nested\_fields()}{has\_nested\_fields()}}
{\footnotesize\ttfamily has\+\_\+nested\+\_\+fields (\begin{DoxyParamCaption}\item[{}]{ndtype }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns whether one or several fields of a dtype are nested.

Parameters
----------
ndtype : dtype
    Data-type of a structured array.

Raises
------
AttributeError
    If `ndtype` does not have a `names` attribute.

Examples
--------
>>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float)])
>>> np.lib._iotools.has_nested_fields(dt)
False\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a2b8f762ba60384b0c65e8036e7e35d0b}\label{namespacenumpy_1_1lib_1_1__iotools_a2b8f762ba60384b0c65e8036e7e35d0b} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!str2bool@{str2bool}}
\index{str2bool@{str2bool}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{str2bool()}{str2bool()}}
{\footnotesize\ttfamily str2bool (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Tries to transform a string supposed to represent a boolean to a boolean.

Parameters
----------
value : str
    The string that is transformed to a boolean.

Returns
-------
boolval : bool
    The boolean representation of `value`.

Raises
------
ValueError
    If the string is not 'True' or 'False' (case independent)

Examples
--------
>>> np.lib._iotools.str2bool('TRUE')
True
>>> np.lib._iotools.str2bool('false')
False\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_aa3c0e7a8f2695defce5d510420b4f347}\label{namespacenumpy_1_1lib_1_1__iotools_aa3c0e7a8f2695defce5d510420b4f347} 
\index{numpy.lib.\_iotools@{numpy.lib.\_iotools}!unicode@{unicode}}
\index{unicode@{unicode}!numpy.lib.\_iotools@{numpy.lib.\_iotools}}
\doxysubsubsection{\texorpdfstring{unicode}{unicode}}
{\footnotesize\ttfamily unicode = str}

