\doxysection{numpy.\+core.\+arrayprint Namespace Reference}
\hypertarget{namespacenumpy_1_1core_1_1arrayprint}{}\label{namespacenumpy_1_1core_1_1arrayprint}\index{numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1___timelike_format}{\+\_\+\+Timelike\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_bool_format}{Bool\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_complex_floating_format}{Complex\+Floating\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_complex_format}{Complex\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_datetime_format}{Datetime\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_float_format}{Float\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_floating_format}{Floating\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_integer_format}{Integer\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_long_complex_format}{Long\+Complex\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_long_float_format}{Long\+Float\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_structured_void_format}{Structured\+Void\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_structure_format}{Structure\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_sub_array_format}{Sub\+Array\+Format}}
\item 
class \mbox{\hyperlink{classnumpy_1_1core_1_1arrayprint_1_1_timedelta_format}{Timedelta\+Format}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_af528a0ef83670800d0921f66a9011c92}{\+\_\+make\+\_\+options\+\_\+dict}} (precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, sign=None, formatter=None, floatmode=None, legacy=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_aa784fe34c238c9acfa37264f7bf6a915}{set\+\_\+printoptions}} (precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None, sign=None, floatmode=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwarg)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_aeafa82df35fc4235f950b24c4387c1cc}{get\+\_\+printoptions}} ()
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a5cc274f3817e2afdcd0e2ff664c17310}{printoptions}} (\texorpdfstring{$\ast$}{*}args, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a3b474f2a395c4ac749cce777a659ae57}{\+\_\+leading\+\_\+trailing}} (a, edgeitems, index=())
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_ae9d2d5af3ae6f148aff49641d874fb44}{\+\_\+object\+\_\+format}} (o)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a34fd6f2f6297e4afa9fe2ac79a68170d}{repr\+\_\+format}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_ae9296a2445550b4425d4ee9877a51e2d}{str\+\_\+format}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a6570260e3618c0e9a56e96eab4f1c879}{\+\_\+get\+\_\+formatdict}} (data, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}opt)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a58c03006fb50f5105f2aafef9e8228a1}{\+\_\+get\+\_\+format\+\_\+function}} (data, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}options)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a6629b4cf734761796d030aa7523b9ed5}{\+\_\+recursive\+\_\+guard}} (fillvalue=\textquotesingle{}...\textquotesingle{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a9d031b7f68ac80c7befd16b91e137a97}{\+\_\+array2string}} (a, options, separator=\textquotesingle{} \textquotesingle{}, prefix="{}"{})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a2029f270fe1016b21768022282ef878b}{array2string}} (a, max\+\_\+line\+\_\+width=None, precision=None, suppress\+\_\+small=None, separator=\textquotesingle{} \textquotesingle{}, prefix="{}"{}, style=np.\+\_\+\+No\+Value, formatter=None, threshold=None, edgeitems=None, sign=None, floatmode=None, suffix="{}"{}, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwarg)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a274127dbe2c33c768028261d9ef8a7e3}{\+\_\+extend\+Line}} (s, line, word, line\+\_\+width, next\+\_\+line\+\_\+prefix, legacy)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_ab99c94b0dca7544b2a4bd861bf016d98}{\+\_\+format\+Array}} (a, format\+\_\+function, line\+\_\+width, next\+\_\+line\+\_\+prefix, separator, edge\+\_\+items, summary\+\_\+insert, legacy)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a834e583ebedbb042410abe26369228e6}{\+\_\+none\+\_\+or\+\_\+positive\+\_\+arg}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, name)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_ad21224cd86eac22171118f34f5a24311}{format\+\_\+float\+\_\+scientific}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, precision=None, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a350d02d0f9d40999067311aaf8f38fb9}{unique}}=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, trim=\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_adc468c70fb574ebd07287b38d0d0676d}{k}}\textquotesingle{}, sign=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, pad\+\_\+left=None, exp\+\_\+digits=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_aa0e46b8bc88eaba0f1a47d725a93db6b}{format\+\_\+float\+\_\+positional}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}}, precision=None, \mbox{\hyperlink{namespacenumpy_1_1lib_1_1arraysetops_a350d02d0f9d40999067311aaf8f38fb9}{unique}}=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, fractional=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}, trim=\textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_adc468c70fb574ebd07287b38d0d0676d}{k}}\textquotesingle{}, sign=\mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}, pad\+\_\+left=None, pad\+\_\+right=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_af980c41613faedfd82aea9c8c4fdde58}{\+\_\+void\+\_\+scalar\+\_\+repr}} (\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_a9336ebf25087d91c818ee6e9ec29f8c1}{x}})
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a690c9b0d0fc9bfb7627552fb07f282de}{dtype\+\_\+is\+\_\+implied}} (dtype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a0fd82872a9319e87771a1db268e6dfb8}{dtype\+\_\+short\+\_\+repr}} (dtype)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a5a5a2108449ecc5df3fb5badf651bc38}{array\+\_\+repr}} (arr, max\+\_\+line\+\_\+width=None, precision=None, suppress\+\_\+small=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a2c410cc8781059daeeed7dd115fc0cb7}{array\+\_\+str}} (a, max\+\_\+line\+\_\+width=None, precision=None, suppress\+\_\+small=None)
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_aff06c1fd4c22c1e0e3b294fd5e9bd4df}{set\+\_\+string\+\_\+function}} (f, repr=\mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
dict \mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a1048e963b71d39326e6c56387bad0f73}{\+\_\+format\+\_\+options}}
\item 
list \mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a8615520c713272a87aee4e26ceecacd5}{\+\_\+typelessdata}} = \mbox{[}int\+\_\+, float\+\_\+, complex\+\_\+, bool\+\_\+\mbox{]}
\item 
\mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_aa968c2afd15f6c3fc1d34e8884154c89}{\+\_\+guarded\+\_\+str}} = \mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a6629b4cf734761796d030aa7523b9ed5}{\+\_\+recursive\+\_\+guard}}()(str)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Array printing function

$Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a9d031b7f68ac80c7befd16b91e137a97}\label{namespacenumpy_1_1core_1_1arrayprint_a9d031b7f68ac80c7befd16b91e137a97} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_array2string@{\_array2string}}
\index{\_array2string@{\_array2string}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_array2string()}{\_array2string()}}
{\footnotesize\ttfamily \+\_\+array2string (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{options,  }\item[{}]{separator = {\ttfamily \textquotesingle{}~\textquotesingle{}},  }\item[{}]{prefix = {\ttfamily "{}"{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a274127dbe2c33c768028261d9ef8a7e3}\label{namespacenumpy_1_1core_1_1arrayprint_a274127dbe2c33c768028261d9ef8a7e3} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_extendLine@{\_extendLine}}
\index{\_extendLine@{\_extendLine}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_extendLine()}{\_extendLine()}}
{\footnotesize\ttfamily \+\_\+extend\+Line (\begin{DoxyParamCaption}\item[{}]{s,  }\item[{}]{line,  }\item[{}]{word,  }\item[{}]{line\+\_\+width,  }\item[{}]{next\+\_\+line\+\_\+prefix,  }\item[{}]{legacy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_ab99c94b0dca7544b2a4bd861bf016d98}\label{namespacenumpy_1_1core_1_1arrayprint_ab99c94b0dca7544b2a4bd861bf016d98} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_formatArray@{\_formatArray}}
\index{\_formatArray@{\_formatArray}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_formatArray()}{\_formatArray()}}
{\footnotesize\ttfamily \+\_\+format\+Array (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{format\+\_\+function,  }\item[{}]{line\+\_\+width,  }\item[{}]{next\+\_\+line\+\_\+prefix,  }\item[{}]{separator,  }\item[{}]{edge\+\_\+items,  }\item[{}]{summary\+\_\+insert,  }\item[{}]{legacy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}formatArray is designed for two modes of operation:

1. Full output

2. Summarized output\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a58c03006fb50f5105f2aafef9e8228a1}\label{namespacenumpy_1_1core_1_1arrayprint_a58c03006fb50f5105f2aafef9e8228a1} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_get\_format\_function@{\_get\_format\_function}}
\index{\_get\_format\_function@{\_get\_format\_function}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_get\_format\_function()}{\_get\_format\_function()}}
{\footnotesize\ttfamily \+\_\+get\+\_\+format\+\_\+function (\begin{DoxyParamCaption}\item[{}]{data,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{options }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}find the right formatting function for the dtype_
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a6570260e3618c0e9a56e96eab4f1c879}\label{namespacenumpy_1_1core_1_1arrayprint_a6570260e3618c0e9a56e96eab4f1c879} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_get\_formatdict@{\_get\_formatdict}}
\index{\_get\_formatdict@{\_get\_formatdict}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_get\_formatdict()}{\_get\_formatdict()}}
{\footnotesize\ttfamily \+\_\+get\+\_\+formatdict (\begin{DoxyParamCaption}\item[{}]{data,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{opt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a3b474f2a395c4ac749cce777a659ae57}\label{namespacenumpy_1_1core_1_1arrayprint_a3b474f2a395c4ac749cce777a659ae57} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_leading\_trailing@{\_leading\_trailing}}
\index{\_leading\_trailing@{\_leading\_trailing}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_leading\_trailing()}{\_leading\_trailing()}}
{\footnotesize\ttfamily \+\_\+leading\+\_\+trailing (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{edgeitems,  }\item[{}]{index = {\ttfamily ()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Keep only the N-D corners (leading and trailing edges) of an array.

Should be passed a base-class ndarray, since it makes no guarantees about
preserving subclasses.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_af528a0ef83670800d0921f66a9011c92}\label{namespacenumpy_1_1core_1_1arrayprint_af528a0ef83670800d0921f66a9011c92} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_make\_options\_dict@{\_make\_options\_dict}}
\index{\_make\_options\_dict@{\_make\_options\_dict}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_make\_options\_dict()}{\_make\_options\_dict()}}
{\footnotesize\ttfamily \+\_\+make\+\_\+options\+\_\+dict (\begin{DoxyParamCaption}\item[{}]{precision = {\ttfamily None},  }\item[{}]{threshold = {\ttfamily None},  }\item[{}]{edgeitems = {\ttfamily None},  }\item[{}]{linewidth = {\ttfamily None},  }\item[{}]{suppress = {\ttfamily None},  }\item[{}]{nanstr = {\ttfamily None},  }\item[{}]{infstr = {\ttfamily None},  }\item[{}]{sign = {\ttfamily None},  }\item[{}]{formatter = {\ttfamily None},  }\item[{}]{floatmode = {\ttfamily None},  }\item[{}]{legacy = {\ttfamily None} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb} make a dictionary out of the non-None arguments, plus sanity checks \end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a834e583ebedbb042410abe26369228e6}\label{namespacenumpy_1_1core_1_1arrayprint_a834e583ebedbb042410abe26369228e6} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_none\_or\_positive\_arg@{\_none\_or\_positive\_arg}}
\index{\_none\_or\_positive\_arg@{\_none\_or\_positive\_arg}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_none\_or\_positive\_arg()}{\_none\_or\_positive\_arg()}}
{\footnotesize\ttfamily \+\_\+none\+\_\+or\+\_\+positive\+\_\+arg (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_ae9d2d5af3ae6f148aff49641d874fb44}\label{namespacenumpy_1_1core_1_1arrayprint_ae9d2d5af3ae6f148aff49641d874fb44} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_object\_format@{\_object\_format}}
\index{\_object\_format@{\_object\_format}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_object\_format()}{\_object\_format()}}
{\footnotesize\ttfamily \+\_\+object\+\_\+format (\begin{DoxyParamCaption}\item[{}]{o }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb} Object arrays containing lists should be printed unambiguously \end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a6629b4cf734761796d030aa7523b9ed5}\label{namespacenumpy_1_1core_1_1arrayprint_a6629b4cf734761796d030aa7523b9ed5} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_recursive\_guard@{\_recursive\_guard}}
\index{\_recursive\_guard@{\_recursive\_guard}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_recursive\_guard()}{\_recursive\_guard()}}
{\footnotesize\ttfamily \+\_\+recursive\+\_\+guard (\begin{DoxyParamCaption}\item[{}]{fillvalue = {\ttfamily \textquotesingle{}...\textquotesingle{}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Like the python 3.2 reprlib.recursive_repr, but forwards *args and **kwargs

Decorates a function such that if it calls itself with the same first
argument, it returns `fillvalue` instead of recursing.

Largely copied from reprlib.recursive_repr
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_af980c41613faedfd82aea9c8c4fdde58}\label{namespacenumpy_1_1core_1_1arrayprint_af980c41613faedfd82aea9c8c4fdde58} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_void\_scalar\_repr@{\_void\_scalar\_repr}}
\index{\_void\_scalar\_repr@{\_void\_scalar\_repr}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_void\_scalar\_repr()}{\_void\_scalar\_repr()}}
{\footnotesize\ttfamily \+\_\+void\+\_\+scalar\+\_\+repr (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Implements the repr for structured-void scalars. It is called from the
scalartypes.c.src code, and is placed here because it uses the elementwise
formatters defined above.
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a2029f270fe1016b21768022282ef878b}\label{namespacenumpy_1_1core_1_1arrayprint_a2029f270fe1016b21768022282ef878b} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!array2string@{array2string}}
\index{array2string@{array2string}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{array2string()}{array2string()}}
{\footnotesize\ttfamily array2string (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{max\+\_\+line\+\_\+width = {\ttfamily None},  }\item[{}]{precision = {\ttfamily None},  }\item[{}]{suppress\+\_\+small = {\ttfamily None},  }\item[{}]{separator = {\ttfamily \textquotesingle{}~\textquotesingle{}},  }\item[{}]{prefix = {\ttfamily "{}"{}},  }\item[{}]{style = {\ttfamily np.\+\_\+NoValue},  }\item[{}]{formatter = {\ttfamily None},  }\item[{}]{threshold = {\ttfamily None},  }\item[{}]{edgeitems = {\ttfamily None},  }\item[{}]{sign = {\ttfamily None},  }\item[{}]{floatmode = {\ttfamily None},  }\item[{}]{suffix = {\ttfamily "{}"{}},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwarg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a string representation of an array.

Parameters
----------
a : array_like
    Input array.
max_line_width : int, optional
    The maximum number of columns the string should span. Newline
    characters splits the string appropriately after array elements.
precision : int or None, optional
    Floating point precision. Default is the current printing
    precision (usually 8), which can be altered using `set_printoptions`.
suppress_small : bool, optional
    Represent very small numbers as zero. A number is "very small" if it
    is smaller than the current printing precision.
separator : str, optional
    Inserted between elements.
prefix : str, optional
suffix: str, optional
    The length of the prefix and suffix strings are used to respectively
    align and wrap the output. An array is typically printed as::

      prefix + array2string(a) + suffix

    The output is left-padded by the length of the prefix string, and
    wrapping is forced at the column ``max_line_width - len(suffix)``.
style : _NoValue, optional
    Has no effect, do not use.

    .. deprecated:: 1.14.0
formatter : dict of callables, optional
    If not None, the keys should indicate the type(s) that the respective
    formatting function applies to.  Callables should return a string.
    Types that are not specified (by their corresponding keys) are handled
    by the default formatters.  Individual types for which a formatter
    can be set are:

    - 'bool'
    - 'int'
    - 'timedelta' : a `numpy.timedelta64`
    - 'datetime' : a `numpy.datetime64`
    - 'float'
    - 'longfloat' : 128-bit floats
    - 'complexfloat'
    - 'longcomplexfloat' : composed of two 128-bit floats
    - 'void' : type `numpy.void`
    - 'numpystr' : types `numpy.string_` and `numpy.unicode_`
    - 'str' : all other strings

    Other keys that can be used to set a group of types at once are:

    - 'all' : sets all types
    - 'int_kind' : sets 'int'
    - 'float_kind' : sets 'float' and 'longfloat'
    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
    - 'str_kind' : sets 'str' and 'numpystr'
threshold : int, optional
    Total number of array elements which trigger summarization
    rather than full repr.
edgeitems : int, optional
    Number of array items in summary at beginning and end of
    each dimension.
sign : string, either '-', '+', or ' ', optional
    Controls printing of the sign of floating-point types. If '+', always
    print the sign of positive values. If ' ', always prints a space
    (whitespace character) in the sign position of positive values.  If
    '-', omit the sign character of positive values.
floatmode : str, optional
    Controls the interpretation of the `precision` option for
    floating-point types. Can take the following values:

    - 'fixed': Always print exactly `precision` fractional digits,
      even if this would print more or fewer digits than
      necessary to specify the value uniquely.
    - 'unique': Print the minimum number of fractional digits necessary
      to represent each value uniquely. Different elements may
      have a different number of digits.  The value of the
      `precision` option is ignored.
    - 'maxprec': Print at most `precision` fractional digits, but if
      an element can be uniquely represented with fewer digits
      only print it with that many.
    - 'maxprec_equal': Print at most `precision` fractional digits,
      but if every element in the array can be uniquely
      represented with an equal number of fewer digits, use that
      many digits for all elements.
legacy : string or `False`, optional
    If set to the string `'1.13'` enables 1.13 legacy printing mode. This
    approximates numpy 1.13 print output by including a space in the sign
    position of floats and different behavior for 0d arrays. If set to
    `False`, disables legacy mode. Unrecognized strings will be ignored
    with a warning for forward compatibility.

    .. versionadded:: 1.14.0

Returns
-------
array_str : str
    String representation of the array.

Raises
------
TypeError
    if a callable in `formatter` does not return a string.

See Also
--------
array_str, array_repr, set_printoptions, get_printoptions

Notes
-----
If a formatter is specified for a certain type, the `precision` keyword is
ignored for that type.

This is a very flexible function; `array_repr` and `array_str` are using
`array2string` internally so keywords with the same name should work
identically in all three functions.

Examples
--------
>>> x = np.array([1e-16,1,2,3])
>>> print(np.array2string(x, precision=2, separator=',',
...                       suppress_small=True))
[ 0., 1., 2., 3.]

>>> x  = np.arange(3.)
>>> np.array2string(x, formatter={'float_kind':lambda x: "%.2f" % x})
'[0.00 1.00 2.00]'

>>> x  = np.arange(3)
>>> np.array2string(x, formatter={'int':lambda x: hex(x)})
'[0x0L 0x1L 0x2L]'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a5a5a2108449ecc5df3fb5badf651bc38}\label{namespacenumpy_1_1core_1_1arrayprint_a5a5a2108449ecc5df3fb5badf651bc38} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!array\_repr@{array\_repr}}
\index{array\_repr@{array\_repr}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{array\_repr()}{array\_repr()}}
{\footnotesize\ttfamily array\+\_\+repr (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{max\+\_\+line\+\_\+width = {\ttfamily None},  }\item[{}]{precision = {\ttfamily None},  }\item[{}]{suppress\+\_\+small = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the string representation of an array.

Parameters
----------
arr : ndarray
    Input array.
max_line_width : int, optional
    The maximum number of columns the string should span. Newline
    characters split the string appropriately after array elements.
precision : int, optional
    Floating point precision. Default is the current printing precision
    (usually 8), which can be altered using `set_printoptions`.
suppress_small : bool, optional
    Represent very small numbers as zero, default is False. Very small
    is defined by `precision`, if the precision is 8 then
    numbers smaller than 5e-9 are represented as zero.

Returns
-------
string : str
  The string representation of an array.

See Also
--------
array_str, array2string, set_printoptions

Examples
--------
>>> np.array_repr(np.array([1,2]))
'array([1, 2])'
>>> np.array_repr(np.ma.array([0.]))
'MaskedArray([ 0.])'
>>> np.array_repr(np.array([], np.int32))
'array([], dtype=int32)'

>>> x = np.array([1e-6, 4e-7, 2, 3])
>>> np.array_repr(x, precision=6, suppress_small=True)
'array([ 0.000001,  0.      ,  2.      ,  3.      ])'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a2c410cc8781059daeeed7dd115fc0cb7}\label{namespacenumpy_1_1core_1_1arrayprint_a2c410cc8781059daeeed7dd115fc0cb7} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!array\_str@{array\_str}}
\index{array\_str@{array\_str}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{array\_str()}{array\_str()}}
{\footnotesize\ttfamily array\+\_\+str (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{max\+\_\+line\+\_\+width = {\ttfamily None},  }\item[{}]{precision = {\ttfamily None},  }\item[{}]{suppress\+\_\+small = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a string representation of the data in an array.

The data in the array is returned as a single string.  This function is
similar to `array_repr`, the difference being that `array_repr` also
returns information on the kind of array and its data type.

Parameters
----------
a : ndarray
    Input array.
max_line_width : int, optional
    Inserts newlines if text is longer than `max_line_width`.  The
    default is, indirectly, 75.
precision : int, optional
    Floating point precision.  Default is the current printing precision
    (usually 8), which can be altered using `set_printoptions`.
suppress_small : bool, optional
    Represent numbers "very close" to zero as zero; default is False.
    Very close is defined by precision: if the precision is 8, e.g.,
    numbers smaller (in absolute value) than 5e-9 are represented as
    zero.

See Also
--------
array2string, array_repr, set_printoptions

Examples
--------
>>> np.array_str(np.arange(3))
'[0 1 2]'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a690c9b0d0fc9bfb7627552fb07f282de}\label{namespacenumpy_1_1core_1_1arrayprint_a690c9b0d0fc9bfb7627552fb07f282de} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!dtype\_is\_implied@{dtype\_is\_implied}}
\index{dtype\_is\_implied@{dtype\_is\_implied}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{dtype\_is\_implied()}{dtype\_is\_implied()}}
{\footnotesize\ttfamily dtype\+\_\+is\+\_\+implied (\begin{DoxyParamCaption}\item[{}]{dtype }\end{DoxyParamCaption})}

\begin{DoxyVerb}Determine if the given dtype is implied by the representation of its values.

Parameters
----------
dtype : dtype
    Data type

Returns
-------
implied : bool
    True if the dtype is implied by the representation of its values.

Examples
--------
>>> np.core.arrayprint.dtype_is_implied(int)
True
>>> np.array([1, 2, 3], int)
array([1, 2, 3])
>>> np.core.arrayprint.dtype_is_implied(np.int8)
False
>>> np.array([1, 2, 3], np.int8)
array([1, 2, 3], dtype=np.int8)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a0fd82872a9319e87771a1db268e6dfb8}\label{namespacenumpy_1_1core_1_1arrayprint_a0fd82872a9319e87771a1db268e6dfb8} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!dtype\_short\_repr@{dtype\_short\_repr}}
\index{dtype\_short\_repr@{dtype\_short\_repr}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{dtype\_short\_repr()}{dtype\_short\_repr()}}
{\footnotesize\ttfamily dtype\+\_\+short\+\_\+repr (\begin{DoxyParamCaption}\item[{}]{dtype }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert a dtype to a short form which evaluates to the same dtype.

The intent is roughly that the following holds

>>> from numpy import *
>>> assert eval(dtype_short_repr(dt)) == dt
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_aa0e46b8bc88eaba0f1a47d725a93db6b}\label{namespacenumpy_1_1core_1_1arrayprint_aa0e46b8bc88eaba0f1a47d725a93db6b} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!format\_float\_positional@{format\_float\_positional}}
\index{format\_float\_positional@{format\_float\_positional}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{format\_float\_positional()}{format\_float\_positional()}}
{\footnotesize\ttfamily format\+\_\+float\+\_\+positional (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{precision = {\ttfamily None},  }\item[{}]{unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{fractional = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{trim = {\ttfamily \textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_adc468c70fb574ebd07287b38d0d0676d}{k}}\textquotesingle{}},  }\item[{}]{sign = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{pad\+\_\+left = {\ttfamily None},  }\item[{}]{pad\+\_\+right = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Format a floating-point scalar as a decimal string in positional notation.

Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the "Dragon4" algorithm.

Parameters
----------
x : python float or numpy floating scalar
    Value to format.
precision : non-negative integer or None, optional
    Maximum number of digits to print. May be None if `unique` is
    `True`, but must be an integer if unique is `False`.
unique : boolean, optional
    If `True`, use a digit-generation strategy which gives the shortest
    representation which uniquely identifies the floating-point number from
    other values of the same type, by judicious rounding. If `precision`
    was omitted, print out all necessary digits, otherwise digit generation
    is cut off after `precision` digits and the remaining value is rounded.
    If `False`, digits are generated as if printing an infinite-precision
    value and stopping after `precision` digits, rounding the remaining
    value.
fractional : boolean, optional
    If `True`, the cutoff of `precision` digits refers to the total number
    of digits after the decimal point, including leading zeros.
    If `False`, `precision` refers to the total number of significant
    digits, before or after the decimal point, ignoring leading zeros.
trim : one of 'k', '.', '0', '-', optional
    Controls post-processing trimming of trailing digits, as follows:

    * 'k' : keep trailing zeros, keep decimal point (no trimming)
    * '.' : trim all trailing zeros, leave decimal point
    * '0' : trim all but the zero before the decimal point. Insert the
      zero if it is missing.
    * '-' : trim trailing zeros and any trailing decimal point
sign : boolean, optional
    Whether to show the sign for positive values.
pad_left : non-negative integer, optional
    Pad the left side of the string with whitespace until at least that
    many characters are to the left of the decimal point.
pad_right : non-negative integer, optional
    Pad the right side of the string with whitespace until at least that
    many characters are to the right of the decimal point.

Returns
-------
rep : string
    The string representation of the floating point value

See Also
--------
format_float_scientific

Examples
--------
>>> np.format_float_positional(np.float32(np.pi))
'3.1415927'
>>> np.format_float_positional(np.float16(np.pi))
'3.14'
>>> np.format_float_positional(np.float16(0.3))
'0.3'
>>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)
'0.3000488281'
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_ad21224cd86eac22171118f34f5a24311}\label{namespacenumpy_1_1core_1_1arrayprint_ad21224cd86eac22171118f34f5a24311} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!format\_float\_scientific@{format\_float\_scientific}}
\index{format\_float\_scientific@{format\_float\_scientific}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{format\_float\_scientific()}{format\_float\_scientific()}}
{\footnotesize\ttfamily format\+\_\+float\+\_\+scientific (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{precision = {\ttfamily None},  }\item[{}]{unique = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}},  }\item[{}]{trim = {\ttfamily \textquotesingle{}\mbox{\hyperlink{namespacenumpy_1_1core_1_1numerictypes_adc468c70fb574ebd07287b38d0d0676d}{k}}\textquotesingle{}},  }\item[{}]{sign = {\ttfamily \mbox{\hyperlink{cxbool_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}},  }\item[{}]{pad\+\_\+left = {\ttfamily None},  }\item[{}]{exp\+\_\+digits = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Format a floating-point scalar as a decimal string in scientific notation.

Provides control over rounding, trimming and padding. Uses and assumes
IEEE unbiased rounding. Uses the "Dragon4" algorithm.

Parameters
----------
x : python float or numpy floating scalar
    Value to format.
precision : non-negative integer or None, optional
    Maximum number of digits to print. May be None if `unique` is
    `True`, but must be an integer if unique is `False`.
unique : boolean, optional
    If `True`, use a digit-generation strategy which gives the shortest
    representation which uniquely identifies the floating-point number from
    other values of the same type, by judicious rounding. If `precision`
    was omitted, print all necessary digits, otherwise digit generation is
    cut off after `precision` digits and the remaining value is rounded.
    If `False`, digits are generated as if printing an infinite-precision
    value and stopping after `precision` digits, rounding the remaining
    value.
trim : one of 'k', '.', '0', '-', optional
    Controls post-processing trimming of trailing digits, as follows:

    * 'k' : keep trailing zeros, keep decimal point (no trimming)
    * '.' : trim all trailing zeros, leave decimal point
    * '0' : trim all but the zero before the decimal point. Insert the
      zero if it is missing.
    * '-' : trim trailing zeros and any trailing decimal point
sign : boolean, optional
    Whether to show the sign for positive values.
pad_left : non-negative integer, optional
    Pad the left side of the string with whitespace until at least that
    many characters are to the left of the decimal point.
exp_digits : non-negative integer, optional
    Pad the exponent with zeros until it contains at least this many digits.
    If omitted, the exponent will be at least 2 digits.

Returns
-------
rep : string
    The string representation of the floating point value

See Also
--------
format_float_positional

Examples
--------
>>> np.format_float_scientific(np.float32(np.pi))
'3.1415927e+00'
>>> s = np.float32(1.23e24)
>>> np.format_float_scientific(s, unique=False, precision=15)
'1.230000071797338e+24'
>>> np.format_float_scientific(s, exp_digits=4)
'1.23e+0024'
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_aeafa82df35fc4235f950b24c4387c1cc}\label{namespacenumpy_1_1core_1_1arrayprint_aeafa82df35fc4235f950b24c4387c1cc} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!get\_printoptions@{get\_printoptions}}
\index{get\_printoptions@{get\_printoptions}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{get\_printoptions()}{get\_printoptions()}}
{\footnotesize\ttfamily get\+\_\+printoptions (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the current print options.

Returns
-------
print_opts : dict
    Dictionary of current print options with keys

      - precision : int
      - threshold : int
      - edgeitems : int
      - linewidth : int
      - suppress : bool
      - nanstr : str
      - infstr : str
      - formatter : dict of callables
      - sign : str

    For a full description of these options, see `set_printoptions`.

See Also
--------
set_printoptions, set_string_function\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a5cc274f3817e2afdcd0e2ff664c17310}\label{namespacenumpy_1_1core_1_1arrayprint_a5cc274f3817e2afdcd0e2ff664c17310} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!printoptions@{printoptions}}
\index{printoptions@{printoptions}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{printoptions()}{printoptions()}}
{\footnotesize\ttfamily printoptions (\begin{DoxyParamCaption}\item[{\texorpdfstring{$\ast$}{*}}]{args,  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Context manager for setting print options.

Set print options for the scope of the `with` block, and restore the old
options at the end. See `set_printoptions` for the full description of
available options.

Examples
--------

>>> with np.printoptions(precision=2):
...     print(np.array([2.0])) / 3
[0.67]

The `as`-clause of the `with`-statement gives the current print options:

>>> with np.printoptions(precision=2) as opts:
...      assert_equal(opts, np.get_printoptions())

See Also
--------
set_printoptions, get_printoptions\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a34fd6f2f6297e4afa9fe2ac79a68170d}\label{namespacenumpy_1_1core_1_1arrayprint_a34fd6f2f6297e4afa9fe2ac79a68170d} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!repr\_format@{repr\_format}}
\index{repr\_format@{repr\_format}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{repr\_format()}{repr\_format()}}
{\footnotesize\ttfamily repr\+\_\+format (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_aa784fe34c238c9acfa37264f7bf6a915}\label{namespacenumpy_1_1core_1_1arrayprint_aa784fe34c238c9acfa37264f7bf6a915} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!set\_printoptions@{set\_printoptions}}
\index{set\_printoptions@{set\_printoptions}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{set\_printoptions()}{set\_printoptions()}}
{\footnotesize\ttfamily set\+\_\+printoptions (\begin{DoxyParamCaption}\item[{}]{precision = {\ttfamily None},  }\item[{}]{threshold = {\ttfamily None},  }\item[{}]{edgeitems = {\ttfamily None},  }\item[{}]{linewidth = {\ttfamily None},  }\item[{}]{suppress = {\ttfamily None},  }\item[{}]{nanstr = {\ttfamily None},  }\item[{}]{infstr = {\ttfamily None},  }\item[{}]{formatter = {\ttfamily None},  }\item[{}]{sign = {\ttfamily None},  }\item[{}]{floatmode = {\ttfamily None},  }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwarg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set printing options.

These options determine the way floating point numbers, arrays and
other NumPy objects are displayed.

Parameters
----------
precision : int or None, optional
    Number of digits of precision for floating point output (default 8).
    May be `None` if `floatmode` is not `fixed`, to print as many digits as
    necessary to uniquely specify the value.
threshold : int, optional
    Total number of array elements which trigger summarization
    rather than full repr (default 1000).
edgeitems : int, optional
    Number of array items in summary at beginning and end of
    each dimension (default 3).
linewidth : int, optional
    The number of characters per line for the purpose of inserting
    line breaks (default 75).
suppress : bool, optional
    If True, always print floating point numbers using fixed point
    notation, in which case numbers equal to zero in the current precision
    will print as zero.  If False, then scientific notation is used when
    absolute value of the smallest number is < 1e-4 or the ratio of the
    maximum absolute value to the minimum is > 1e3. The default is False.
nanstr : str, optional
    String representation of floating point not-a-number (default nan).
infstr : str, optional
    String representation of floating point infinity (default inf).
sign : string, either '-', '+', or ' ', optional
    Controls printing of the sign of floating-point types. If '+', always
    print the sign of positive values. If ' ', always prints a space
    (whitespace character) in the sign position of positive values.  If
    '-', omit the sign character of positive values. (default '-')
formatter : dict of callables, optional
    If not None, the keys should indicate the type(s) that the respective
    formatting function applies to.  Callables should return a string.
    Types that are not specified (by their corresponding keys) are handled
    by the default formatters.  Individual types for which a formatter
    can be set are:

    - 'bool'
    - 'int'
    - 'timedelta' : a `numpy.timedelta64`
    - 'datetime' : a `numpy.datetime64`
    - 'float'
    - 'longfloat' : 128-bit floats
    - 'complexfloat'
    - 'longcomplexfloat' : composed of two 128-bit floats
    - 'numpystr' : types `numpy.string_` and `numpy.unicode_`
    - 'object' : `np.object_` arrays
    - 'str' : all other strings

    Other keys that can be used to set a group of types at once are:

    - 'all' : sets all types
    - 'int_kind' : sets 'int'
    - 'float_kind' : sets 'float' and 'longfloat'
    - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
    - 'str_kind' : sets 'str' and 'numpystr'
floatmode : str, optional
    Controls the interpretation of the `precision` option for
    floating-point types. Can take the following values:

    * 'fixed': Always print exactly `precision` fractional digits,
            even if this would print more or fewer digits than
            necessary to specify the value uniquely.
    * 'unique': Print the minimum number of fractional digits necessary
            to represent each value uniquely. Different elements may
            have a different number of digits. The value of the
            `precision` option is ignored.
    * 'maxprec': Print at most `precision` fractional digits, but if
            an element can be uniquely represented with fewer digits
            only print it with that many.
    * 'maxprec_equal': Print at most `precision` fractional digits,
            but if every element in the array can be uniquely
            represented with an equal number of fewer digits, use that
            many digits for all elements.
legacy : string or `False`, optional
    If set to the string `'1.13'` enables 1.13 legacy printing mode. This
    approximates numpy 1.13 print output by including a space in the sign
    position of floats and different behavior for 0d arrays. If set to
    `False`, disables legacy mode. Unrecognized strings will be ignored
    with a warning for forward compatibility.

    .. versionadded:: 1.14.0

See Also
--------
get_printoptions, set_string_function, array2string

Notes
-----
`formatter` is always reset with a call to `set_printoptions`.

Examples
--------
Floating point precision can be set:

>>> np.set_printoptions(precision=4)
>>> print(np.array([1.123456789]))
[ 1.1235]

Long arrays can be summarised:

>>> np.set_printoptions(threshold=5)
>>> print(np.arange(10))
[0 1 2 ..., 7 8 9]

Small results can be suppressed:

>>> eps = np.finfo(float).eps
>>> x = np.arange(4.)
>>> x**2 - (x + eps)**2
array([ -4.9304e-32,  -4.4409e-16,   0.0000e+00,   0.0000e+00])
>>> np.set_printoptions(suppress=True)
>>> x**2 - (x + eps)**2
array([-0., -0.,  0.,  0.])

A custom formatter can be used to display array elements as desired:

>>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})
>>> x = np.arange(3)
>>> x
array([int: 0, int: -1, int: -2])
>>> np.set_printoptions()  # formatter gets reset
>>> x
array([0, 1, 2])

To put back the default options, you can use:

>>> np.set_printoptions(edgeitems=3,infstr='inf',
... linewidth=75, nanstr='nan', precision=8,
... suppress=False, threshold=1000, formatter=None)
\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_aff06c1fd4c22c1e0e3b294fd5e9bd4df}\label{namespacenumpy_1_1core_1_1arrayprint_aff06c1fd4c22c1e0e3b294fd5e9bd4df} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!set\_string\_function@{set\_string\_function}}
\index{set\_string\_function@{set\_string\_function}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{set\_string\_function()}{set\_string\_function()}}
{\footnotesize\ttfamily set\+\_\+string\+\_\+function (\begin{DoxyParamCaption}\item[{}]{f,  }\item[{}]{repr = {\ttfamily \mbox{\hyperlink{cxbool_8h_add3ca9eefe3b5b754426f51d3043e579}{True}}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set a Python function to be used when pretty printing arrays.

Parameters
----------
f : function or None
    Function to be used to pretty print arrays. The function should expect
    a single array argument and return a string of the representation of
    the array. If None, the function is reset to the default NumPy function
    to print arrays.
repr : bool, optional
    If True (default), the function for pretty printing (``__repr__``)
    is set, if False the function that returns the default string
    representation (``__str__``) is set.

See Also
--------
set_printoptions, get_printoptions

Examples
--------
>>> def pprint(arr):
...     return 'HA! - What are you going to do now?'
...
>>> np.set_string_function(pprint)
>>> a = np.arange(10)
>>> a
HA! - What are you going to do now?
>>> print(a)
[0 1 2 3 4 5 6 7 8 9]

We can reset the function to the default:

>>> np.set_string_function(None)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

`repr` affects either pretty printing or normal string representation.
Note that ``__repr__`` is still affected by setting ``__str__``
because the width of each array element in the returned string becomes
equal to the length of the result of ``__str__()``.

>>> x = np.arange(4)
>>> np.set_string_function(lambda x:'random', repr=False)
>>> x.__str__()
'random'
>>> x.__repr__()
'array([     0,      1,      2,      3])'\end{DoxyVerb}
 \Hypertarget{namespacenumpy_1_1core_1_1arrayprint_ae9296a2445550b4425d4ee9877a51e2d}\label{namespacenumpy_1_1core_1_1arrayprint_ae9296a2445550b4425d4ee9877a51e2d} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!str\_format@{str\_format}}
\index{str\_format@{str\_format}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{str\_format()}{str\_format()}}
{\footnotesize\ttfamily str\+\_\+format (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}



\doxysubsection{Variable Documentation}
\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a1048e963b71d39326e6c56387bad0f73}\label{namespacenumpy_1_1core_1_1arrayprint_a1048e963b71d39326e6c56387bad0f73} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_format\_options@{\_format\_options}}
\index{\_format\_options@{\_format\_options}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_format\_options}{\_format\_options}}
{\footnotesize\ttfamily dict \+\_\+format\+\_\+options\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \{}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{'edgeitems'}:\ 3,\ \ \textcolor{comment}{\#\ repr\ N\ leading\ and\ trailing\ items\ of\ each\ dimension}}
\DoxyCodeLine{00003\ \ \ \ \ \textcolor{stringliteral}{'threshold'}:\ 1000,\ \ \textcolor{comment}{\#\ total\ items\ >\ triggers\ array\ summarization}}
\DoxyCodeLine{00004\ \ \ \ \ \textcolor{stringliteral}{'floatmode'}:\ \textcolor{stringliteral}{'maxprec'},}
\DoxyCodeLine{00005\ \ \ \ \ \textcolor{stringliteral}{'precision'}:\ 8,\ \ \textcolor{comment}{\#\ precision\ of\ floating\ point\ representations}}
\DoxyCodeLine{00006\ \ \ \ \ \textcolor{stringliteral}{'suppress'}:\ \textcolor{keyword}{False},\ \ \textcolor{comment}{\#\ suppress\ printing\ small\ floating\ values\ in\ exp\ format}}
\DoxyCodeLine{00007\ \ \ \ \ \textcolor{stringliteral}{'linewidth'}:\ 75,}
\DoxyCodeLine{00008\ \ \ \ \ \textcolor{stringliteral}{'nanstr'}:\ \textcolor{stringliteral}{'nan'},}
\DoxyCodeLine{00009\ \ \ \ \ \textcolor{stringliteral}{'infstr'}:\ \textcolor{stringliteral}{'inf'},}
\DoxyCodeLine{00010\ \ \ \ \ \textcolor{stringliteral}{'sign'}:\ \textcolor{stringliteral}{'-\/'},}
\DoxyCodeLine{00011\ \ \ \ \ \textcolor{stringliteral}{'formatter'}:\ \textcolor{keywordtype}{None},}
\DoxyCodeLine{00012\ \ \ \ \ \textcolor{stringliteral}{'legacy'}:\ \textcolor{keyword}{False}\}}

\end{DoxyCode}
\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_aa968c2afd15f6c3fc1d34e8884154c89}\label{namespacenumpy_1_1core_1_1arrayprint_aa968c2afd15f6c3fc1d34e8884154c89} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_guarded\_str@{\_guarded\_str}}
\index{\_guarded\_str@{\_guarded\_str}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_guarded\_str}{\_guarded\_str}}
{\footnotesize\ttfamily \+\_\+guarded\+\_\+str = \mbox{\hyperlink{namespacenumpy_1_1core_1_1arrayprint_a6629b4cf734761796d030aa7523b9ed5}{\+\_\+recursive\+\_\+guard}}()(str)\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespacenumpy_1_1core_1_1arrayprint_a8615520c713272a87aee4e26ceecacd5}\label{namespacenumpy_1_1core_1_1arrayprint_a8615520c713272a87aee4e26ceecacd5} 
\index{numpy.core.arrayprint@{numpy.core.arrayprint}!\_typelessdata@{\_typelessdata}}
\index{\_typelessdata@{\_typelessdata}!numpy.core.arrayprint@{numpy.core.arrayprint}}
\doxysubsubsection{\texorpdfstring{\_typelessdata}{\_typelessdata}}
{\footnotesize\ttfamily list \+\_\+typelessdata = \mbox{[}int\+\_\+, float\+\_\+, complex\+\_\+, bool\+\_\+\mbox{]}\hspace{0.3cm}{\ttfamily [protected]}}

