<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fluent UDF 2020R1: numpy.lib.recfunctions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Fluent UDF 2020R1<span id="projectnumber">&#160;0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacenumpy_1_1lib_1_1recfunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.recfunctions Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a90b50d674651a19e404d8917e43bd985" id="r_a90b50d674651a19e404d8917e43bd985"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a90b50d674651a19e404d8917e43bd985">recursive_fill_fields</a> (input, output)</td></tr>
<tr class="separator:a90b50d674651a19e404d8917e43bd985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af709e9de74755d60f4246b740859b5b2" id="r_af709e9de74755d60f4246b740859b5b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#af709e9de74755d60f4246b740859b5b2">get_fieldspec</a> (dtype)</td></tr>
<tr class="separator:af709e9de74755d60f4246b740859b5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bca600002a39b43f29bcea9d6afe127" id="r_a9bca600002a39b43f29bcea9d6afe127"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a9bca600002a39b43f29bcea9d6afe127">get_names</a> (adtype)</td></tr>
<tr class="separator:a9bca600002a39b43f29bcea9d6afe127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95eb68b91b34d343f3f0403516997c95" id="r_a95eb68b91b34d343f3f0403516997c95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a95eb68b91b34d343f3f0403516997c95">get_names_flat</a> (adtype)</td></tr>
<tr class="separator:a95eb68b91b34d343f3f0403516997c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c17836e29b5e2c3eb28bd4c67e6f8a" id="r_a07c17836e29b5e2c3eb28bd4c67e6f8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a07c17836e29b5e2c3eb28bd4c67e6f8a">flatten_descr</a> (ndtype)</td></tr>
<tr class="separator:a07c17836e29b5e2c3eb28bd4c67e6f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce38664bd357367b7bc99b1efbe85b7" id="r_a3ce38664bd357367b7bc99b1efbe85b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a3ce38664bd357367b7bc99b1efbe85b7">zip_dtype</a> (seqarrays, <a class="el" href="size_2foo_8f90.html#a5b6fedc75d027f2d0e1cea960deeec4e">flatten</a>=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a3ce38664bd357367b7bc99b1efbe85b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7eea4fc4db2ee34ab760e7282de6ad" id="r_abc7eea4fc4db2ee34ab760e7282de6ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#abc7eea4fc4db2ee34ab760e7282de6ad">zip_descr</a> (seqarrays, <a class="el" href="size_2foo_8f90.html#a5b6fedc75d027f2d0e1cea960deeec4e">flatten</a>=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:abc7eea4fc4db2ee34ab760e7282de6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1161a47ec16bfa06e2c329f0f0afdb" id="r_a8c1161a47ec16bfa06e2c329f0f0afdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a8c1161a47ec16bfa06e2c329f0f0afdb">get_fieldstructure</a> (adtype, lastname=None, parents=None)</td></tr>
<tr class="separator:a8c1161a47ec16bfa06e2c329f0f0afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ebf42e008262928084eb345c7e4ec0" id="r_a49ebf42e008262928084eb345c7e4ec0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a49ebf42e008262928084eb345c7e4ec0">_izip_fields_flat</a> (<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af2a0c70951e6a07c4ce9feac3cbd9a3e">iterable</a>)</td></tr>
<tr class="separator:a49ebf42e008262928084eb345c7e4ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf1627b0c26fc691797cd162ff1ea0a" id="r_abdf1627b0c26fc691797cd162ff1ea0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#abdf1627b0c26fc691797cd162ff1ea0a">_izip_fields</a> (<a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#af2a0c70951e6a07c4ce9feac3cbd9a3e">iterable</a>)</td></tr>
<tr class="separator:abdf1627b0c26fc691797cd162ff1ea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bbb9c215f9a6d1730be0f32d72b886" id="r_a32bbb9c215f9a6d1730be0f32d72b886"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a32bbb9c215f9a6d1730be0f32d72b886">izip_records</a> (seqarrays, fill_value=None, <a class="el" href="size_2foo_8f90.html#a5b6fedc75d027f2d0e1cea960deeec4e">flatten</a>=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>)</td></tr>
<tr class="separator:a32bbb9c215f9a6d1730be0f32d72b886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4e9d9e56ed4c7790aa30fdb22e7a48" id="r_aee4e9d9e56ed4c7790aa30fdb22e7a48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aee4e9d9e56ed4c7790aa30fdb22e7a48">_fix_output</a> (output, usemask=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, asrecarray=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:aee4e9d9e56ed4c7790aa30fdb22e7a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d45a9889d635f5c9d328235818e1b27" id="r_a8d45a9889d635f5c9d328235818e1b27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a8d45a9889d635f5c9d328235818e1b27">_fix_defaults</a> (output, defaults=None)</td></tr>
<tr class="separator:a8d45a9889d635f5c9d328235818e1b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a638a3e1287a8fc39125c44eb730d4" id="r_a97a638a3e1287a8fc39125c44eb730d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a97a638a3e1287a8fc39125c44eb730d4">merge_arrays</a> (seqarrays, fill_value=-1, <a class="el" href="size_2foo_8f90.html#a5b6fedc75d027f2d0e1cea960deeec4e">flatten</a>=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>, usemask=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>, asrecarray=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a97a638a3e1287a8fc39125c44eb730d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209573accec22b499d43122518b09165" id="r_a209573accec22b499d43122518b09165"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a209573accec22b499d43122518b09165">drop_fields</a> (base, drop_names, usemask=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, asrecarray=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a209573accec22b499d43122518b09165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2944e386580ae41f3af6e31ec1b0fb49" id="r_a2944e386580ae41f3af6e31ec1b0fb49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a2944e386580ae41f3af6e31ec1b0fb49">_keep_fields</a> (base, keep_names, usemask=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, asrecarray=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a2944e386580ae41f3af6e31ec1b0fb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1babb67ed7b583bf9f9938e63b41692d" id="r_a1babb67ed7b583bf9f9938e63b41692d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a1babb67ed7b583bf9f9938e63b41692d">rec_drop_fields</a> (base, drop_names)</td></tr>
<tr class="separator:a1babb67ed7b583bf9f9938e63b41692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be12bd9734f5aef13eac79acb247d78" id="r_a3be12bd9734f5aef13eac79acb247d78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a3be12bd9734f5aef13eac79acb247d78">rename_fields</a> (base, namemapper)</td></tr>
<tr class="separator:a3be12bd9734f5aef13eac79acb247d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc767012cc5df7fa461f59c6168f4bb" id="r_a3cc767012cc5df7fa461f59c6168f4bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a3cc767012cc5df7fa461f59c6168f4bb">append_fields</a> (base, names, data, dtypes=None, fill_value=-1, usemask=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, asrecarray=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a3cc767012cc5df7fa461f59c6168f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c8346c0f836df25f62f98846f62b59" id="r_a47c8346c0f836df25f62f98846f62b59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a47c8346c0f836df25f62f98846f62b59">rec_append_fields</a> (base, names, data, dtypes=None)</td></tr>
<tr class="separator:a47c8346c0f836df25f62f98846f62b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b62d0cc1969274290a81b5b9f1ff8" id="r_ad17b62d0cc1969274290a81b5b9f1ff8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ad17b62d0cc1969274290a81b5b9f1ff8">repack_fields</a> (a, align=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>, recurse=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:ad17b62d0cc1969274290a81b5b9f1ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819642c300a90e0a19d8c9c0e98eb73" id="r_a3819642c300a90e0a19d8c9c0e98eb73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a3819642c300a90e0a19d8c9c0e98eb73">stack_arrays</a> (arrays, defaults=None, usemask=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, asrecarray=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>, autoconvert=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a3819642c300a90e0a19d8c9c0e98eb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee972c7fd36266d344e95818d3740faa" id="r_aee972c7fd36266d344e95818d3740faa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#aee972c7fd36266d344e95818d3740faa">find_duplicates</a> (a, key=None, ignoremask=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, return_index=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:aee972c7fd36266d344e95818d3740faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dac389f0ecd916e1ff105571ea39b4" id="r_a97dac389f0ecd916e1ff105571ea39b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a97dac389f0ecd916e1ff105571ea39b4">join_by</a> (key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None, usemask=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>, asrecarray=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a97dac389f0ecd916e1ff105571ea39b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507b660c03032e0cd2d4b446ef646a7" id="r_a4507b660c03032e0cd2d4b446ef646a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#a4507b660c03032e0cd2d4b446ef646a7">rec_join</a> (key, r1, r2, jointype='inner', r1postfix='1', r2postfix='2', defaults=None)</td></tr>
<tr class="separator:a4507b660c03032e0cd2d4b446ef646a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab29d297a549b7791bd84533ff576e06a" id="r_ab29d297a549b7791bd84533ff576e06a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html#ab29d297a549b7791bd84533ff576e06a">_check_fill_value</a> = np.ma.core._check_fill_value</td></tr>
<tr class="separator:ab29d297a549b7791bd84533ff576e06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Collection of utilities to manipulate structured arrays.

Most of these functions were initially implemented by John Hunter for
matplotlib.  They have been rewritten and extended for convenience.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a8d45a9889d635f5c9d328235818e1b27" name="a8d45a9889d635f5c9d328235818e1b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d45a9889d635f5c9d328235818e1b27">&#9670;&#160;</a></span>_fix_defaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_fix_defaults </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Update the fill_value and masked data of `output`
from the default given in a dictionary defaults.
</pre> 
</div>
</div>
<a id="aee4e9d9e56ed4c7790aa30fdb22e7a48" name="aee4e9d9e56ed4c7790aa30fdb22e7a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4e9d9e56ed4c7790aa30fdb22e7a48">&#9670;&#160;</a></span>_fix_output()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_fix_output </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function: return a recarray, a ndarray, a MaskedArray
or a MaskedRecords depending on the input parameters
</pre> 
</div>
</div>
<a id="abdf1627b0c26fc691797cd162ff1ea0a" name="abdf1627b0c26fc691797cd162ff1ea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf1627b0c26fc691797cd162ff1ea0a">&#9670;&#160;</a></span>_izip_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_izip_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator of concatenated fields from a sequence of arrays.</pre> 
</div>
</div>
<a id="a49ebf42e008262928084eb345c7e4ec0" name="a49ebf42e008262928084eb345c7e4ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ebf42e008262928084eb345c7e4ec0">&#9670;&#160;</a></span>_izip_fields_flat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_izip_fields_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator of concatenated fields from a sequence of arrays,
collapsing any nested structure.</pre> 
</div>
</div>
<a id="a2944e386580ae41f3af6e31ec1b0fb49" name="a2944e386580ae41f3af6e31ec1b0fb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2944e386580ae41f3af6e31ec1b0fb49">&#9670;&#160;</a></span>_keep_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_keep_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a new array keeping only the fields in `keep_names`,
and preserving the order of those fields.

Parameters
----------
base : array
    Input array
keep_names : string or sequence
    String or sequence of strings corresponding to the names of the
    fields to keep. Order of the names will be preserved.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : string or sequence, optional
    Whether to return a recarray or a mrecarray (`asrecarray=True`) or
    a plain ndarray or masked array with flexible dtype. The default
    is False.
</pre> 
</div>
</div>
<a id="a3cc767012cc5df7fa461f59c6168f4bb" name="a3cc767012cc5df7fa461f59c6168f4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc767012cc5df7fa461f59c6168f4bb">&#9670;&#160;</a></span>append_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">append_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtypes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add new fields to an existing array.

The names of the fields are given with the `names` arguments,
the corresponding values with the `data` arguments.
If a single field is appended, `names`, `data` and `dtypes` do not have
to be lists but just values.

Parameters
----------
base : array
    Input array to extend.
names : string, sequence
    String or sequence of strings corresponding to the names
    of the new fields.
data : array or sequence of arrays
    Array or sequence of arrays storing the fields to add to the base.
dtypes : sequence of datatypes, optional
    Datatype or sequence of datatypes.
    If None, the datatypes are estimated from the `data`.
fill_value : {float}, optional
    Filling value used to pad missing data on the shorter arrays.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : {False, True}, optional
    Whether to return a recarray (MaskedRecords) or not.</pre> 
</div>
</div>
<a id="a209573accec22b499d43122518b09165" name="a209573accec22b499d43122518b09165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209573accec22b499d43122518b09165">&#9670;&#160;</a></span>drop_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">drop_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new array with fields in `drop_names` dropped.

Nested fields are supported.

Parameters
----------
base : array
    Input array
drop_names : string or sequence
    String or sequence of strings corresponding to the names of the
    fields to drop.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : string or sequence, optional
    Whether to return a recarray or a mrecarray (`asrecarray=True`) or
    a plain ndarray or masked array with flexible dtype. The default
    is False.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.array([(1, (2, 3.0)), (4, (5, 6.0))],
...   dtype=[('a', int), ('b', [('ba', float), ('bb', int)])])
&gt;&gt;&gt; rfn.drop_fields(a, 'a')
array([((2.0, 3),), ((5.0, 6),)],
      dtype=[('b', [('ba', '&lt;f8'), ('bb', '&lt;i4')])])
&gt;&gt;&gt; rfn.drop_fields(a, 'ba')
array([(1, (3,)), (4, (6,))],
      dtype=[('a', '&lt;i4'), ('b', [('bb', '&lt;i4')])])
&gt;&gt;&gt; rfn.drop_fields(a, ['ba', 'bb'])
array([(1,), (4,)],
      dtype=[('a', '&lt;i4')])
</pre> 
</div>
</div>
<a id="aee972c7fd36266d344e95818d3740faa" name="aee972c7fd36266d344e95818d3740faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee972c7fd36266d344e95818d3740faa">&#9670;&#160;</a></span>find_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">find_duplicates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ignoremask</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_index</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the duplicates in a structured array along a given key

Parameters
----------
a : array-like
    Input array
key : {string, None}, optional
    Name of the fields along which to check the duplicates.
    If None, the search is performed by records
ignoremask : {True, False}, optional
    Whether masked data should be discarded or considered as duplicates.
return_index : {False, True}, optional
    Whether to return the indices of the duplicated values.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; ndtype = [('a', int)]
&gt;&gt;&gt; a = np.ma.array([1, 1, 1, 2, 2, 3, 3],
...         mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype)
&gt;&gt;&gt; rfn.find_duplicates(a, ignoremask=True, return_index=True)
... # XXX: judging by the output, the ignoremask flag has no effect
</pre> 
</div>
</div>
<a id="a07c17836e29b5e2c3eb28bd4c67e6f8a" name="a07c17836e29b5e2c3eb28bd4c67e6f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c17836e29b5e2c3eb28bd4c67e6f8a">&#9670;&#160;</a></span>flatten_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">flatten_descr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flatten a structured data-type description.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; ndtype = np.dtype([('a', '&lt;i4'), ('b', [('ba', '&lt;f8'), ('bb', '&lt;i4')])])
&gt;&gt;&gt; rfn.flatten_descr(ndtype)
(('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32')))</pre> 
</div>
</div>
<a id="af709e9de74755d60f4246b740859b5b2" name="af709e9de74755d60f4246b740859b5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af709e9de74755d60f4246b740859b5b2">&#9670;&#160;</a></span>get_fieldspec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">get_fieldspec </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Produce a list of name/dtype pairs corresponding to the dtype fields

Similar to dtype.descr, but the second item of each tuple is a dtype, not a
string. As a result, this handles subarray dtypes

Can be passed to the dtype constructor to reconstruct the dtype, noting that
this (deliberately) discards field offsets.

Examples
--------
&gt;&gt;&gt; dt = np.dtype([(('a', 'A'), int), ('b', float, 3)])
&gt;&gt;&gt; dt.descr
[(('a', 'A'), '&lt;i4'), ('b', '&lt;f8', (3,))]
&gt;&gt;&gt; get_fieldspec(dt)
[(('a', 'A'), dtype('int32')), ('b', dtype(('&lt;f8', (3,))))]</pre> 
</div>
</div>
<a id="a8c1161a47ec16bfa06e2c329f0f0afdb" name="a8c1161a47ec16bfa06e2c329f0f0afdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1161a47ec16bfa06e2c329f0f0afdb">&#9670;&#160;</a></span>get_fieldstructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">get_fieldstructure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lastname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parents</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a dictionary with fields indexing lists of their parent fields.

This function is used to simplify access to fields nested in other fields.

Parameters
----------
adtype : np.dtype
    Input datatype
lastname : optional
    Last processed field name (used internally during recursion).
parents : dictionary
    Dictionary of parent fields (used interbally during recursion).

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; ndtype =  np.dtype([('A', int),
...                     ('B', [('BA', int),
...                            ('BB', [('BBA', int), ('BBB', int)])])])
&gt;&gt;&gt; rfn.get_fieldstructure(ndtype)
... # XXX: possible regression, order of BBA and BBB is swapped
{'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']}</pre> 
</div>
</div>
<a id="a9bca600002a39b43f29bcea9d6afe127" name="a9bca600002a39b43f29bcea9d6afe127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bca600002a39b43f29bcea9d6afe127">&#9670;&#160;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">get_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the field names of the input datatype as a tuple.

Parameters
----------
adtype : dtype
    Input datatype

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=int)) is None
True
&gt;&gt;&gt; rfn.get_names(np.empty((1,), dtype=[('A',int), ('B', float)]))
('A', 'B')
&gt;&gt;&gt; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])
&gt;&gt;&gt; rfn.get_names(adtype)
('a', ('b', ('ba', 'bb')))
</pre> 
</div>
</div>
<a id="a95eb68b91b34d343f3f0403516997c95" name="a95eb68b91b34d343f3f0403516997c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95eb68b91b34d343f3f0403516997c95">&#9670;&#160;</a></span>get_names_flat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">get_names_flat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the field names of the input datatype as a tuple. Nested structure
are flattend beforehand.

Parameters
----------
adtype : dtype
    Input datatype

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=int)) is None
True
&gt;&gt;&gt; rfn.get_names_flat(np.empty((1,), dtype=[('A',int), ('B', float)]))
('A', 'B')
&gt;&gt;&gt; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])
&gt;&gt;&gt; rfn.get_names_flat(adtype)
('a', 'b', 'ba', 'bb')
</pre> 
</div>
</div>
<a id="a32bbb9c215f9a6d1730be0f32d72b886" name="a32bbb9c215f9a6d1730be0f32d72b886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bbb9c215f9a6d1730be0f32d72b886">&#9670;&#160;</a></span>izip_records()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">izip_records </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator of concatenated items from a sequence of arrays.

Parameters
----------
seqarrays : sequence of arrays
    Sequence of arrays.
fill_value : {None, integer}
    Value used to pad shorter iterables.
flatten : {True, False},
    Whether to
</pre> 
</div>
</div>
<a id="a97dac389f0ecd916e1ff105571ea39b4" name="a97dac389f0ecd916e1ff105571ea39b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dac389f0ecd916e1ff105571ea39b4">&#9670;&#160;</a></span>join_by()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">join_by </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jointype</em> = <code>'inner'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1postfix</em> = <code>'1'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2postfix</em> = <code>'2'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Join arrays `r1` and `r2` on key `key`.

The key should be either a string or a sequence of string corresponding
to the fields used to join the array.  An exception is raised if the
`key` field cannot be found in the two input arrays.  Neither `r1` nor
`r2` should have any duplicates along `key`: the presence of duplicates
will make the output quite unreliable. Note that duplicates are not
looked for by the algorithm.

Parameters
----------
key : {string, sequence}
    A string or a sequence of strings corresponding to the fields used
    for comparison.
r1, r2 : arrays
    Structured arrays.
jointype : {'inner', 'outer', 'leftouter'}, optional
    If 'inner', returns the elements common to both r1 and r2.
    If 'outer', returns the common elements as well as the elements of
    r1 not in r2 and the elements of not in r2.
    If 'leftouter', returns the common elements and the elements of r1
    not in r2.
r1postfix : string, optional
    String appended to the names of the fields of r1 that are present
    in r2 but absent of the key.
r2postfix : string, optional
    String appended to the names of the fields of r2 that are present
    in r1 but absent of the key.
defaults : {dictionary}, optional
    Dictionary mapping field names to the corresponding default values.
usemask : {True, False}, optional
    Whether to return a MaskedArray (or MaskedRecords is
    `asrecarray==True`) or a ndarray.
asrecarray : {False, True}, optional
    Whether to return a recarray (or MaskedRecords if `usemask==True`)
    or just a flexible-type ndarray.

Notes
-----
* The output is sorted along the key.
* A temporary array is formed by dropping the fields not in the key for
  the two arrays and concatenating the result. This array is then
  sorted, and the common entries selected. The output is constructed by
  filling the fields with the selected entries. Matching is not
  preserved if there are some duplicates...</pre> 
</div>
</div>
<a id="a97a638a3e1287a8fc39125c44eb730d4" name="a97a638a3e1287a8fc39125c44eb730d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a638a3e1287a8fc39125c44eb730d4">&#9670;&#160;</a></span>merge_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">merge_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Merge arrays field by field.

Parameters
----------
seqarrays : sequence of ndarrays
    Sequence of arrays
fill_value : {float}, optional
    Filling value used to pad missing data on the shorter arrays.
flatten : {False, True}, optional
    Whether to collapse nested fields.
usemask : {False, True}, optional
    Whether to return a masked array or not.
asrecarray : {False, True}, optional
    Whether to return a recarray (MaskedRecords) or not.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.])))
masked_array(data = [(1, 10.0) (2, 20.0) (--, 30.0)],
             mask = [(False, False) (False, False) (True, False)],
       fill_value = (999999, 1e+20),
            dtype = [('f0', '&lt;i4'), ('f1', '&lt;f8')])

&gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.])),
...              usemask=False)
array([(1, 10.0), (2, 20.0), (-1, 30.0)],
      dtype=[('f0', '&lt;i4'), ('f1', '&lt;f8')])
&gt;&gt;&gt; rfn.merge_arrays((np.array([1, 2]).view([('a', int)]),
...               np.array([10., 20., 30.])),
...              usemask=False, asrecarray=True)
rec.array([(1, 10.0), (2, 20.0), (-1, 30.0)],
          dtype=[('a', '&lt;i4'), ('f1', '&lt;f8')])

Notes
-----
* Without a mask, the missing value will be filled with something,
  depending on what its corresponding type:

  * ``-1``      for integers
  * ``-1.0``    for floating point numbers
  * ``'-'``     for characters
  * ``'-1'``    for strings
  * ``True``    for boolean values
* XXX: I just obtained these values empirically
</pre> 
</div>
</div>
<a id="a47c8346c0f836df25f62f98846f62b59" name="a47c8346c0f836df25f62f98846f62b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c8346c0f836df25f62f98846f62b59">&#9670;&#160;</a></span>rec_append_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rec_append_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtypes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add new fields to an existing array.

The names of the fields are given with the `names` arguments,
the corresponding values with the `data` arguments.
If a single field is appended, `names`, `data` and `dtypes` do not have
to be lists but just values.

Parameters
----------
base : array
    Input array to extend.
names : string, sequence
    String or sequence of strings corresponding to the names
    of the new fields.
data : array or sequence of arrays
    Array or sequence of arrays storing the fields to add to the base.
dtypes : sequence of datatypes, optional
    Datatype or sequence of datatypes.
    If None, the datatypes are estimated from the `data`.

See Also
--------
append_fields

Returns
-------
appended_array : np.recarray
</pre> 
</div>
</div>
<a id="a1babb67ed7b583bf9f9938e63b41692d" name="a1babb67ed7b583bf9f9938e63b41692d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1babb67ed7b583bf9f9938e63b41692d">&#9670;&#160;</a></span>rec_drop_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rec_drop_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a new numpy.recarray with fields in `drop_names` dropped.
</pre> 
</div>
</div>
<a id="a4507b660c03032e0cd2d4b446ef646a7" name="a4507b660c03032e0cd2d4b446ef646a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4507b660c03032e0cd2d4b446ef646a7">&#9670;&#160;</a></span>rec_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rec_join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>jointype</em> = <code>'inner'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r1postfix</em> = <code>'1'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r2postfix</em> = <code>'2'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Join arrays `r1` and `r2` on keys.
Alternative to join_by, that always returns a np.recarray.

See Also
--------
join_by : equivalent function
</pre> 
</div>
</div>
<a id="a90b50d674651a19e404d8917e43bd985" name="a90b50d674651a19e404d8917e43bd985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b50d674651a19e404d8917e43bd985">&#9670;&#160;</a></span>recursive_fill_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">recursive_fill_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fills fields from output with fields from input,
with support for nested structures.

Parameters
----------
input : ndarray
    Input array.
output : ndarray
    Output array.

Notes
-----
* `output` should be at least the same size as `input`

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.array([(1, 10.), (2, 20.)], dtype=[('A', int), ('B', float)])
&gt;&gt;&gt; b = np.zeros((3,), dtype=a.dtype)
&gt;&gt;&gt; rfn.recursive_fill_fields(a, b)
array([(1, 10.0), (2, 20.0), (0, 0.0)],
      dtype=[('A', '&lt;i4'), ('B', '&lt;f8')])</pre> 
</div>
</div>
<a id="a3be12bd9734f5aef13eac79acb247d78" name="a3be12bd9734f5aef13eac79acb247d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be12bd9734f5aef13eac79acb247d78">&#9670;&#160;</a></span>rename_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rename_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>namemapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Rename the fields from a flexible-datatype ndarray or recarray.

Nested fields are supported.

Parameters
----------
base : ndarray
    Input array whose fields must be modified.
namemapper : dictionary
    Dictionary mapping old field names to their new version.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))],
...   dtype=[('a', int),('b', [('ba', float), ('bb', (float, 2))])])
&gt;&gt;&gt; rfn.rename_fields(a, {'a':'A', 'bb':'BB'})
array([(1, (2.0, [3.0, 30.0])), (4, (5.0, [6.0, 60.0]))],
      dtype=[('A', '&lt;i4'), ('b', [('ba', '&lt;f8'), ('BB', '&lt;f8', 2)])])</pre> 
</div>
</div>
<a id="ad17b62d0cc1969274290a81b5b9f1ff8" name="ad17b62d0cc1969274290a81b5b9f1ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17b62d0cc1969274290a81b5b9f1ff8">&#9670;&#160;</a></span>repack_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">repack_fields </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recurse</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Re-pack the fields of a structured array or dtype in memory.

The memory layout of structured datatypes allows fields at arbitrary
byte offsets. This means the fields can be separated by padding bytes,
their offsets can be non-monotonically increasing, and they can overlap.

This method removes any overlaps and reorders the fields in memory so they
have increasing byte offsets, and adds or removes padding bytes depending
on the `align` option, which behaves like the `align` option to `np.dtype`.

If `align=False`, this method produces a "packed" memory layout in which
each field starts at the byte the previous field ended, and any padding
bytes are removed.

If `align=True`, this methods produces an "aligned" memory layout in which
each field's offset is a multiple of its alignment, and the total itemsize
is a multiple of the largest alignment, by adding padding bytes as needed.

Parameters
----------
a : ndarray or dtype
   array or dtype for which to repack the fields.
align : boolean
   If true, use an "aligned" memory layout, otherwise use a "packed" layout.
recurse : boolean
   If True, also repack nested structures.

Returns
-------
repacked : ndarray or dtype
   Copy of `a` with fields repacked, or `a` itself if no repacking was
   needed.

Examples
--------

&gt;&gt;&gt; def print_offsets(d):
...     print("offsets:", [d.fields[name][1] for name in d.names])
...     print("itemsize:", d.itemsize)
...
&gt;&gt;&gt; dt = np.dtype('u1,i4,f4', align=True)
&gt;&gt;&gt; dt
dtype({'names':['f0','f1','f2'], 'formats':['u1','&lt;i4','&lt;f8'], 'offsets':[0,4,8], 'itemsize':16}, align=True)
&gt;&gt;&gt; print_offsets(dt)
offsets: [0, 4, 8]
itemsize: 16
&gt;&gt;&gt; packed_dt = repack_fields(dt)
&gt;&gt;&gt; packed_dt
dtype([('f0', 'u1'), ('f1', '&lt;i4'), ('f2', '&lt;f8')])
&gt;&gt;&gt; print_offsets(packed_dt)
offsets: [0, 1, 5]
itemsize: 13</pre> 
</div>
</div>
<a id="a3819642c300a90e0a19d8c9c0e98eb73" name="a3819642c300a90e0a19d8c9c0e98eb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3819642c300a90e0a19d8c9c0e98eb73">&#9670;&#160;</a></span>stack_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stack_arrays </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>defaults</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>usemask</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>asrecarray</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>autoconvert</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Superposes arrays fields by fields

Parameters
----------
arrays : array or sequence
    Sequence of input arrays.
defaults : dictionary, optional
    Dictionary mapping field names to the corresponding default values.
usemask : {True, False}, optional
    Whether to return a MaskedArray (or MaskedRecords is
    `asrecarray==True`) or a ndarray.
asrecarray : {False, True}, optional
    Whether to return a recarray (or MaskedRecords if `usemask==True`)
    or just a flexible-type ndarray.
autoconvert : {False, True}, optional
    Whether automatically cast the type of the field to the maximum.

Examples
--------
&gt;&gt;&gt; from numpy.lib import recfunctions as rfn
&gt;&gt;&gt; x = np.array([1, 2,])
&gt;&gt;&gt; rfn.stack_arrays(x) is x
True
&gt;&gt;&gt; z = np.array([('A', 1), ('B', 2)], dtype=[('A', '|S3'), ('B', float)])
&gt;&gt;&gt; zz = np.array([('a', 10., 100.), ('b', 20., 200.), ('c', 30., 300.)],
...   dtype=[('A', '|S3'), ('B', float), ('C', float)])
&gt;&gt;&gt; test = rfn.stack_arrays((z,zz))
&gt;&gt;&gt; test
masked_array(data = [('A', 1.0, --) ('B', 2.0, --) ('a', 10.0, 100.0) ('b', 20.0, 200.0)
 ('c', 30.0, 300.0)],
             mask = [(False, False, True) (False, False, True) (False, False, False)
 (False, False, False) (False, False, False)],
       fill_value = ('N/A', 1e+20, 1e+20),
            dtype = [('A', '|S3'), ('B', '&lt;f8'), ('C', '&lt;f8')])</pre> 
</div>
</div>
<a id="abc7eea4fc4db2ee34ab760e7282de6ad" name="abc7eea4fc4db2ee34ab760e7282de6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7eea4fc4db2ee34ab760e7282de6ad">&#9670;&#160;</a></span>zip_descr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zip_descr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Combine the dtype description of a series of arrays.

Parameters
----------
seqarrays : sequence of arrays
    Sequence of arrays
flatten : {boolean}, optional
    Whether to collapse nested descriptions.
</pre> 
</div>
</div>
<a id="a3ce38664bd357367b7bc99b1efbe85b7" name="a3ce38664bd357367b7bc99b1efbe85b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce38664bd357367b7bc99b1efbe85b7">&#9670;&#160;</a></span>zip_dtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zip_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seqarrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flatten</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab29d297a549b7791bd84533ff576e06a" name="ab29d297a549b7791bd84533ff576e06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29d297a549b7791bd84533ff576e06a">&#9670;&#160;</a></span>_check_fill_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_check_fill_value = np.ma.core._check_fill_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1recfunctions.html">recfunctions</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
