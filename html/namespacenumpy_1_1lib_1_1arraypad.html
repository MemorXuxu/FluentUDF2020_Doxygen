<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fluent UDF 2020R1: numpy.lib.arraypad Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Fluent UDF 2020R1<span id="projectnumber">&#160;0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacenumpy_1_1lib_1_1arraypad.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.arraypad Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8c47ee86df8d1805b19b6d9037ac7b87" id="r_a8c47ee86df8d1805b19b6d9037ac7b87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a8c47ee86df8d1805b19b6d9037ac7b87">_arange_ndarray</a> (arr, <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a149f0ed3f02491db0c249840e2aff84f">shape</a>, axis, <a class="el" href="sprim_8h.html#af0ac3203ee4ac7f1978fd034401988f5">reverse</a>=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="memdesc:a8c47ee86df8d1805b19b6d9037ac7b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private utility functions.  <br /></td></tr>
<tr class="separator:a8c47ee86df8d1805b19b6d9037ac7b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a25cbba1748acb00d93d7adeb6f67a" id="r_a59a25cbba1748acb00d93d7adeb6f67a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a59a25cbba1748acb00d93d7adeb6f67a">_round_ifneeded</a> (arr, dtype)</td></tr>
<tr class="separator:a59a25cbba1748acb00d93d7adeb6f67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a39553ec1f7a61c2cf0ab2720572c9" id="r_a65a39553ec1f7a61c2cf0ab2720572c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a65a39553ec1f7a61c2cf0ab2720572c9">_slice_at_axis</a> (<a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a149f0ed3f02491db0c249840e2aff84f">shape</a>, sl, axis)</td></tr>
<tr class="separator:a65a39553ec1f7a61c2cf0ab2720572c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b167ee326b56fe2d2885b29bc77e5c" id="r_aa9b167ee326b56fe2d2885b29bc77e5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#aa9b167ee326b56fe2d2885b29bc77e5c">_slice_first</a> (<a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a149f0ed3f02491db0c249840e2aff84f">shape</a>, n, axis)</td></tr>
<tr class="separator:aa9b167ee326b56fe2d2885b29bc77e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa30fcce2c78a351331363bd1d8687a" id="r_aafa30fcce2c78a351331363bd1d8687a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#aafa30fcce2c78a351331363bd1d8687a">_slice_last</a> (<a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a149f0ed3f02491db0c249840e2aff84f">shape</a>, n, axis)</td></tr>
<tr class="separator:aafa30fcce2c78a351331363bd1d8687a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b93e2942b035d155d7fde56a764d5e" id="r_ae9b93e2942b035d155d7fde56a764d5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#ae9b93e2942b035d155d7fde56a764d5e">_do_prepend</a> (arr, pad_chunk, axis)</td></tr>
<tr class="separator:ae9b93e2942b035d155d7fde56a764d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ae6e266d2977d44c116e36c27d24c2" id="r_a21ae6e266d2977d44c116e36c27d24c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a21ae6e266d2977d44c116e36c27d24c2">_do_append</a> (arr, pad_chunk, axis)</td></tr>
<tr class="separator:a21ae6e266d2977d44c116e36c27d24c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9742d041a625557f296ac18d9ba29f" id="r_a0e9742d041a625557f296ac18d9ba29f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a0e9742d041a625557f296ac18d9ba29f">_prepend_const</a> (arr, pad_amt, val, axis=-1)</td></tr>
<tr class="separator:a0e9742d041a625557f296ac18d9ba29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7964268e6d64fc34cab68148396937a4" id="r_a7964268e6d64fc34cab68148396937a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a7964268e6d64fc34cab68148396937a4">_append_const</a> (arr, pad_amt, val, axis=-1)</td></tr>
<tr class="separator:a7964268e6d64fc34cab68148396937a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6368220333dcedcf87fc716c2057ef57" id="r_a6368220333dcedcf87fc716c2057ef57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a6368220333dcedcf87fc716c2057ef57">_prepend_edge</a> (arr, pad_amt, axis=-1)</td></tr>
<tr class="separator:a6368220333dcedcf87fc716c2057ef57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994b8ffb84ef5a27eda274a8f9c408af" id="r_a994b8ffb84ef5a27eda274a8f9c408af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a994b8ffb84ef5a27eda274a8f9c408af">_append_edge</a> (arr, pad_amt, axis=-1)</td></tr>
<tr class="separator:a994b8ffb84ef5a27eda274a8f9c408af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a25b68fc080b53006c4478da0337070" id="r_a6a25b68fc080b53006c4478da0337070"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a6a25b68fc080b53006c4478da0337070">_prepend_ramp</a> (arr, pad_amt, end, axis=-1)</td></tr>
<tr class="separator:a6a25b68fc080b53006c4478da0337070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6578933c47dee0dc94b3a762424636" id="r_aac6578933c47dee0dc94b3a762424636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#aac6578933c47dee0dc94b3a762424636">_append_ramp</a> (arr, pad_amt, end, axis=-1)</td></tr>
<tr class="separator:aac6578933c47dee0dc94b3a762424636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f674258e3ff0b271c1c8f6719289e4" id="r_a71f674258e3ff0b271c1c8f6719289e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a71f674258e3ff0b271c1c8f6719289e4">_prepend_max</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a71f674258e3ff0b271c1c8f6719289e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91209ad9d6cb50e487e665f95e7e9763" id="r_a91209ad9d6cb50e487e665f95e7e9763"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a91209ad9d6cb50e487e665f95e7e9763">_append_max</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a91209ad9d6cb50e487e665f95e7e9763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf494f1abbac22ee81ad4901bfb3ef2" id="r_a4bf494f1abbac22ee81ad4901bfb3ef2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a4bf494f1abbac22ee81ad4901bfb3ef2">_prepend_mean</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a4bf494f1abbac22ee81ad4901bfb3ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1088c3c46068878d76e827192729b5e1" id="r_a1088c3c46068878d76e827192729b5e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a1088c3c46068878d76e827192729b5e1">_append_mean</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a1088c3c46068878d76e827192729b5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8d83827bf0f91a1444f30c95b3f405" id="r_a7b8d83827bf0f91a1444f30c95b3f405"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a7b8d83827bf0f91a1444f30c95b3f405">_prepend_med</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a7b8d83827bf0f91a1444f30c95b3f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55924ed3bfe9a9e5705b79ddc0b002d1" id="r_a55924ed3bfe9a9e5705b79ddc0b002d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a55924ed3bfe9a9e5705b79ddc0b002d1">_append_med</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a55924ed3bfe9a9e5705b79ddc0b002d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3062d5d2303b0df142624567602c09ff" id="r_a3062d5d2303b0df142624567602c09ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a3062d5d2303b0df142624567602c09ff">_prepend_min</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a3062d5d2303b0df142624567602c09ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212c3e6737f07d161d356e49b1475f61" id="r_a212c3e6737f07d161d356e49b1475f61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a212c3e6737f07d161d356e49b1475f61">_append_min</a> (arr, pad_amt, num, axis=-1)</td></tr>
<tr class="separator:a212c3e6737f07d161d356e49b1475f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb5c8d46d6454c0f241c5991e7e76ad" id="r_a0eb5c8d46d6454c0f241c5991e7e76ad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a0eb5c8d46d6454c0f241c5991e7e76ad">_pad_ref</a> (arr, pad_amt, method, axis=-1)</td></tr>
<tr class="separator:a0eb5c8d46d6454c0f241c5991e7e76ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae029b1373005d38a13efe848d9745a87" id="r_ae029b1373005d38a13efe848d9745a87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#ae029b1373005d38a13efe848d9745a87">_pad_sym</a> (arr, pad_amt, method, axis=-1)</td></tr>
<tr class="separator:ae029b1373005d38a13efe848d9745a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93799b9f9f003688385fc67b0de7e191" id="r_a93799b9f9f003688385fc67b0de7e191"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a93799b9f9f003688385fc67b0de7e191">_pad_wrap</a> (arr, pad_amt, axis=-1)</td></tr>
<tr class="separator:a93799b9f9f003688385fc67b0de7e191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ea99ca7c1b6b197ce4d1ec4ef7705e" id="r_a19ea99ca7c1b6b197ce4d1ec4ef7705e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a19ea99ca7c1b6b197ce4d1ec4ef7705e">_normalize_shape</a> (ndarray, <a class="el" href="namespacenumpy_1_1core_1_1fromnumeric.html#a149f0ed3f02491db0c249840e2aff84f">shape</a>, cast_to_int=<a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a>)</td></tr>
<tr class="separator:a19ea99ca7c1b6b197ce4d1ec4ef7705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9280aa90d3a2caa20193f1f400b21608" id="r_a9280aa90d3a2caa20193f1f400b21608"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a9280aa90d3a2caa20193f1f400b21608">_validate_lengths</a> (narray, number_elements)</td></tr>
<tr class="separator:a9280aa90d3a2caa20193f1f400b21608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e732fce8299b618ad6acd76a6af727" id="r_a57e732fce8299b618ad6acd76a6af727"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html#a57e732fce8299b618ad6acd76a6af727">pad</a> (array, pad_width, mode, **kwargs)</td></tr>
<tr class="memdesc:a57e732fce8299b618ad6acd76a6af727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public functions.  <br /></td></tr>
<tr class="separator:a57e732fce8299b618ad6acd76a6af727"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">The arraypad module contains a group of functions to pad values onto the edges
of an n-dimensional array.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a7964268e6d64fc34cab68148396937a4" name="a7964268e6d64fc34cab68148396937a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7964268e6d64fc34cab68148396937a4">&#9670;&#160;</a></span>_append_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_append_const </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Append constant `val` along `axis` of `arr`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to append.
val : scalar
    Constant value to use. For best results should be of type `arr.dtype`;
    if not `arr.dtype` will be cast to `arr.dtype`.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` constant `val` appended along `axis`.</pre> 
</div>
</div>
<a id="a994b8ffb84ef5a27eda274a8f9c408af" name="a994b8ffb84ef5a27eda274a8f9c408af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994b8ffb84ef5a27eda274a8f9c408af">&#9670;&#160;</a></span>_append_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_append_edge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Append `pad_amt` to `arr` along `axis` by extending edge values.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to append.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, extended by `pad_amt` edge values prepended along
    `axis`.</pre> 
</div>
</div>
<a id="a91209ad9d6cb50e487e665f95e7e9763" name="a91209ad9d6cb50e487e665f95e7e9763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91209ad9d6cb50e487e665f95e7e9763">&#9670;&#160;</a></span>_append_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_append_max </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pad one `axis` of `arr` with the maximum of the last `num` elements.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to append.
num : int
    Depth into `arr` along `axis` to calculate maximum.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values appended along `axis`. The
    appended region is the maximum of the final `num` values along `axis`.</pre> 
</div>
</div>
<a id="a1088c3c46068878d76e827192729b5e1" name="a1088c3c46068878d76e827192729b5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1088c3c46068878d76e827192729b5e1">&#9670;&#160;</a></span>_append_mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_append_mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Append `pad_amt` mean values along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to append.
num : int
    Depth into `arr` along `axis` to calculate mean.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values appended along `axis`. The
    appended region is the maximum of the final `num` values along `axis`.</pre> 
</div>
</div>
<a id="a55924ed3bfe9a9e5705b79ddc0b002d1" name="a55924ed3bfe9a9e5705b79ddc0b002d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55924ed3bfe9a9e5705b79ddc0b002d1">&#9670;&#160;</a></span>_append_med()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_append_med </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Append `pad_amt` median values along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to append.
num : int
    Depth into `arr` along `axis` to calculate median.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values appended along `axis`. The
    appended region is the median of the final `num` values along `axis`.</pre> 
</div>
</div>
<a id="a212c3e6737f07d161d356e49b1475f61" name="a212c3e6737f07d161d356e49b1475f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212c3e6737f07d161d356e49b1475f61">&#9670;&#160;</a></span>_append_min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_append_min </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Append `pad_amt` median values along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to append.
num : int
    Depth into `arr` along `axis` to calculate minimum.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values appended along `axis`. The
    appended region is the minimum of the final `num` values along `axis`.</pre> 
</div>
</div>
<a id="aac6578933c47dee0dc94b3a762424636" name="aac6578933c47dee0dc94b3a762424636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6578933c47dee0dc94b3a762424636">&#9670;&#160;</a></span>_append_ramp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_append_ramp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Append linear ramp along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to append.
end : scalar
    Constal value to use. For best results should be of type `arr.dtype`;
    if not `arr.dtype` will be cast to `arr.dtype`.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values appended along `axis`. The
    appended region ramps linearly from the edge value to `end`.</pre> 
</div>
</div>
<a id="a8c47ee86df8d1805b19b6d9037ac7b87" name="a8c47ee86df8d1805b19b6d9037ac7b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c47ee86df8d1805b19b6d9037ac7b87">&#9670;&#160;</a></span>_arange_ndarray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_arange_ndarray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private utility functions. </p>
<pre class="fragment">Create an ndarray of `shape` with increments along specified `axis`

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
shape : tuple of ints
    Shape of desired array. Should be equivalent to `arr.shape` except
    `shape[axis]` which may have any positive value.
axis : int
    Axis to increment along.
reverse : bool
    If False, increment in a positive fashion from 1 to `shape[axis]`,
    inclusive. If True, the bounds are the same but the order reversed.

Returns
-------
padarr : ndarray
    Output array sized to pad `arr` along `axis`, with linear range from
    1 to `shape[axis]` along specified `axis`.

Notes
-----
The range is deliberately 1-indexed for this specific use case. Think of
this algorithm as broadcasting `np.arange` to a single `axis` of an
arbitrarily shaped ndarray.</pre> 
</div>
</div>
<a id="a21ae6e266d2977d44c116e36c27d24c2" name="a21ae6e266d2977d44c116e36c27d24c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ae6e266d2977d44c116e36c27d24c2">&#9670;&#160;</a></span>_do_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_do_append </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b93e2942b035d155d7fde56a764d5e" name="ae9b93e2942b035d155d7fde56a764d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b93e2942b035d155d7fde56a764d5e">&#9670;&#160;</a></span>_do_prepend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_do_prepend </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19ea99ca7c1b6b197ce4d1ec4ef7705e" name="a19ea99ca7c1b6b197ce4d1ec4ef7705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ea99ca7c1b6b197ce4d1ec4ef7705e">&#9670;&#160;</a></span>_normalize_shape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_normalize_shape </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cast_to_int</em> = <code><a class="el" href="cxbool_8h.html#add3ca9eefe3b5b754426f51d3043e579">True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function which does some checks and normalizes the possibly
much simpler representations of 'pad_width', 'stat_length',
'constant_values', 'end_values'.

Parameters
----------
narray : ndarray
    Input ndarray
shape : {sequence, array_like, float, int}, optional
    The width of padding (pad_width), the number of elements on the
    edge of the narray used for statistics (stat_length), the constant
    value(s) to use when filling padded regions (constant_values), or the
    endpoint target(s) for linear ramps (end_values).
    ((before_1, after_1), ... (before_N, after_N)) unique number of
    elements for each axis where `N` is rank of `narray`.
    ((before, after),) yields same before and after constants for each
    axis.
    (constant,) or val is a shortcut for before = after = constant for
    all axes.
cast_to_int : bool, optional
    Controls if values in ``shape`` will be rounded and cast to int
    before being returned.

Returns
-------
normalized_shape : tuple of tuples
    val                               =&gt; ((val, val), (val, val), ...)
    [[val1, val2], [val3, val4], ...] =&gt; ((val1, val2), (val3, val4), ...)
    ((val1, val2), (val3, val4), ...) =&gt; no change
    [[val1, val2], ]                  =&gt; ((val1, val2), (val1, val2), ...)
    ((val1, val2), )                  =&gt; ((val1, val2), (val1, val2), ...)
    [[val ,     ], ]                  =&gt; ((val, val), (val, val), ...)
    ((val ,     ), )                  =&gt; ((val, val), (val, val), ...)</pre> 
</div>
</div>
<a id="a0eb5c8d46d6454c0f241c5991e7e76ad" name="a0eb5c8d46d6454c0f241c5991e7e76ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb5c8d46d6454c0f241c5991e7e76ad">&#9670;&#160;</a></span>_pad_ref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pad_ref </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pad `axis` of `arr` by reflection.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : tuple of ints, length 2
    Padding to (prepend, append) along `axis`.
method : str
    Controls method of reflection; options are 'even' or 'odd'.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt[0]` values prepended and `pad_amt[1]`
    values appended along `axis`. Both regions are padded with reflected
    values from the original array.

Notes
-----
This algorithm does not pad with repetition, i.e. the edges are not
repeated in the reflection. For that behavior, use `mode='symmetric'`.

The modes 'reflect', 'symmetric', and 'wrap' must be padded with a
single function, lest the indexing tricks in non-integer multiples of the
original shape would violate repetition in the final iteration.</pre> 
</div>
</div>
<a id="ae029b1373005d38a13efe848d9745a87" name="ae029b1373005d38a13efe848d9745a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae029b1373005d38a13efe848d9745a87">&#9670;&#160;</a></span>_pad_sym()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pad_sym </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pad `axis` of `arr` by symmetry.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : tuple of ints, length 2
    Padding to (prepend, append) along `axis`.
method : str
    Controls method of symmetry; options are 'even' or 'odd'.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt[0]` values prepended and `pad_amt[1]`
    values appended along `axis`. Both regions are padded with symmetric
    values from the original array.

Notes
-----
This algorithm DOES pad with repetition, i.e. the edges are repeated.
For padding without repeated edges, use `mode='reflect'`.

The modes 'reflect', 'symmetric', and 'wrap' must be padded with a
single function, lest the indexing tricks in non-integer multiples of the
original shape would violate repetition in the final iteration.</pre> 
</div>
</div>
<a id="a93799b9f9f003688385fc67b0de7e191" name="a93799b9f9f003688385fc67b0de7e191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93799b9f9f003688385fc67b0de7e191">&#9670;&#160;</a></span>_pad_wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pad_wrap </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Pad `axis` of `arr` via wrapping.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : tuple of ints, length 2
    Padding to (prepend, append) along `axis`.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt[0]` values prepended and `pad_amt[1]`
    values appended along `axis`. Both regions are padded wrapped values
    from the opposite end of `axis`.

Notes
-----
This method of padding is also known as 'tile' or 'tiling'.

The modes 'reflect', 'symmetric', and 'wrap' must be padded with a
single function, lest the indexing tricks in non-integer multiples of the
original shape would violate repetition in the final iteration.</pre> 
</div>
</div>
<a id="a0e9742d041a625557f296ac18d9ba29f" name="a0e9742d041a625557f296ac18d9ba29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9742d041a625557f296ac18d9ba29f">&#9670;&#160;</a></span>_prepend_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_prepend_const </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepend constant `val` along `axis` of `arr`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to prepend.
val : scalar
    Constant value to use. For best results should be of type `arr.dtype`;
    if not `arr.dtype` will be cast to `arr.dtype`.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` constant `val` prepended along `axis`.</pre> 
</div>
</div>
<a id="a6368220333dcedcf87fc716c2057ef57" name="a6368220333dcedcf87fc716c2057ef57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6368220333dcedcf87fc716c2057ef57">&#9670;&#160;</a></span>_prepend_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_prepend_edge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepend `pad_amt` to `arr` along `axis` by extending edge values.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to prepend.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, extended by `pad_amt` edge values appended along `axis`.</pre> 
</div>
</div>
<a id="a71f674258e3ff0b271c1c8f6719289e4" name="a71f674258e3ff0b271c1c8f6719289e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f674258e3ff0b271c1c8f6719289e4">&#9670;&#160;</a></span>_prepend_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_prepend_max </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepend `pad_amt` maximum values along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to prepend.
num : int
    Depth into `arr` along `axis` to calculate maximum.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values appended along `axis`. The
    prepended region is the maximum of the first `num` values along
    `axis`.</pre> 
</div>
</div>
<a id="a4bf494f1abbac22ee81ad4901bfb3ef2" name="a4bf494f1abbac22ee81ad4901bfb3ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf494f1abbac22ee81ad4901bfb3ef2">&#9670;&#160;</a></span>_prepend_mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_prepend_mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepend `pad_amt` mean values along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to prepend.
num : int
    Depth into `arr` along `axis` to calculate mean.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values prepended along `axis`. The
    prepended region is the mean of the first `num` values along `axis`.</pre> 
</div>
</div>
<a id="a7b8d83827bf0f91a1444f30c95b3f405" name="a7b8d83827bf0f91a1444f30c95b3f405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8d83827bf0f91a1444f30c95b3f405">&#9670;&#160;</a></span>_prepend_med()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_prepend_med </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepend `pad_amt` median values along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to prepend.
num : int
    Depth into `arr` along `axis` to calculate median.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values prepended along `axis`. The
    prepended region is the median of the first `num` values along `axis`.</pre> 
</div>
</div>
<a id="a3062d5d2303b0df142624567602c09ff" name="a3062d5d2303b0df142624567602c09ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3062d5d2303b0df142624567602c09ff">&#9670;&#160;</a></span>_prepend_min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_prepend_min </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepend `pad_amt` minimum values along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to prepend.
num : int
    Depth into `arr` along `axis` to calculate minimum.
    Range: [1, `arr.shape[axis]`] or None (entire axis)
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values prepended along `axis`. The
    prepended region is the minimum of the first `num` values along
    `axis`.</pre> 
</div>
</div>
<a id="a6a25b68fc080b53006c4478da0337070" name="a6a25b68fc080b53006c4478da0337070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a25b68fc080b53006c4478da0337070">&#9670;&#160;</a></span>_prepend_ramp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_prepend_ramp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_amt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepend linear ramp along `axis`.

Parameters
----------
arr : ndarray
    Input array of arbitrary shape.
pad_amt : int
    Amount of padding to prepend.
end : scalar
    Constal value to use. For best results should be of type `arr.dtype`;
    if not `arr.dtype` will be cast to `arr.dtype`.
axis : int
    Axis along which to pad `arr`.

Returns
-------
padarr : ndarray
    Output array, with `pad_amt` values prepended along `axis`. The
    prepended region ramps linearly from the edge value to `end`.</pre> 
</div>
</div>
<a id="a59a25cbba1748acb00d93d7adeb6f67a" name="a59a25cbba1748acb00d93d7adeb6f67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a25cbba1748acb00d93d7adeb6f67a">&#9670;&#160;</a></span>_round_ifneeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_round_ifneeded </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Rounds arr inplace if destination dtype is integer.

Parameters
----------
arr : ndarray
    Input array.
dtype : dtype
    The dtype of the destination array.</pre> 
</div>
</div>
<a id="a65a39553ec1f7a61c2cf0ab2720572c9" name="a65a39553ec1f7a61c2cf0ab2720572c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a39553ec1f7a61c2cf0ab2720572c9">&#9670;&#160;</a></span>_slice_at_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_slice_at_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Construct a slice tuple the length of shape, with sl at the specified axis
</pre> 
</div>
</div>
<a id="aa9b167ee326b56fe2d2885b29bc77e5c" name="aa9b167ee326b56fe2d2885b29bc77e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b167ee326b56fe2d2885b29bc77e5c">&#9670;&#160;</a></span>_slice_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_slice_first </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Construct a slice tuple to take the first n elements along axis </pre> 
</div>
</div>
<a id="aafa30fcce2c78a351331363bd1d8687a" name="aafa30fcce2c78a351331363bd1d8687a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa30fcce2c78a351331363bd1d8687a">&#9670;&#160;</a></span>_slice_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_slice_last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> Construct a slice tuple to take the last n elements along axis </pre> 
</div>
</div>
<a id="a9280aa90d3a2caa20193f1f400b21608" name="a9280aa90d3a2caa20193f1f400b21608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9280aa90d3a2caa20193f1f400b21608">&#9670;&#160;</a></span>_validate_lengths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_validate_lengths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>narray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>number_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Private function which does some checks and reformats pad_width and
stat_length using _normalize_shape.

Parameters
----------
narray : ndarray
    Input ndarray
number_elements : {sequence, int}, optional
    The width of padding (pad_width) or the number of elements on the edge
    of the narray used for statistics (stat_length).
    ((before_1, after_1), ... (before_N, after_N)) unique number of
    elements for each axis.
    ((before, after),) yields same before and after constants for each
    axis.
    (constant,) or int is a shortcut for before = after = constant for all
    axes.

Returns
-------
_validate_lengths : tuple of tuples
    int                               =&gt; ((int, int), (int, int), ...)
    [[int1, int2], [int3, int4], ...] =&gt; ((int1, int2), (int3, int4), ...)
    ((int1, int2), (int3, int4), ...) =&gt; no change
    [[int1, int2], ]                  =&gt; ((int1, int2), (int1, int2), ...)
    ((int1, int2), )                  =&gt; ((int1, int2), (int1, int2), ...)
    [[int ,     ], ]                  =&gt; ((int, int), (int, int), ...)
    ((int ,     ), )                  =&gt; ((int, int), (int, int), ...)</pre> 
</div>
</div>
<a id="a57e732fce8299b618ad6acd76a6af727" name="a57e732fce8299b618ad6acd76a6af727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e732fce8299b618ad6acd76a6af727">&#9670;&#160;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public functions. </p>
<pre class="fragment">Pads an array.

Parameters
----------
array : array_like of rank N
    Input array
pad_width : {sequence, array_like, int}
    Number of values padded to the edges of each axis.
    ((before_1, after_1), ... (before_N, after_N)) unique pad widths
    for each axis.
    ((before, after),) yields same before and after pad for each axis.
    (pad,) or int is a shortcut for before = after = pad width for all
    axes.
mode : str or function
    One of the following string values or a user supplied function.

    'constant'
        Pads with a constant value.
    'edge'
        Pads with the edge values of array.
    'linear_ramp'
        Pads with the linear ramp between end_value and the
        array edge value.
    'maximum'
        Pads with the maximum value of all or part of the
        vector along each axis.
    'mean'
        Pads with the mean value of all or part of the
        vector along each axis.
    'median'
        Pads with the median value of all or part of the
        vector along each axis.
    'minimum'
        Pads with the minimum value of all or part of the
        vector along each axis.
    'reflect'
        Pads with the reflection of the vector mirrored on
        the first and last values of the vector along each
        axis.
    'symmetric'
        Pads with the reflection of the vector mirrored
        along the edge of the array.
    'wrap'
        Pads with the wrap of the vector along the axis.
        The first values are used to pad the end and the
        end values are used to pad the beginning.
    &lt;function&gt;
        Padding function, see Notes.
stat_length : sequence or int, optional
    Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of
    values at edge of each axis used to calculate the statistic value.

    ((before_1, after_1), ... (before_N, after_N)) unique statistic
    lengths for each axis.

    ((before, after),) yields same before and after statistic lengths
    for each axis.

    (stat_length,) or int is a shortcut for before = after = statistic
    length for all axes.

    Default is ``None``, to use the entire axis.
constant_values : sequence or int, optional
    Used in 'constant'.  The values to set the padded values for each
    axis.

    ((before_1, after_1), ... (before_N, after_N)) unique pad constants
    for each axis.

    ((before, after),) yields same before and after constants for each
    axis.

    (constant,) or int is a shortcut for before = after = constant for
    all axes.

    Default is 0.
end_values : sequence or int, optional
    Used in 'linear_ramp'.  The values used for the ending value of the
    linear_ramp and that will form the edge of the padded array.

    ((before_1, after_1), ... (before_N, after_N)) unique end values
    for each axis.

    ((before, after),) yields same before and after end values for each
    axis.

    (constant,) or int is a shortcut for before = after = end value for
    all axes.

    Default is 0.
reflect_type : {'even', 'odd'}, optional
    Used in 'reflect', and 'symmetric'.  The 'even' style is the
    default with an unaltered reflection around the edge value.  For
    the 'odd' style, the extended part of the array is created by
    subtracting the reflected values from two times the edge value.

Returns
-------
pad : ndarray
    Padded array of rank equal to `array` with shape increased
    according to `pad_width`.

Notes
-----
.. versionadded:: 1.7.0

For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.

The padding function, if used, should return a rank 1 array equal in
length to the vector argument with padded values replaced. It has the
following signature::

    padding_func(vector, iaxis_pad_width, iaxis, kwargs)

where

    vector : ndarray
        A rank 1 array already padded with zeros.  Padded values are
        vector[:pad_tuple[0]] and vector[-pad_tuple[1]:].
    iaxis_pad_width : tuple
        A 2-tuple of ints, iaxis_pad_width[0] represents the number of
        values padded at the beginning of vector where
        iaxis_pad_width[1] represents the number of values padded at
        the end of vector.
    iaxis : int
        The axis currently being calculated.
    kwargs : dict
        Any keyword arguments the function requires.

Examples
--------
&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; np.pad(a, (2,3), 'constant', constant_values=(4, 6))
array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6])

&gt;&gt;&gt; np.pad(a, (2, 3), 'edge')
array([1, 1, 1, 2, 3, 4, 5, 5, 5, 5])

&gt;&gt;&gt; np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])

&gt;&gt;&gt; np.pad(a, (2,), 'maximum')
array([5, 5, 1, 2, 3, 4, 5, 5, 5])

&gt;&gt;&gt; np.pad(a, (2,), 'mean')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

&gt;&gt;&gt; np.pad(a, (2,), 'median')
array([3, 3, 1, 2, 3, 4, 5, 3, 3])

&gt;&gt;&gt; a = [[1, 2], [3, 4]]
&gt;&gt;&gt; np.pad(a, ((3, 2), (2, 3)), 'minimum')
array([[1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [3, 3, 3, 4, 3, 3, 3],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1]])

&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect')
array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])

&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect', reflect_type='odd')
array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])

&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric')
array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])

&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])

&gt;&gt;&gt; np.pad(a, (2, 3), 'wrap')
array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])

&gt;&gt;&gt; def pad_with(vector, pad_width, iaxis, kwargs):
...     pad_value = kwargs.get('padder', 10)
...     vector[:pad_width[0]] = pad_value
...     vector[-pad_width[1]:] = pad_value
...     return vector
&gt;&gt;&gt; a = np.arange(6)
&gt;&gt;&gt; a = a.reshape((2, 3))
&gt;&gt;&gt; np.pad(a, 2, pad_with)
array([[10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10,  0,  1,  2, 10, 10],
       [10, 10,  3,  4,  5, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10]])
&gt;&gt;&gt; np.pad(a, 2, pad_with, padder=100)
array([[100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100,   0,   1,   2, 100, 100],
       [100, 100,   3,   4,   5, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100]])
</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1arraypad.html">arraypad</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
