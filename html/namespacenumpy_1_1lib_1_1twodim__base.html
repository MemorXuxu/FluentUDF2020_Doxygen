<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fluent UDF 2020R1: numpy.lib.twodim_base Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Fluent UDF 2020R1<span id="projectnumber">&#160;0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacenumpy_1_1lib_1_1twodim__base.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.lib.twodim_base Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae7d6bab148f5842ef349e309c08970ab" id="r_ae7d6bab148f5842ef349e309c08970ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#ae7d6bab148f5842ef349e309c08970ab">_min_int</a> (low, high)</td></tr>
<tr class="separator:ae7d6bab148f5842ef349e309c08970ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b853c61e2eb420d58ed790609f90157" id="r_a6b853c61e2eb420d58ed790609f90157"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a6b853c61e2eb420d58ed790609f90157">fliplr</a> (m)</td></tr>
<tr class="separator:a6b853c61e2eb420d58ed790609f90157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19c2075878c59dfce9568a46c7dcfdf" id="r_af19c2075878c59dfce9568a46c7dcfdf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#af19c2075878c59dfce9568a46c7dcfdf">flipud</a> (m)</td></tr>
<tr class="separator:af19c2075878c59dfce9568a46c7dcfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a0662bb03bd19aa154d0037221113d" id="r_aa0a0662bb03bd19aa154d0037221113d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#aa0a0662bb03bd19aa154d0037221113d">eye</a> (<a class="el" href="sg__pollut_8h.html#a2be6b2e3a94031359aa1b0cdef72fd9ea2c63acbe79d9f41ba6bb7766e9c37702">N</a>, M=None, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0, dtype=float, order='C')</td></tr>
<tr class="separator:aa0a0662bb03bd19aa154d0037221113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dd0dea33b8dcaaa6f00c668481305c" id="r_ab6dd0dea33b8dcaaa6f00c668481305c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#ab6dd0dea33b8dcaaa6f00c668481305c">diag</a> (v, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0)</td></tr>
<tr class="separator:ab6dd0dea33b8dcaaa6f00c668481305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226f5aab9ac06089c74115f9762cbaf0" id="r_a226f5aab9ac06089c74115f9762cbaf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a226f5aab9ac06089c74115f9762cbaf0">diagflat</a> (v, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0)</td></tr>
<tr class="separator:a226f5aab9ac06089c74115f9762cbaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fae3f50ac344063c0919ba7f54d717" id="r_a16fae3f50ac344063c0919ba7f54d717"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a16fae3f50ac344063c0919ba7f54d717">tri</a> (<a class="el" href="sg__pollut_8h.html#a2be6b2e3a94031359aa1b0cdef72fd9ea2c63acbe79d9f41ba6bb7766e9c37702">N</a>, M=None, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0, dtype=float)</td></tr>
<tr class="separator:a16fae3f50ac344063c0919ba7f54d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0a30b71887bc9c15050531e85a642" id="r_af4a0a30b71887bc9c15050531e85a642"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#af4a0a30b71887bc9c15050531e85a642">tril</a> (m, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0)</td></tr>
<tr class="separator:af4a0a30b71887bc9c15050531e85a642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1903e2d096119cc63674d318c41589" id="r_abd1903e2d096119cc63674d318c41589"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#abd1903e2d096119cc63674d318c41589">triu</a> (m, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0)</td></tr>
<tr class="separator:abd1903e2d096119cc63674d318c41589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ff6907cb8bacb08813dc6eecce8796" id="r_a91ff6907cb8bacb08813dc6eecce8796"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a91ff6907cb8bacb08813dc6eecce8796">vander</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="sg__pollut_8h.html#a2be6b2e3a94031359aa1b0cdef72fd9ea2c63acbe79d9f41ba6bb7766e9c37702">N</a>=None, increasing=<a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a>)</td></tr>
<tr class="separator:a91ff6907cb8bacb08813dc6eecce8796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1d26026eb2f32e6849aa083d6c5d55" id="r_a9f1d26026eb2f32e6849aa083d6c5d55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a9f1d26026eb2f32e6849aa083d6c5d55">histogram2d</a> (<a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, y, bins=10, <a class="el" href="namespacenumpy_1_1lib_1_1function__base.html#a5a95c5aa27dc12b07af34405942b7849">range</a>=None, normed=None, weights=None, density=None)</td></tr>
<tr class="separator:a9f1d26026eb2f32e6849aa083d6c5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a3640baeb79f967ff0349cf774584e" id="r_a35a3640baeb79f967ff0349cf774584e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a35a3640baeb79f967ff0349cf774584e">mask_indices</a> (n, mask_func, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0)</td></tr>
<tr class="separator:a35a3640baeb79f967ff0349cf774584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05fd6b74b3e7375454305ba5d2bffd" id="r_abe05fd6b74b3e7375454305ba5d2bffd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#abe05fd6b74b3e7375454305ba5d2bffd">tril_indices</a> (n, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0, m=None)</td></tr>
<tr class="separator:abe05fd6b74b3e7375454305ba5d2bffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea2d6007161d48d33b348e28f2f0361" id="r_a1ea2d6007161d48d33b348e28f2f0361"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a1ea2d6007161d48d33b348e28f2f0361">tril_indices_from</a> (arr, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0)</td></tr>
<tr class="separator:a1ea2d6007161d48d33b348e28f2f0361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab549c5bd536bd3f53931b844669220e9" id="r_ab549c5bd536bd3f53931b844669220e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#ab549c5bd536bd3f53931b844669220e9">triu_indices</a> (n, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0, m=None)</td></tr>
<tr class="separator:ab549c5bd536bd3f53931b844669220e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add96b8e061ed54e0cd1c208e981585a6" id="r_add96b8e061ed54e0cd1c208e981585a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#add96b8e061ed54e0cd1c208e981585a6">triu_indices_from</a> (arr, <a class="el" href="namespacenumpy_1_1core_1_1numerictypes.html#adc468c70fb574ebd07287b38d0d0676d">k</a>=0)</td></tr>
<tr class="separator:add96b8e061ed54e0cd1c208e981585a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac6ef61fb0fec52abd81fd71388742cc0" id="r_ac6ef61fb0fec52abd81fd71388742cc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#ac6ef61fb0fec52abd81fd71388742cc0">i1</a> = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int8)</td></tr>
<tr class="separator:ac6ef61fb0fec52abd81fd71388742cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fce890a7c411f1fe7c0c55ec9eb4106" id="r_a2fce890a7c411f1fe7c0c55ec9eb4106"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a2fce890a7c411f1fe7c0c55ec9eb4106">i2</a> = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int16)</td></tr>
<tr class="separator:a2fce890a7c411f1fe7c0c55ec9eb4106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608e2266a7f74d5814905a52df1fc084" id="r_a608e2266a7f74d5814905a52df1fc084"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html#a608e2266a7f74d5814905a52df1fc084">i4</a> = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int32)</td></tr>
<tr class="separator:a608e2266a7f74d5814905a52df1fc084"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment"> Basic functions for manipulating 2d arrays</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae7d6bab148f5842ef349e309c08970ab" name="ae7d6bab148f5842ef349e309c08970ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d6bab148f5842ef349e309c08970ab">&#9670;&#160;</a></span>_min_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_min_int </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment"> get small int that fits the range </pre> 
</div>
</div>
<a id="ab6dd0dea33b8dcaaa6f00c668481305c" name="ab6dd0dea33b8dcaaa6f00c668481305c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dd0dea33b8dcaaa6f00c668481305c">&#9670;&#160;</a></span>diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">diag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract a diagonal or construct a diagonal array.

See the more detailed documentation for ``numpy.diagonal`` if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.

Parameters
----------
v : array_like
    If `v` is a 2-D array, return a copy of its `k`-th diagonal.
    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
    diagonal.
k : int, optional
    Diagonal in question. The default is 0. Use `k&gt;0` for diagonals
    above the main diagonal, and `k&lt;0` for diagonals below the main
    diagonal.

Returns
-------
out : ndarray
    The extracted diagonal or constructed diagonal array.

See Also
--------
diagonal : Return specified diagonals.
diagflat : Create a 2-D array with the flattened input as a diagonal.
trace : Sum along diagonals.
triu : Upper triangle of an array.
tril : Lower triangle of an array.

Examples
--------
&gt;&gt;&gt; x = np.arange(9).reshape((3,3))
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

&gt;&gt;&gt; np.diag(x)
array([0, 4, 8])
&gt;&gt;&gt; np.diag(x, k=1)
array([1, 5])
&gt;&gt;&gt; np.diag(x, k=-1)
array([3, 7])

&gt;&gt;&gt; np.diag(np.diag(x))
array([[0, 0, 0],
       [0, 4, 0],
       [0, 0, 8]])</pre> 
</div>
</div>
<a id="a226f5aab9ac06089c74115f9762cbaf0" name="a226f5aab9ac06089c74115f9762cbaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226f5aab9ac06089c74115f9762cbaf0">&#9670;&#160;</a></span>diagflat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">diagflat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a two-dimensional array with the flattened input as a diagonal.

Parameters
----------
v : array_like
    Input data, which is flattened and set as the `k`-th
    diagonal of the output.
k : int, optional
    Diagonal to set; 0, the default, corresponds to the "main" diagonal,
    a positive (negative) `k` giving the number of the diagonal above
    (below) the main.

Returns
-------
out : ndarray
    The 2-D output array.

See Also
--------
diag : MATLAB work-alike for 1-D and 2-D arrays.
diagonal : Return specified diagonals.
trace : Sum along diagonals.

Examples
--------
&gt;&gt;&gt; np.diagflat([[1,2], [3,4]])
array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])

&gt;&gt;&gt; np.diagflat([1,2], 1)
array([[0, 1, 0],
       [0, 0, 2],
       [0, 0, 0]])</pre> 
</div>
</div>
<a id="aa0a0662bb03bd19aa154d0037221113d" name="aa0a0662bb03bd19aa154d0037221113d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a0662bb03bd19aa154d0037221113d">&#9670;&#160;</a></span>eye()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eye </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'C'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a 2-D array with ones on the diagonal and zeros elsewhere.

Parameters
----------
N : int
  Number of rows in the output.
M : int, optional
  Number of columns in the output. If None, defaults to `N`.
k : int, optional
  Index of the diagonal: 0 (the default) refers to the main diagonal,
  a positive value refers to an upper diagonal, and a negative value
  to a lower diagonal.
dtype : data-type, optional
  Data-type of the returned array.
order : {'C', 'F'}, optional
    Whether the output should be stored in row-major (C-style) or
    column-major (Fortran-style) order in memory.

    .. versionadded:: 1.14.0

Returns
-------
I : ndarray of shape (N,M)
  An array where all elements are equal to zero, except for the `k`-th
  diagonal, whose values are equal to one.

See Also
--------
identity : (almost) equivalent function
diag : diagonal 2-D array from a 1-D array specified by the user.

Examples
--------
&gt;&gt;&gt; np.eye(2, dtype=int)
array([[1, 0],
       [0, 1]])
&gt;&gt;&gt; np.eye(3, k=1)
array([[ 0.,  1.,  0.],
       [ 0.,  0.,  1.],
       [ 0.,  0.,  0.]])</pre> 
</div>
</div>
<a id="a6b853c61e2eb420d58ed790609f90157" name="a6b853c61e2eb420d58ed790609f90157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b853c61e2eb420d58ed790609f90157">&#9670;&#160;</a></span>fliplr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fliplr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flip array in the left/right direction.

Flip the entries in each row in the left/right direction.
Columns are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array, must be at least 2-D.

Returns
-------
f : ndarray
    A view of `m` with the columns reversed.  Since a view
    is returned, this operation is :math:`\\mathcal O(1)`.

See Also
--------
flipud : Flip array in the up/down direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to m[:,::-1]. Requires the array to be at least 2-D.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.,2.,3.])
&gt;&gt;&gt; A
array([[ 1.,  0.,  0.],
       [ 0.,  2.,  0.],
       [ 0.,  0.,  3.]])
&gt;&gt;&gt; np.fliplr(A)
array([[ 0.,  0.,  1.],
       [ 0.,  2.,  0.],
       [ 3.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(np.fliplr(A) == A[:,::-1,...])
True</pre> 
</div>
</div>
<a id="af19c2075878c59dfce9568a46c7dcfdf" name="af19c2075878c59dfce9568a46c7dcfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19c2075878c59dfce9568a46c7dcfdf">&#9670;&#160;</a></span>flipud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">flipud </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flip array in the up/down direction.

Flip the entries in each column in the up/down direction.
Rows are preserved, but appear in a different order than before.

Parameters
----------
m : array_like
    Input array.

Returns
-------
out : array_like
    A view of `m` with the rows reversed.  Since a view is
    returned, this operation is :math:`\\mathcal O(1)`.

See Also
--------
fliplr : Flip array in the left/right direction.
rot90 : Rotate array counterclockwise.

Notes
-----
Equivalent to ``m[::-1,...]``.
Does not require the array to be two-dimensional.

Examples
--------
&gt;&gt;&gt; A = np.diag([1.0, 2, 3])
&gt;&gt;&gt; A
array([[ 1.,  0.,  0.],
       [ 0.,  2.,  0.],
       [ 0.,  0.,  3.]])
&gt;&gt;&gt; np.flipud(A)
array([[ 0.,  0.,  3.],
       [ 0.,  2.,  0.],
       [ 1.,  0.,  0.]])

&gt;&gt;&gt; A = np.random.randn(2,3,5)
&gt;&gt;&gt; np.all(np.flipud(A) == A[::-1,...])
True

&gt;&gt;&gt; np.flipud([1,2])
array([2, 1])</pre> 
</div>
</div>
<a id="a9f1d26026eb2f32e6849aa083d6c5d55" name="a9f1d26026eb2f32e6849aa083d6c5d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1d26026eb2f32e6849aa083d6c5d55">&#9670;&#160;</a></span>histogram2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">histogram2d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>range</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normed</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>density</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the bi-dimensional histogram of two data samples.

Parameters
----------
x : array_like, shape (N,)
    An array containing the x coordinates of the points to be
    histogrammed.
y : array_like, shape (N,)
    An array containing the y coordinates of the points to be
    histogrammed.
bins : int or array_like or [int, int] or [array, array], optional
    The bin specification:

      * If int, the number of bins for the two dimensions (nx=ny=bins).
      * If array_like, the bin edges for the two dimensions
        (x_edges=y_edges=bins).
      * If [int, int], the number of bins in each dimension
        (nx, ny = bins).
      * If [array, array], the bin edges in each dimension
        (x_edges, y_edges = bins).
      * A combination [int, array] or [array, int], where int
        is the number of bins and array is the bin edges.

range : array_like, shape(2,2), optional
    The leftmost and rightmost edges of the bins along each dimension
    (if not specified explicitly in the `bins` parameters):
    ``[[xmin, xmax], [ymin, ymax]]``. All values outside of this range
    will be considered outliers and not tallied in the histogram.
density : bool, optional
    If False, the default, returns the number of samples in each bin.
    If True, returns the probability *density* function at the bin,
    ``bin_count / sample_count / bin_area``.
normed : bool, optional
    An alias for the density argument that behaves identically. To avoid
    confusion with the broken normed argument to `histogram`, `density`
    should be preferred.
weights : array_like, shape(N,), optional
    An array of values ``w_i`` weighing each sample ``(x_i, y_i)``.
    Weights are normalized to 1 if `normed` is True. If `normed` is
    False, the values of the returned histogram are equal to the sum of
    the weights belonging to the samples falling into each bin.

Returns
-------
H : ndarray, shape(nx, ny)
    The bi-dimensional histogram of samples `x` and `y`. Values in `x`
    are histogrammed along the first dimension and values in `y` are
    histogrammed along the second dimension.
xedges : ndarray, shape(nx+1,)
    The bin edges along the first dimension.
yedges : ndarray, shape(ny+1,)
    The bin edges along the second dimension.

See Also
--------
histogram : 1D histogram
histogramdd : Multidimensional histogram

Notes
-----
When `normed` is True, then the returned histogram is the sample
density, defined such that the sum over bins of the product
``bin_value * bin_area`` is 1.

Please note that the histogram does not follow the Cartesian convention
where `x` values are on the abscissa and `y` values on the ordinate
axis.  Rather, `x` is histogrammed along the first dimension of the
array (vertical), and `y` along the second dimension of the array
(horizontal).  This ensures compatibility with `histogramdd`.

Examples
--------
&gt;&gt;&gt; import matplotlib as mpl
&gt;&gt;&gt; import matplotlib.pyplot as plt

Construct a 2-D histogram with variable bin width. First define the bin
edges:

&gt;&gt;&gt; xedges = [0, 1, 3, 5]
&gt;&gt;&gt; yedges = [0, 2, 3, 4, 6]

Next we create a histogram H with random bin content:

&gt;&gt;&gt; x = np.random.normal(2, 1, 100)
&gt;&gt;&gt; y = np.random.normal(1, 1, 100)
&gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
&gt;&gt;&gt; H = H.T  # Let each row list bins with common y range.

:func:`imshow &lt;matplotlib.pyplot.imshow&gt;` can only display square bins:

&gt;&gt;&gt; fig = plt.figure(figsize=(7, 3))
&gt;&gt;&gt; ax = fig.add_subplot(131, title='imshow: square bins')
&gt;&gt;&gt; plt.imshow(H, interpolation='nearest', origin='low',
...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])

:func:`pcolormesh &lt;matplotlib.pyplot.pcolormesh&gt;` can display actual edges:

&gt;&gt;&gt; ax = fig.add_subplot(132, title='pcolormesh: actual edges',
...         aspect='equal')
&gt;&gt;&gt; X, Y = np.meshgrid(xedges, yedges)
&gt;&gt;&gt; ax.pcolormesh(X, Y, H)

:class:`NonUniformImage &lt;matplotlib.image.NonUniformImage&gt;` can be used to
display actual bin edges with interpolation:

&gt;&gt;&gt; ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
&gt;&gt;&gt; im = mpl.image.NonUniformImage(ax, interpolation='bilinear')
&gt;&gt;&gt; xcenters = (xedges[:-1] + xedges[1:]) / 2
&gt;&gt;&gt; ycenters = (yedges[:-1] + yedges[1:]) / 2
&gt;&gt;&gt; im.set_data(xcenters, ycenters, H)
&gt;&gt;&gt; ax.images.append(im)
&gt;&gt;&gt; plt.show()</pre> 
</div>
</div>
<a id="a35a3640baeb79f967ff0349cf774584e" name="a35a3640baeb79f967ff0349cf774584e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a3640baeb79f967ff0349cf774584e">&#9670;&#160;</a></span>mask_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mask_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices to access (n, n) arrays, given a masking function.

Assume `mask_func` is a function that, for a square array a of size
``(n, n)`` with a possible offset argument `k`, when called as
``mask_func(a, k)`` returns a new array with zeros in certain locations
(functions like `triu` or `tril` do precisely this). Then this function
returns the indices where the non-zero values would be located.

Parameters
----------
n : int
    The returned indices will be valid to access arrays of shape (n, n).
mask_func : callable
    A function whose call signature is similar to that of `triu`, `tril`.
    That is, ``mask_func(x, k)`` returns a boolean array, shaped like `x`.
    `k` is an optional argument to the function.
k : scalar
    An optional argument which is passed through to `mask_func`. Functions
    like `triu`, `tril` take a second argument that is interpreted as an
    offset.

Returns
-------
indices : tuple of arrays.
    The `n` arrays of indices corresponding to the locations where
    ``mask_func(np.ones((n, n)), k)`` is True.

See Also
--------
triu, tril, triu_indices, tril_indices

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
These are the indices that would allow you to access the upper triangular
part of any 3x3 array:

&gt;&gt;&gt; iu = np.mask_indices(3, np.triu)

For example, if `a` is a 3x3 array:

&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)
&gt;&gt;&gt; a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
&gt;&gt;&gt; a[iu]
array([0, 1, 2, 4, 5, 8])

An offset can be passed also to the masking function.  This gets us the
indices starting on the first diagonal right of the main one:

&gt;&gt;&gt; iu1 = np.mask_indices(3, np.triu, 1)

with which we now extract only three elements:

&gt;&gt;&gt; a[iu1]
array([1, 2, 5])</pre> 
</div>
</div>
<a id="a16fae3f50ac344063c0919ba7f54d717" name="a16fae3f50ac344063c0919ba7f54d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fae3f50ac344063c0919ba7f54d717">&#9670;&#160;</a></span>tri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tri </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An array with ones at and below the given diagonal and zeros elsewhere.

Parameters
----------
N : int
    Number of rows in the array.
M : int, optional
    Number of columns in the array.
    By default, `M` is taken equal to `N`.
k : int, optional
    The sub-diagonal at and below which the array is filled.
    `k` = 0 is the main diagonal, while `k` &lt; 0 is below it,
    and `k` &gt; 0 is above.  The default is 0.
dtype : dtype, optional
    Data type of the returned array.  The default is float.

Returns
-------
tri : ndarray of shape (N, M)
    Array with its lower triangle filled with ones and zero elsewhere;
    in other words ``T[i,j] == 1`` for ``i &lt;= j + k``, 0 otherwise.

Examples
--------
&gt;&gt;&gt; np.tri(3, 5, 2, dtype=int)
array([[1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1]])

&gt;&gt;&gt; np.tri(3, 5, -1)
array([[ 0.,  0.,  0.,  0.,  0.],
       [ 1.,  0.,  0.,  0.,  0.],
       [ 1.,  1.,  0.,  0.,  0.]])</pre> 
</div>
</div>
<a id="af4a0a30b71887bc9c15050531e85a642" name="af4a0a30b71887bc9c15050531e85a642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a0a30b71887bc9c15050531e85a642">&#9670;&#160;</a></span>tril()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tril </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Lower triangle of an array.

Return a copy of an array with elements above the `k`-th diagonal zeroed.

Parameters
----------
m : array_like, shape (M, N)
    Input array.
k : int, optional
    Diagonal above which to zero elements.  `k = 0` (the default) is the
    main diagonal, `k &lt; 0` is below it and `k &gt; 0` is above.

Returns
-------
tril : ndarray, shape (M, N)
    Lower triangle of `m`, of same shape and data-type as `m`.

See Also
--------
triu : same thing, only for the upper triangle

Examples
--------
&gt;&gt;&gt; np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12]])</pre> 
</div>
</div>
<a id="abe05fd6b74b3e7375454305ba5d2bffd" name="abe05fd6b74b3e7375454305ba5d2bffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe05fd6b74b3e7375454305ba5d2bffd">&#9670;&#160;</a></span>tril_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tril_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the lower-triangle of an (n, m) array.

Parameters
----------
n : int
    The row dimension of the arrays for which the returned
    indices will be valid.
k : int, optional
    Diagonal offset (see `tril` for details).
m : int, optional
    .. versionadded:: 1.9.0

    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple of arrays
    The indices for the triangle. The returned tuple contains two arrays,
    each with the indices along one dimension of the array.

See also
--------
triu_indices : similar function, for upper-triangular.
mask_indices : generic function accepting an arbitrary mask function.
tril, triu

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Compute two different sets of indices to access 4x4 arrays, one for the
lower triangular part starting at the main diagonal, and one starting two
diagonals further right:

&gt;&gt;&gt; il1 = np.tril_indices(4)
&gt;&gt;&gt; il2 = np.tril_indices(4, 2)

Here is how they can be used with a sample array:

&gt;&gt;&gt; a = np.arange(16).reshape(4, 4)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

&gt;&gt;&gt; a[il1]
array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])

And for assigning values:

&gt;&gt;&gt; a[il1] = -1
&gt;&gt;&gt; a
array([[-1,  1,  2,  3],
       [-1, -1,  6,  7],
       [-1, -1, -1, 11],
       [-1, -1, -1, -1]])

These cover almost the whole array (two diagonals right of the main one):

&gt;&gt;&gt; a[il2] = -10
&gt;&gt;&gt; a
array([[-10, -10, -10,   3],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10]])</pre> 
</div>
</div>
<a id="a1ea2d6007161d48d33b348e28f2f0361" name="a1ea2d6007161d48d33b348e28f2f0361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea2d6007161d48d33b348e28f2f0361">&#9670;&#160;</a></span>tril_indices_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tril_indices_from </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the lower-triangle of arr.

See `tril_indices` for full details.

Parameters
----------
arr : array_like
    The indices will be valid for square arrays whose dimensions are
    the same as arr.
k : int, optional
    Diagonal offset (see `tril` for details).

See Also
--------
tril_indices, tril

Notes
-----
.. versionadded:: 1.4.0</pre> 
</div>
</div>
<a id="abd1903e2d096119cc63674d318c41589" name="abd1903e2d096119cc63674d318c41589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1903e2d096119cc63674d318c41589">&#9670;&#160;</a></span>triu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">triu </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Upper triangle of an array.

Return a copy of a matrix with the elements below the `k`-th diagonal
zeroed.

Please refer to the documentation for `tril` for further details.

See Also
--------
tril : lower triangle of an array

Examples
--------
&gt;&gt;&gt; np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12]])</pre> 
</div>
</div>
<a id="ab549c5bd536bd3f53931b844669220e9" name="ab549c5bd536bd3f53931b844669220e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab549c5bd536bd3f53931b844669220e9">&#9670;&#160;</a></span>triu_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">triu_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the upper-triangle of an (n, m) array.

Parameters
----------
n : int
    The size of the arrays for which the returned indices will
    be valid.
k : int, optional
    Diagonal offset (see `triu` for details).
m : int, optional
    .. versionadded:: 1.9.0

    The column dimension of the arrays for which the returned
    arrays will be valid.
    By default `m` is taken equal to `n`.


Returns
-------
inds : tuple, shape(2) of ndarrays, shape(`n`)
    The indices for the triangle. The returned tuple contains two arrays,
    each with the indices along one dimension of the array.  Can be used
    to slice a ndarray of shape(`n`, `n`).

See also
--------
tril_indices : similar function, for lower-triangular.
mask_indices : generic function accepting an arbitrary mask function.
triu, tril

Notes
-----
.. versionadded:: 1.4.0

Examples
--------
Compute two different sets of indices to access 4x4 arrays, one for the
upper triangular part starting at the main diagonal, and one starting two
diagonals further right:

&gt;&gt;&gt; iu1 = np.triu_indices(4)
&gt;&gt;&gt; iu2 = np.triu_indices(4, 2)

Here is how they can be used with a sample array:

&gt;&gt;&gt; a = np.arange(16).reshape(4, 4)
&gt;&gt;&gt; a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

Both for indexing:

&gt;&gt;&gt; a[iu1]
array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])

And for assigning values:

&gt;&gt;&gt; a[iu1] = -1
&gt;&gt;&gt; a
array([[-1, -1, -1, -1],
       [ 4, -1, -1, -1],
       [ 8,  9, -1, -1],
       [12, 13, 14, -1]])

These cover only a small part of the whole array (two diagonals right
of the main one):

&gt;&gt;&gt; a[iu2] = -10
&gt;&gt;&gt; a
array([[ -1,  -1, -10, -10],
       [  4,  -1,  -1, -10],
       [  8,   9,  -1,  -1],
       [ 12,  13,  14,  -1]])</pre> 
</div>
</div>
<a id="add96b8e061ed54e0cd1c208e981585a6" name="add96b8e061ed54e0cd1c208e981585a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add96b8e061ed54e0cd1c208e981585a6">&#9670;&#160;</a></span>triu_indices_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">triu_indices_from </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices for the upper-triangle of arr.

See `triu_indices` for full details.

Parameters
----------
arr : ndarray, shape(N, N)
    The indices will be valid for square arrays.
k : int, optional
    Diagonal offset (see `triu` for details).

Returns
-------
triu_indices_from : tuple, shape(2) of ndarray, shape(N)
    Indices for the upper-triangle of `arr`.

See Also
--------
triu_indices, triu

Notes
-----
.. versionadded:: 1.4.0</pre> 
</div>
</div>
<a id="a91ff6907cb8bacb08813dc6eecce8796" name="a91ff6907cb8bacb08813dc6eecce8796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ff6907cb8bacb08813dc6eecce8796">&#9670;&#160;</a></span>vander()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vander </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>increasing</em> = <code><a class="el" href="cxbool_8h.html#a306ebd41c0cd1303b1372c6153f0caf8">False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a Vandermonde matrix.

The columns of the output matrix are powers of the input vector. The
order of the powers is determined by the `increasing` boolean argument.
Specifically, when `increasing` is False, the `i`-th output column is
the input vector raised element-wise to the power of ``N - i - 1``. Such
a matrix with a geometric progression in each row is named for Alexandre-
Theophile Vandermonde.

Parameters
----------
x : array_like
    1-D input array.
N : int, optional
    Number of columns in the output.  If `N` is not specified, a square
    array is returned (``N = len(x)``).
increasing : bool, optional
    Order of the powers of the columns.  If True, the powers increase
    from left to right, if False (the default) they are reversed.

    .. versionadded:: 1.9.0

Returns
-------
out : ndarray
    Vandermonde matrix.  If `increasing` is False, the first column is
    ``x^(N-1)``, the second ``x^(N-2)`` and so forth. If `increasing` is
    True, the columns are ``x^0, x^1, ..., x^(N-1)``.

See Also
--------
polynomial.polynomial.polyvander

Examples
--------
&gt;&gt;&gt; x = np.array([1, 2, 3, 5])
&gt;&gt;&gt; N = 3
&gt;&gt;&gt; np.vander(x, N)
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

&gt;&gt;&gt; np.column_stack([x**(N-1-i) for i in range(N)])
array([[ 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1]])

&gt;&gt;&gt; x = np.array([1, 2, 3, 5])
&gt;&gt;&gt; np.vander(x)
array([[  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1]])
&gt;&gt;&gt; np.vander(x, increasing=True)
array([[  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125]])

The determinant of a square Vandermonde matrix is the product
of the differences between the values of the input vector:

&gt;&gt;&gt; np.linalg.det(np.vander(x))
48.000000000000043
&gt;&gt;&gt; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)
48</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac6ef61fb0fec52abd81fd71388742cc0" name="ac6ef61fb0fec52abd81fd71388742cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ef61fb0fec52abd81fd71388742cc0">&#9670;&#160;</a></span>i1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i1 = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int8)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fce890a7c411f1fe7c0c55ec9eb4106" name="a2fce890a7c411f1fe7c0c55ec9eb4106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fce890a7c411f1fe7c0c55ec9eb4106">&#9670;&#160;</a></span>i2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2 = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int16)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a608e2266a7f74d5814905a52df1fc084" name="a608e2266a7f74d5814905a52df1fc084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608e2266a7f74d5814905a52df1fc084">&#9670;&#160;</a></span>i4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i4 = <a class="el" href="classnumpy_1_1core_1_1getlimits_1_1iinfo.html">iinfo</a>(int32)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1twodim__base.html">twodim_base</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
